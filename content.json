{"pages":[{"title":"","text":"这是关于","link":"/about.html"}],"posts":[{"title":"Q&amp;A","text":"待解答： HTTP1, HTTP2, HTTPS、 浏览从输入网址到回车发生了什么、 前端跨域、 浏览器缓存、 cookie, session, token, localstorage, sessionstorage、 状态码、 TCP连接(三次握手, 四次挥手) XSS（cross-site-scripting）跨站脚本攻击 CDN","link":"/2020/09/30/%E7%BD%91%E7%BB%9C/Q&A/"},{"title":"2020年09月30日","text":"需求理解能力，业务建模能力，流程规范能力是比你看懂点底层框架梗直接高效的点","link":"/2020/09/30/%E9%9A%8F%E7%AC%94/2020%E5%B9%B409%E6%9C%8830%E6%97%A5/"},{"title":"CSS pixels, physical pixels, logical pixels, device pixel ratio, PPI, Viewport","text":"css 像素：px 物理像素：pt（设备像素） 分辨率 像素比：dpr-device pixel ratio （1px = dpr^2 * 1pt） 设备独立像素：dip-device independent pixel（又称逻辑像素） ppi：pixel per inch（每一英寸拥有的像素数）像素密度，衡量单位面积内的拥有像素值的情况 retina 显示屏 疑问： 为什么 iOS 有@1、@2、@3 的区别？ 1. PX像素，为显示影像的基本单位。译自 pixel ， pixel 为 picture element 的缩写。像素是相对单位。 2. DP物理像素， device pixel 。顾名思义，物理意义上的点阵集，单位是 PT，是绝对单位，即每个屏幕的物理像素是固定的。 分辨率","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/CSS/CSS%20pixels,%20physical%20pixels,%20logical%20pixels,%20device%20pixel%20ratio,%20PPI,%20Viewport/"},{"title":"Flex","text":"Flex 是 flexible box （可伸缩盒子）的简称。 传统的布局解决方案： 基于 table（CSS3.0 未实现之前的方案，已废弃） 基于盒模型，依赖于 display 、 position 、 float 属性 传统布局多少有失灵活性和不方便性，flex 则进行了相应的提升。 1、基本概念采用 Flex 布局的元素，称为 Flex 容器，他的所有子元素自动成为容器成员，称为 Flex 项目（flex item）。 容器默认存在两根轴：主轴（main axis）和交叉轴（cross axis） 主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end 交叉轴的开始位置叫做 cross start，结束位置叫做 cross end 项目默认沿主轴排列，单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size 2. 容器属性Flex 容器有以下 6 个属性： flex-direction flex-wrap flex-flow justify-content align-items align-content 2.1、flex-directionflex-direction 属性决定主轴的方向（即项目的排列方向）： 123.box { flex-direction: row | row-reverse | column | column-reverse;} 2.2、flex-wrapflex-wrap 决定 flex item 超出一排长度时是否换行。 默认为不换行 flex item 对于宽度的分割按照 width 、 flex 属性的定义，如果都为 width 而且超出了，则会被压缩，否则按照 flex 属性的定义分割 123.box { flex-wrap: nowrap | wrap | wrap-reverse;} 2.3、flex-flowflex-flow 是 flex-direction 和 flex-wrap 的缩写。 123.box { flex-flow: &lt;flex-direction&gt; | &lt;flex-wrap&gt; ;} 2.4、justify-contentjustify-content 属性定义了 flex-item 在主轴上的对齐方式。 123.box { justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;} 2.5、align-itemsalign-items 属性定义 flex item 在交叉轴上如何排列。 123.box { align-items: flex-start | flex-end | center | baseline | stretch;} 2.6、align-contentalign-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box { align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch;} 3、项目属性Flex 容器有以下 6 个属性： order flex-grow flex-shrink flex-basis flex align-self3.1、order order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 3.2、flex-growflex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 比如：如果所有项目的 flex-grow 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3.3、flex-shrinkflex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 比如：如果所有项目的 flex-shrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为0，其他项目都为1，则空间不足时，前者不缩小。 3.4、flex-basisflex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto ，即项目的本来大小。 它可以设为跟 width 或 height 属性一样的值（比如350px），则项目将占据固定空间。 3.5、flexflex 属性是 flex-grow , flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto 。后两个属性可选。 3.6、align-selfalign-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto ，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch 。 参考文档： https://xluos.github.io/demo/flexbox/ http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/CSS/Flex/"},{"title":"Q&amp;A","text":"什么是 Shadow Dom web component","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/CSS/Q&A/"},{"title":"居中","text":"页面如下结构： 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;内容&lt;/div&gt;&lt;/div&gt; 1、水平居中123456789101112131415161718192021222324252627282930// margin: 0 auto;.parent { .child { margin: 0 auto; }}// text-align + inline-block.parent { text-align: center; .child { display: inline-block; }}// absolute + translate.parent { position: relative; .child { position: absolute; left: 50%; transform: translateX(-50%); }}// flex.parent { display: flex; justify-content: center;} 2、垂直居中123456789101112131415161718192021// table-cell + vertical-align.parent { display: table-cell; vertical-align: middle;}// absolute + translate.parent { position: relative; .child { position: absolute; top: 50%; transform: translateY(-50%); }}// flex.parent { display: flex; align-items: center;} 3、垂直、水平居中123456789101112131415161718192021222324252627// absolute + translate.parent { position: relative; .child { position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); }}// table-cell、text-align.parent { display: table-cell; vertical-align: middle; text-align: center; .child { display: inline-block; }}// flex.parent { display: flex; justify-content: center; align-items: center;}","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/CSS/%E5%B1%85%E4%B8%AD/"},{"title":"Q&amp;A","text":"什么是 Shadow Dom web component","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/HTML/Q&A/"},{"title":"Q&amp;A","text":"待解答 继承 原型链、 this指向、 设计模式、 call, apply, bind, new实现、 防抖节流、 let, var, const 区别、 EventLoop、有哪些宏任务和微任务？ promise使用及实现、promise并行执行和顺序执行 闭包、 垃圾回收和内存泄漏、 数组方法、 数组乱序, 数组扁平化、 事件委托、事件监听、事件模型、 typescript 函数式编程和面向对象编程 内存管理和垃圾回收 bind、call、apply 箭头函数和普通函数的区别？能不能作为构造函数？ 文档引用 异步How JavaScript Timers Work 乱纪","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/JavaScript/Q&A/"},{"title":"内置对象","text":"1、简介 1.1 概述像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc() 和 free() 。相反，JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让 JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。 1.2 生命周期不管什么程序语言，内存生命周期基本是一致的： 分配 使用 释放/归还 2、JavaScript 内存分配 2.1 初始化1234567891011121314151617181920212223242526272829// 给数值变量分配内存var n = 123;// 给字符串分配内存var s = &quot;azerty&quot;; // 给对象及其包含的值分配内存var o = { a: 1, b: null};// 给数组及其包含的值分配内存（就像对象一样）var a = [1, null, &quot;abra&quot;]; // 给函数（可调用的对象）分配内存function f(a){ return a + 2;}// 函数表达式也能分配一个对象someElement.addEventListener('click', function(){ someElement.style.backgroundColor = 'blue';}, false);// 分配一个 Date 对象var d = new Date(); // 分配一个 DOM 元素var e = document.createElement('div'); 2.2 使用值使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。 2.3 释放大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“哪些被分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。 3、垃圾回收如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。 3.1 引用垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。 3.2 算法 3.2.1 引用计数这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 示例123456789101112131415var o = { a: { b:2 }}; // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o// 很显然，没有一个可以被垃圾收集var o2 = o; // o2变量是第二个对“这个对象”的引用o = 1; // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有var oa = o2.a; // 引用“这个对象”的a属性 // 现在，“这个对象”有两个引用了，一个是o2，一个是oao2 = &quot;yo&quot;; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了 // 但是它的属性a的对象还在被oa引用，所以还不能回收oa = null; // a属性的那个对象现在也是零引用了 // 它可以被垃圾回收了 限制：循环引用该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 12345678function f(){ var o = {}; var o2 = {}; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o return &quot;azerty&quot;;}f(); 实际例子IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏： 123456var div;window.onload = function(){ div = document.getElementById(&quot;myDivElement&quot;); div.circularReference = div; div.lotsOfData = new Array(10000).join(&quot;*&quot;);}; 在上面的例子里，myDivElement 这个 DOM 元素里的 circularReference 属性引用了myDivElement，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的lotsOfData 属性)，而这个数据占用的内存将永远不会被释放。 3.2.2 标记清楚这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。循环引用不再是问题了在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。限制: 那些无法从根对象查询到的对象都将被清除尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/JavaScript/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"Q&amp;A","text":"待解答： vue数据双向绑定原理(对象、defineProperty、set/get、数组、.sync) vue computed原理、 vue编译器结构图、 生命周期、 vue组件通信、 mmvm模式、 mvc模式理解、 vue dom diff、 vuex、 vue-router sync 修饰符的用处 怎么理解单项数据流 双向绑定 v-model 是什么？怎么自定义？和 react 受控组件的对比 v-slot 如何使用？作用域是什么？ 依赖注入怎么用？ #### 1. v-for 和 v-if 同时存在会怎样？ for 和 if 作用在同一个模板节点上，会有两种意图： for 包裹 if12345for (let i = 0; i &lt; arr.length; i++) { if(i &lt; 3) { // some }} if 包裹 for12345if(expression) { for (let i = 0; i &lt; arr.length(); i++) { // some }} 一般不要这样用，但如果这样使用了，vue 会采用第一种逻辑处理。 2. 如何理解单项数据流和操作 3. 计算属性和方法的区别","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/React/Q&A/"},{"title":"大纲","text":"","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/React/%E5%A4%A7%E7%BA%B2/"},{"title":"Q&amp;A","text":"待解答： vue数据双向绑定原理(对象、defineProperty、set/get、数组、.sync) vue computed原理、 vue编译器结构图、 生命周期、 vue组件通信、 mmvm模式、 mvc模式理解、 vue dom diff、 vuex、 vue-router sync 修饰符的用处 怎么理解单项数据流 双向绑定 v-model 是什么？怎么自定义？和 react 受控组件的对比 v-slot 如何使用？作用域是什么？ 依赖注入怎么用？ #### 1. v-for 和 v-if 同时存在会怎样？ for 和 if 作用在同一个模板节点上，会有两种意图： for 包裹 if12345for (let i = 0; i &lt; arr.length; i++) { if(i &lt; 3) { // some }} if 包裹 for12345if(expression) { for (let i = 0; i &lt; arr.length(); i++) { // some }} 一般不要这样用，但如果这样使用了，vue 会采用第一种逻辑处理。 2. 如何理解单项数据流和操作 3. 计算属性和方法的区别","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/Vue/Q&A/"},{"title":"生命周期","text":"","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/Vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"语义化版本 2.0.0","text":"摘要版本格式：主版本号.次版本号.修订号，版本号递增规则如下： 主版本号：当你做了不兼容的 API 修改， 次版本号：当你做了向下兼容的功能性新增， 修订号：当你做了向下兼容的问题修正。 先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。 简介在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。在依赖高的系统中发布新版本包可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个依赖包改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你专案的进展因为版本依赖被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共 API 。这可以透过文件定义或代码强制要求来实现。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z （主版本号.次版本号.修订号）修复问题但不影响API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。 语义化版本控制规范（SemVer）以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。（译注：为了保持语句顺畅， 以下文件遇到的关键词将依照整句语义进行翻译，在此先不进行个别翻译。） 使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。 标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。 标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。 修订号 Z（x.y.Z | x &gt; 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。 次版本号 Y（x.Y.z | x &gt; 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。 主版本号 X（X.y.z | X &gt; 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。 先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。 版本编译元数据可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译元数据可（SHOULD）被忽略。因此当两个版本只有在版本编译元数据有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译元数据不在这份比较的列表中）。由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符比非数字的标识符优先层级低。若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0。 为什么要使用语义化的版本控制？这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函式库，它需要另一个名为“梯子”并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能， 你可以放心地指定依赖于梯子的版本号大等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函式库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页连结，让别人也知道这些规则并从中受益。 FAQ在 0.y.z 初始开发阶段，我该如何进行版本控制？最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。 如何判断发布 1.0.0 版本的时机？当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。 这不会阻碍快速开发和迭代吗？主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。 对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。 为整个公共 API 写文件太费事了！为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。 万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。 如果我更新了自己的依赖但没有改变公共 API 该怎么办？由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。 如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。 我该如何处理即将弃用的功能？弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。 语义化版本对于版本的字串长度是否有限制呢？没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC/"},{"title":"Vue 和 React","text":"为什么 React 比 Vue 火React的灵活性高于Vue，这就决定了它的上限。为什么说React的灵活性高于Vue？理由一：模板。我们来可以对比下React的jsx和vue的模板：JSX其实是一种语法糖，因为最终经过编译后实际上就是React.createElement，所以我认为他不是模板是语法糖，但他能提供类似模板的直观表现形式，且跟JS语言完美的融合在一起，如果你非要把他看做模板，那也是个具有图灵完备的模板语法，简直完美，而且还不需要额外学习新的模板语言，你只需要学习好JS就行。Vue模板则是自定义一套DSL语言，他有自己的一套语法，如v-if v-for。这其实是增加了学习，理解，后期维护成本。这种类型的模版还存一个很大的问题，就是灵活性不足，所以只能添加各种指令或标签来提高灵活性，只要是模板型框架你不可避免要学习一大堆模板语法。当然你可以说vue也支持jsx，我也可以用jsx，但这其实不符合vue开发模式的，而且vue的比较热门的UI库，有的内部实现其实是用了jsx，我只能说：真乱。灵活性的不足最终限制开发者的创造力，在这种情况下，必然会有部分开发者跳出这种模式，寻找新的开发模式，比如React或理念更先进框架。理由二：数据流。React是单向的，这其实非常清晰，视图的改变必须通过setState来触发Vue是双向的，这可能在刚开始接触的时候看起来非常美好，但这种微妙关系真的是个坑，如果我想刷新视图，我其实只能改变数据模型的相关数据，很多时候我非得加个watch或computed来处理，难道用Vue的对这一层概念不觉得啰嗦没吗？这里要提下小程序，它的开发模式其实我也不喜欢，但小程序是因为渲染机制不一样，我接受了，但是使用了setData来明确UI更新入口，我觉得是非常正确的。注：评论指出的双向问题我这里的描述确实不是很准确。我想表达的意思是：数据绑定（数据和视图可以互相影响）。它的体现是：操作数据会直接体现在UI上，这可能在刚开始接触的时候看起来非常美好，但这种微妙关系，会带来一定的心智负担及问题排查。另外社区活跃再知乎看到过一个回答，React开发者都忙着造轮子，我其实是认同这说法的，这并不是说React的社区没有这个轮子，而是React给了你种感觉，我也可以轻松的造出来，并能轻松分享到社区及项目中使用。相反Vue其实给我的感觉就是在于一些状态库，路由库，动画库上都是官方提供了一套，而是他们必须得和Vue有种深层次关联，这注定了普通开发者没办法写的。如果你的项目只是CRUD的功能，用vue jquery angular react其实都无所谓，因为确实都能很轻松满足，但如果你的项目具有较高的灵活性和规模的时候我的推荐是：React。","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/Vue%20%E5%92%8C%20React/"},{"title":"业务中台系统的一些想法 [原创]","text":"正直商家一期的契机，商家中心后台迎来大改版的机会，在经历了整个商家中心的重构之后，给我们中台系统建设的思路带来了哪些问题，又该有哪些思考？ 解决方案很多人喜欢讲解决方案，那么什么才是解决方案，电商系统？Sass？Antd？如果站在一个初创期公司的一线前端开发人员的角度来讲，对于内外部中后台系统，可以认为一整套的快速高效、质量可靠的业务满足流程就是一套解决方案。 工程化下面是之前在微博上看到的对前端工程化的理解，其实这里更确切的讲是广义上的前端工程。 什么是前端工程？其实就是面向具体的业务形态，抽象的一套标准化研发过程管理方法。通过规范化的研发全生命周期管理，帮助团队高质高效地保障业务生长。一定规模的前端工程化，少不了数据收集、权限管控、流程管控、规范设计、工具整合等；并非所有的团队都需要实现前端工程化，小规模的组织或个人通过工具提效即可满足基本诉求，复杂的工程管理维护的成本是巨高的，不同业务类型的前端工程设计也会存在差异。前端工程的演进，大致为：工具化-&gt;流程化-&gt;工程化-&gt;平台化，足够体量的规模才需要进入平台化，进入平台化，也意味着统一和一致协同，业务的个性化差异太多，抹平不同团队的差异，阻力很大。一个好的思路是“全控代码、扼制发布”。然后再看一个系统演变的一般的节奏是什么样子？ 我们现在处于哪个阶段其实很明显，被需求绊住了腿、被业务压完了腰的起步阶段，阶段不同，所以核心目标也会不一样。 中台系统对于中台系统，MVVM + UI Library 基本就可以满足90%的业务需求。那么这个阶段我们 要不要交互？ 要不要视觉？ 要不要自研所有的工具？ 要不要做规范输出？ 要不要做基础平台支撑？ 我的理解是不需要，起码是大部分都不需要。以新的商家中心作为例子来说，核心是 Vue + AntD(Vue) ，其他的npm包只是零星的功能点暂且不表。一个中台系统要解决的问题包括： 菜单、路由、权限（为什么将这三者合并到一起来讲，因为在常规的设计上他们是高耦合的）； 网络请求（错误码要做哪些统一封装？接口模块按照页面级还是后端微服务维度？） webpack配置（devServer、拆包优化、打包路径、压缩等等的处理，其实Vue和React现在都倾向于脚手架定制，但还是要关心） Utils（模块划分合理，达成共识，增量添加，不要出现分叉各用各的） 状态管理（做了这么多项目下来，其实真正将状态管理重度使用的场景并不是很多，大多数只是用来做了登录态的保存，这还是结合了本地存储的能力） 公共组件（这是一个存在巨大分歧的地方，像对form表单的封装，做不好最后就会成为项目里最头疼的一块，本身form表单组件设计就复杂，然后你做一层看似提效的抽象，殊不知无形中又加重了开发人员的理解成本） 只要合理的解决了上面所提到这些问题，然后具象后落地为一套模板，无论公司启动多少新的项目，新的系统，PRD给过来，合理的工时评估是可期的，而且开发模式共通，相互之间的技术补位也成为可能（当然业务逻辑复杂的场景补位还是会存在问题）。","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%8F%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%20%5B%E5%8E%9F%E5%88%9B%5D/"},{"title":"从 1 人到50 多人，阿里人工智能资深技术专家管理心路","text":"来阿里两年多了，从 1 个人，到现在带领 50 多人的团队，走过了一段艰辛的充满变化的带团队历程，在这里总结下自己过去两年带 15 个人，带 50 个人的不同管理方法。1个人的时候，啥也别说，什么都是自己干，不管是写代码，架构设计，业务沟通，工作协调，都得自己亲力亲为。很快， 3 个月后，我招聘到了第一个兵，因此我把代码工作移交给他，我自己负责架构设计，沟通和协调工作。9 个月后，我已经招聘了 7 个人，有了一支小部队了，因此我开始真正的研发管理。不久后我的团队人数增加到 15 人，而且团队成员横跨杭州和深圳，异地管理问题就出来了。我的方法是，在深圳需要确立一个 Leader ，这个 Leader 需要经常来杭州和杭州团队互动，然后他把杭州大本营的一些工作方式，团队文化带回给深圳团队。当然，我们也会不定期在深圳或者杭州开大团队会议， 15 个同学聚在一起，共创未来。这个阶段，由于队伍还很小，领导风格更加应该是兄弟们跟我上。以下是我在这个阶段的一些管理动作： 一、开周会，周会开什么？1、不要报流水账，滔滔不绝介绍自己的工作流水，而是要说一些需要大家注意的技术风险，需要大家了解的新技术、项目情况、行业信息，或者需要大家协同的工作。2、团队技术分享，大家可以把自己做的工作抽象提炼总结出来，给大家分享技术干货，独乐乐，不如众乐乐。一般 15 分钟的分享比较合适，不宜过长。细节部分可以通过沉淀 ATA 技术文章分享出来。3、不定期的批评&amp;自我批评，团队成员可以互相指出一些工作中的不足，提醒帮助对方改进，通过这个营造开诚布公，透明的团队氛围。 二、指导员工工作由于很多细节工作交给了一线员工，所以管理者可能没有办法了解每一个技术细节，因此需要经常和一线员工沟通技术，对他们的工作给予指导，但是这里要强调是指导，而不是命令和安排。现在的脑力劳动，和体力劳动有很大区别，其中员工的主观能动性非常重要，因此如果员工有很多想法，哪怕有些不是特别被主管看好，我们也要鼓励他们去按照自己的思路去尝试，而不是一味的让员工按照自己的想法来做。当然，主管虽然不直接反对员工的想法，但是可以根据自己的工作经验告诉员工哪里有风险，避免他们出现重大失误，影响了项目的进度。 三、协调资源很多工作是跨团队的，这个时候主管需要和其他团队互动，帮助协调工作。另外，员工碰到了资源瓶颈，也需要主管去协调资源。 四、识别项目风险作为主管，其中一个重要工作就是，随时 review 项目进度，根据自己更加丰富的工作经验，未雨绸缪，提前识别项目中的技术风险，并协调研发资源投入项目，及时消除技术风险。再后来，我的团队人数快速增加到 50 多个人，这个时候工作地点横跨杭州、深圳、上海、北京。异地管理挑战更大了。这个阶段的领导风格不仅仅是兄弟们跟我上了，更加需要做好排兵布阵。我做了以下两件事：第一件事，跳出原来的工作方式，站在全局角度了解当前部门业务场景、技术栈、工作流程和核心工作内容，尽快熟悉团队工作情况。第二件事，了解和熟悉团队中每个工程师他们的工作能力如何？擅长什么方面？性格特点是什么、主观能动性如何等等。了解团队每个人实际也是为未来排兵布阵打下基础，把合适的人安排在合适的位置，因人成事。一个团队如果具有很强凝聚力，目标一致、每个人都有较高积极性投入工作，发挥各自优势和潜力，对工作成果有责任心，有担当，在这样的团队中才会做出出色成绩。因此，基于打造团队凝聚力的考虑，我做了以下的管理动作。 五、成立技术委员会由于团队有 50 多人，涉及的技术面越来越多，不同的 Leader 掌握不同的技术领域，互相可能不太熟悉彼此的技术领域，所以我决定成立技术委员会（10人左右），由不同小组的leader参加，可以通过这个会议，互通有无，大家畅所欲言，献计献策，群策群力。同时，这个会议还会定期邀请 2 位一线优秀员工旁听，这即是对他们平时努力工作的肯定，也让他们体会我们的团队管理文化。另外，技术委员会委员们会组织大家撰写 ATA 技术文章，每半年会发布一个团队的 ATA 文章汇总，然后分享给所有人，打造团队的技术影响力，同时也提高了每个人的技术分享能力。 六、建立公共知识库由于团队人数太多，通过口口相传，或者培训还不足以快速共享知识，因此我们在语雀建立了 AIOT 知识库，大家把自己的知识沉淀到一个公共平台，这样作为管理者也可以随时了解技术和项目的细节，补足宏观思考的漏洞，当然也有利于同学们的知识传承和共享。 七、定期听取一线声音管理者了解团队成员快速上手方法：一对一沟通。定期听取一线声音，可以更加全面的看人、看事。特别是，通过定期访谈，可以更多了解某些同学的优缺点，为将来的排兵布阵做好准备。在沟通中，可以把团队中的同学进行四象限分类，后续管理可以做到有的放矢逐个击破。比如设定 x 轴为工作中积极性， y 轴为工作中的能力。第一象限积极性高、能力好，这样的人是团队中的骨干员工，第二象限是积极性不高，能力还不错，对管理有的会表现出自持傲才，不友好反应。第三象限是能力不行，积极性也不行。第四象限是积极性高，能力不太好。后续的管理动作需要做的是就是给予第一象限的人更大空间，努力把第二和第四象限的人转化到第一象限。 八、季度答疑会有很多工程师，平时忙于写代码，也很少有时间思考和学习成长。而作为管理者，在思维模式、思考角度都有更多的先进性。通过每个季度和一线员工展开案例答疑会，可以快速把自己行之有效的方法论、思维模式、思考角度传承给同学，这样的有血有肉的案例答疑会，比单纯的说教更加有体感和效果。在具体操作上，我会收集大家的问题案例（脱敏），比如一个季度收集 12 个案例（关于工作强度，关于做非重点项目的价值，关于越级汇报，，，），我在会上一一发表我对这些事情的看法，大家通过这样一个个自己关心的问题，立即能获得看问题的新角度，同时也能打造透明的团队文化。 九、年度国情咨文一线工程师其实也很希望听到团队 leader 对技术的未来预判，因此我搞了一个年度的国情咨文会议，各个 leader 各自做一份关于自己技术领域的 Roadmap ，汇总成一份大的团队 Roadmap ，并让每个 leader 上台分享自己的技术观，和一线同学问答互动，同时一线同学也会给这些 leader 打分，互相促进成长。 十、年度代码红草莓烂草莓由于我们是研发团队，代码做的好不好，代码风格是否统一，直接影响了工作效率。还有文档做的好不好，也影响了协同效率。因此每年我们都会举行红草莓烂草莓大会，大家一起来评选最好代码贡献者。当然主管也会分享自己对代码的看法，传递团队要什么样的代码，不要什么样的代码。 十一、 LOT 计划由于我们是知识密集型团队，因此打造一个持续学习团队非常关键，LOT（Learning Organization Training）计划就是这样的管理动作，包含了LOT-T（技术），LOT-M（管理），LOT-E（英语），LOT-B（业务）四大培训计划，一般安排在每周二、四晚上 19：30 ，通过这些培训，同学们既获得了成长，也激发了学习爱好。 十二、 OKR 管理OKR 管理是指 Objectives and Key Results 。探索 KPI+OKR 结合的管理模式， KPI 是大方向， OKR 是过程管理。注重过程管理，每 2 个月，需要给同学们 Review OKR ，及时给同学反馈调整，并通晒结果，让同学们对自己和他人的成绩有预期，在年度 KPI 考核的时候做到心中有数，没有 Suprising ，也可以宣扬团队肯定什么，不认可什么。 十三、私董会其实每个人都有上进之心，但是很多时候，并不知道自己的问题在哪里？如何改进，以及缺乏监督者。私董会就是一个非常好的给同学反馈改进方向的场子。每次可以安排一两个同学作为案主，然后大家按照私董会的流程给案主定义问题，分析问题，解决问题。通过私董会，同学们都大呼刺激，都希望成为案主，毕竟要找这么多高段位的同学给自己诊断问题，这个机会实在太珍贵了。 十四、关于团建团队成员们通过团建熟悉了彼此的背景、经历、兴趣爱好、为人处事的风格。那么，有时候一些小磕小碰，也就能够互相体谅了。而且平时大家工作都忙，甚至不在一个城市工作，那么，团建就是一个增加彼此认识的好场子。所以团建不要只是吃吃喝喝，更需要拉近同事互相之间的距离，比如把大家聚在一起，做一个分享个人最有感悟的故事的小游戏，通过每个人的发言拉近距离。后记：很多人从一线工程师提拔为管理者，总是喜欢和一线工程师抢活干，比如不是指导员工解决问题，而是经常自己捋起袖子亲自上阵，他的内心戏是这样的，如果干不好管理，还可以回来做一线工程师。其实很多时候，自己给自己留退路反而做不好工作（管理）。另外，如果你不学着放手，不去学习其他新能力（新技术方向，技术前瞻性，技术广度），那么你只是把一个会做的工作（技术）做的更好了一丢丢，但是你很快就会成为团队的天花板，最后，所谓的留后路，其实也是不学习，不成长，懒惰的表现，这是一种固定思维，而不是我们鼓励的成长思维！有时候“背水一战”是对管理者的最好的鞭策。作者信息：崮德， 2005 年毕业于浙江大学，获得电路与系统硕士学位，后加入华为，从事 2G 和 3G 的基站开发。2006 年加盟上海晨讯科技，负责功能手机、智能手机以及物联网通信模块（2G/3G Module），主导设计了 GPS 追踪器，平板电脑等智能硬件。2012 年创办上海同时信息科技，专注于蓝牙 BLE 智能硬件，主导设计了智能防丢器，智能钱包，智能行李牌等30多个产品，累计提交了 20 多项的物联网专利，是蓝牙 BLE&amp;mesh 方面的资深专家。2017 年加入阿里巴巴人工智能实验室，负责 AIoT 总体架构设计，是蓝牙 mesh 从 0 到 1 落地天猫精灵开放平台的负责人，沉淀了一套 IoTConnect Kit 赋能产业链。","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/%E4%BB%8E%201%20%E4%BA%BA%E5%88%B050%20%E5%A4%9A%E4%BA%BA%EF%BC%8C%E9%98%BF%E9%87%8C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%B5%84%E6%B7%B1%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E7%AE%A1%E7%90%86%E5%BF%83%E8%B7%AF/"},{"title":"如何落地和管理一个“大前端”团队?饿了么大前端团队解密","text":"为什么要叫大前端团队？它的职责定位是什么？这种模式有何利弊？编者按：本文来自微信公众号“InfoQ”（ID：infoqchina），作者林建锋，现带领饿了么大前端团队在前端和 Node 领域为公司提供基础设施和业务支撑；36氪经授权发布。最近，“大前端”这个词被频繁提及，很多团队也在重新思考“大前端团队”和“移动团队+前端团队”这两种模式的优劣。InfoQ 特别邀请了饿了么大前端部门负责人林建锋，请他结合饿了么大前端团队的实践，向大家分享如何落地和管理一个大前端团队。 前言平时大家会叫我小鱼或 Sofish，尴尬的是只有屈指可数的同行知道我真名叫林建锋。曾经，为了逃离数学，大学我选了法学这个专业；而毕业前，又为了逃离职业性的“辩论”选择了不用说太多话的前端开发，至此踏上了程序员的不归路。这段程序员的不归路从实习开始，到远赴杭州支付宝，而后以第一个前端工程师的身份百姓网，再之后选择创业，最后加入饿了么并定居上海，目前为饿了么大前端部门负责人。 饿了么大前端团队的定位1.为什么叫“大前端”团队大前端这个词最早是因为在阿里内部有很多前端开发人员既写前端又写 Java 的 Velocity 模板而得，而我们部门成为之初所承担的内容不仅仅是前端，还包含 CDN 和 Nginx 层，所以取名“大前端”。时至今日，大家所说的大前端已经包含了前端、Node、Native-Like (Hybrid / Weex / RN)，甚至包括 Native App 开发。2.我所理解的“大前端”在我看来，“大前端”是一种变化形态多过于固定的职责范围，是“前端”职责范围的延伸，是对这个社会分工因为能力范围和因此所达到效率提升的一种进化形态。给大家分享个小道消息：CTO 曾多次开玩笑说 —— 你们负责的已经不仅仅是前端，要不就改名“大全栈”吧。这部门的名字很霸气但同时也太高调，所有并没有接受 BOSS 的提议，而是继续沿用“大前端”这个部门名。3.饿了么大前端团队的职责如上面所说的，除了纯 iOS / Android App 的开发，其他都是我们团队职责所在，同时我们还负责公司 HTTP API 层，有一些自己运维的系统。从分工来说来，目前我们有架构与机动组负责框架、规范、工具的生产；Node 研发团队负责公司 Node 业务的基础设施和业务支撑；多个业务前端团队支持不同的 BU 前端。这里值得一提的是，架构与机动组会对每个业务团队至少派出一名架构师长期、深入地了解业务团队所遇到的问题并反馈到架构团队，并在解决方案提出后协助推动。在具体职能分工之外，各团队也有以项目而组织起来的虚拟团队，比如由我们部门负责的“游戏中心系统”就由 Node 研发团队和架构与机场组中的成员组成；又如小程序团队；亦如发起一次由“93后”独立组织的招聘；专栏编辑团队、官微小分队、对内对外分享会小分队，等等。除了大家看到的开源产品，内部的所有项目都是“内部开源”，特别鼓励大家提 Pull Request 和相互 Code Review。这些与部门所创建的文化息息相关，且如你可能猜到的，大多合作都是一旦有人提出，即自发组队。 饿了么大前端团队如何看待和落地新技术我们是如何看待新技术的？在面试前端 Leader 候选人的时候，我通常会问一个问题：你如何看待技术债，有没有办法可以避免？几乎任何程序员都讨厌还技术债，所以才会有那句“挖坑一时爽，填坑火葬场”。因为痛苦才会非常值得我们去思考和解决。技术债从某种程序上代表着过时的技术，而新技术也将在未来某个时刻变成新的“技术债”。饿了么大前端是如何回答这个问题的？就是我们对新技术的看法。我 2014 年加入饿了么，那会 PC 和 Mobile 都还是后端渲染的模式，使用 Bootstrap 和 jQuery。我进去的第一件事是用 Angular.js 重写移动网站，并且前/后端分离，提倡后端即服务。在高速发展期利用移动网站支撑了当时 10 倍增长的业务；第二件事是重构 PC 站，把 web2 升级到 web3（Code Name），同样是前后端分离，到 14 年底 15 年初，基本实现完全分离。重构一方面是提高前端协作的效率，一方面是提升两部各自的掌握力 —— 只要 API 约定一致，内部封装可以自己随时变更（提升）。在此之后，我们的方向一直是比较激进的技术模式 —— 新业务可以用任何框架，大家自由选择；旧业务只要负责团队（人）有能力升级，那就鼓励用最新的。由于后端已经完全分离出去，所以从掌握力大大提升，加上这种受鼓励的激进技术模式，Angular.js 1.x 这种当年的新技术在日渐变成技术债的今天，也已经几乎全被重写成 Vue.js 和 React.js。当然，也像今天大家能看到的，当大家都还在转发关于 PWA 文章的时候，我们已经和 Google 合作并把 PWA 上线；开源的项目大多是内部成熟应用的项目，而开源的产品亦让我们成为 Vue.js World Ranking 最高的团队；Weex 方面，我们是除阿里内部团队外最早上线的大型用户。这些看起来快速和无止追求新技术的背后，其实并没有大家想的那么了不起，仅仅是因为团队文化本身就鼓励利用新技术解决问题。如果一定要拿 Vue.js 来举例，可能和你想象不一样的是，不用“落地”，仅仅是因为有人说了一句“WOW，Vue.js 写起来好简洁啊，大家要不要一起来试试？”。然后，一个团队，两个团队… 几乎所有团队都开始应用，几乎所有新项目都在用。一位 IBM 的朋友告诉我，他申请在项目试用 Vue.js，上级说在半年后试用，结果半年后又被推翻了。所以你看，在合适的文化土壤里新事物就是一种常态，如果做一个项目用什么技术还要上级主管确定“能不能做”，那本身就不是一件简单的事。我们对于技术选型通常来说要求是 —— 是否提升饿了么运行的效率或者团队开发的效率？是否能 hold 住？有没有人负责到底？符合这样的条件，就会被推动。当大家都在说 HTTPS 是好东西的时候，我们已经推动全网上线，诸如此类 —— Webp、Https、Vue.js / React.js / Angular.js、Weex、PWA 都是如此。比如大家可能去年就关注到我们在上线 HTTP/2，而今天饿了么大前端内部已经做过 HTTP/2 Server Push 的实验，可以想象在不久的将来，线上应用将会大面应用。这就是我们的选型和落地模式。 饿了么大前端团队的特色：散养特色？如果只用两个字来回答就是 —— 散养。但仅仅这样描述大家会一脸问号。外部对我们的评价是：“新技术跟进好快啊”、“怎么又又又出去玩了”、“下班很早”、“好多大牛啊”、“开源的东西获得好多星星啊”，诸如此类，但这不是我们要特地我呈现的，只是一种表像，或者说是一种副产品。一个团队的风格与创始人有很大的关系，比如喜欢愉懒的我会更多考虑自动化；又如有洁癖所以会有代码规划和 Code Review；还有大家看到的爱玩，所以会经常有团建、下午茶这样的文化；但另一方面，我并不想让团队仅仅是和我一样有大家喜欢的，同时充满缺点，而希望是不断尝试的，兼容并包的，让每个人的闪光点都成为集体中有特色标志的。所以我有自己的一套，就是前端所说的“散养”式管理，说起来可能会很大，重点说几点： 招聘最好的人。最好的人不是业界里的所有明星，更重要的是能从某方面给带队带来提升的人。这些人通常自驱能力强，只要有一个方向就能推动事件的发生和发展。加入的人会被要求不要以学习姿态加入这个团队，而是以加入会让这个团队会让其变得更好为姿态，成长就会成为副产品。 鼓励创造结果而不是追求上班时间。如果我们的目标是页面加载时间不要超过 800ms，那么目标就是 800ms 而不是上 12 个小时的班。 营造环境。我们有最好的人，我们追求结果而不是追求上班时间，我们鼓励主动和主人公意识，我们创新以打破规则 ，我们声明所有人为自己而生为用户工作而非老板，我们会包个酒包或找个海岛玩到天亮。有很多东西是要刻意去营造的，创新土壤，主动的意识，热爱生活的文化，鼓励什么就会聚集/培养一群什么样的人。 因为这样的管理方式，通常大部分事情都会被内部很好地解决，而我也得到更多的时间去思考如何做和决定做什么；团队也因为成员不断成长闪耀不同的光芒而变得更好。如果以官话来说，就是我们要发现一种“可持续发展”的模式。这种模式目前运行的不错，无论是业务上的，还是团队文化本身，抑或是加入成员的成长，都是让人高兴的。但，更好的方式仍在探索，如果说只分享一个点的话，那就是千万别用“管”的方式，而是“理”顺，就会顺理成章。至于是不是盲目追求新技术。上面我们已经谈过技术选型的要求，最最重要的也是最最根本的问题“是否进升饿了么运行的效率或者团队开发的效率？”，我相信如果大家能回答好这个问题，就解决了“盲目”追求的问题。最后说一句，无论是管理上、技术上、生活上，预留一定的空间和自由度，一定会带来惊喜。具体就不解释了，大家自行理解，或许某天我们遇到可以用这个话题开场，就开聊起来了。 大前端模式的利弊“大前端”模式的特点前面已有提及，即是对前端本身的一种能力范围延伸。移动开发团队，我这里指包含移动网页、Native-Like、Native App 这样的团队，如携程；纯大前端的团队如美团和饿了么北京研发中心，只要是客户端的无论是网页还是 App 都在单一个团队；饿了么不仅有大前端，还有各 BU 的 Native App 团队，甚至还有专注于移动基础框架的公共的移动技术团队。不同的分工模式，其利弊通常与公司状态、团队本身所创造的价格有很大的关联；虽然大家都是“离用户最近的工程师”，但没有公式可抄。就拿饿了么大前端来说，最开始是因为业务的快速发展，除了 C 端部门，其他新成立的部门前端工程师极度紧缺，为了资源的高效配置，才成立了大前端这个部门。这是当时公司业务的状态。创始人和 CTO 曾问我：“你觉得如果今天合了，几时会分？”当时，我的想法是，如果一个业务前端团队发展到 10 人左右，在负责好本身的业务外，能建立且不断升级自己的技术基础设施又具备有自己的文化，是一个分的时机。时至两年后的今日，我已不再是这样的想法，并且新成立的 BU 更愿意把人放到大前端。这是为什么呢？我们从以下几点分析： 如果一个大团队，并不能提便利的基础设施，不能创建自由且充满可能的文化，不能持续提升自己并帮助成员提升其自身水平。也就是大家经常谈到的技术追求、归属感、成就感。那么，打散到业务组可能更灵活。所以前端业务团队的分与合归根到底在于 —— 大团队是否创造比小团队更高的价值。 大多数人高估了“前端+后端+产品”坐在一起的效果，认为这样就能完美解决问题。很多时候，对于程序员来说更少的打扰，更多的思考（比如坐内部电梯去找某个人太慢了，就会开始思考是不是有必要去找某个人）过后的沟通，是更高效的沟通。 划分框架、机动与业务团队，一方面基础设施共享（框架工具）有更多重用，人员调度可以省不少资源（小团队需求少的团队可以合并支持）且又有专注于业务的团队，似乎是最前非常不错的划分方式，而在 10 个人的团队中是很难做到的。 由此，我们可以看出，一方面是业务影响，另一方面也依赖团队本身产生的价值，今天我们要分还是合，其利弊计算出现在决定做出之后，带领团队的人能否利用“合”的优势去产生出更大的价值。这个问题的答案就是利与弊的答案。 业界大前端团队的现状我们团队每年都会以个人或者团队名义邀请多位前端业界大牛来内部交流，也会组织内、外部交流会，这通常是几个电话和微信就搞定的事，总体交流还是比较多的。即使没有专门的会议，也会偶尔相互通通气。我没有具体统计过业界现状，但从我这边交流过的团队来说，现在很多团队都是大前端方向，或向这个方向发展的比较多。有少部分像携程、腾讯这种体量本身就很大职能划分也比较明确的公司，做的事可能是“大前端”但分开仍是比较偏向于 JS+HTML+CSS 这样的纯前端模式。这里也期望读者所在的团队，如有新的实践和想法我们可以偶尔探讨。 如何落地一个大前端团队？前文也有提到，要不要组建大前端团队，一方面是看业务是否有需求，另一方面是看合能否比分开带来更大的价值。除非人极少，通常来说业务大多数情况都会随公司的发展变得越分越开，而价值则主要是关于人和文化。目标不是为了合而合，或者追随业界模式，而应该着眼于是否优化了公司的人才架构从而优化业务。如果一定要从具体实施点上来说，这里说两点： 框架团队和业务团队应该同时设立，并且框架与业务不能相互脱离，具体可以参考饿了么大前端的模式 —— 相互渗透； 在大职能团队下，尽可能以业务划分团队，不要以职能划分团队；反之亦然。","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E5%92%8C%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E2%80%9C%E5%A4%A7%E5%89%8D%E7%AB%AF%E2%80%9D%E5%9B%A2%E9%98%9F?%E9%A5%BF%E4%BA%86%E4%B9%88%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%9B%A2%E9%98%9F%E8%A7%A3%E5%AF%86/"},{"title":"宋小菜-2020前端工程化","text":"","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/%E5%AE%8B%E5%B0%8F%E8%8F%9C-2020%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"title":"政采云-前端新人入职历程","text":"","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/%E6%94%BF%E9%87%87%E4%BA%91-%E5%89%8D%E7%AB%AF%E6%96%B0%E4%BA%BA%E5%85%A5%E8%81%8C%E5%8E%86%E7%A8%8B/"},{"title":"老码农的字节跳动前端面试总结","text":"有幸得到猎头推荐参加字节跳动工程效率部的前端面试，为此准备了一周的时间，面试前内心十分忐忑，略微有些小紧张。由于是下午面试，所以早早起床，翻出许多年前购买的，几近翻烂的《JavaScript设计模式》，从前到后粗略的翻看了下。之后起床刷牙、洗澡、整理下，躺在床上开始闭目养神~由于是下午两点面试，所以中午12点半从家里出门，担心天气太热，为防止面试时身上有汗水和味道，所以，我决定，打车去面试，这也是我唯一一次打车去面试，不心疼。结果低估了司机师傅的开车速度，竟然不到20分钟就给我送到了地方，没办法，在字节大楼外转了一圈，13:30入场，前台妹子随机抽了一份面试题给我，开始答题。两张面试题，给了十多张A4纸给我答题，嗯，有钱，答题笔柔软，有弹性、出水均匀流畅，高级货！先笔试利用html css 编写样式，div垂直body居中、div内的text垂直居中，div高度等于body宽度的一半（第一题就难住我了，充分暴露了我css功底极差的问题，跪，但终究还是写了点）第二题判断if([] == false) {} , if({} == false) {} , if([]) {} 不会，跪 （最后一面小哥给我讲下，人不错，good）利用宏任务，微任务的知识点判断程序输出（easy ok)bind函数实现(ok)trottle函数实现（ok， 可以用任务队列也可以只维护一个function， 我用的队列）给定一个不含重复数字的数组arr,指定个数n,目标和sum,判断是否含有由n个不同数字相加得到sum的情况（ok, leetcode 40 变种， 数字不得重复使用）以上大概用了三十分钟，之后开始一面一面来的是个小哥，年纪比较小，无形中给我一种挫败感，看题速度极快，之后继续出题：二叉树路径总和（leetcode 112)function request(urls, maxNumber, callback) 要求编写函数实现，根据urls数组内的url地址进行并发网络请求，最大并发数maxNumber,当所有请求完毕后调用callback函数(已知请求网络的方法可以使用fetch api)写代码不怕，最短时间给出程序，相互讨论下，至此一面结束，赞二面问：介绍下项目前端架构、项目难点答：简单介绍下，面试官很感兴趣，讲了大概有三十分钟问：react如何进行性能优化答：function component + redux、immutable、pure component , shouldComponentUpdate …问：https握手机制答：不太懂问：CDN原理答：cache、负载均衡、资源同步问：CDN获取最近节点资源的算法是什么答：不懂问：requestAnimationFrame 和setTimeout 、setInterval的关系答：都可以用作动画 requestAnimationFrame还可以埋点监测应用卡顿问：react fiber 了解多少答：Vritual DOM &amp; FiberNode 利用调度器分批次在不同的tick内渲染 (答的不好)问：你以前做过性能优化方面的开发，介绍下答：通过探针抓取performance数据，判断资源请求、白屏、首屏时间、页面卡顿，以及编写代码抓取页面错误、慢加载、代理用户事件进行行为分析等等。问：sum(100, 200)(300)(…)…(…)() curring化实现答：写代码，简单等等还有很多，知识点非常全面，充分暴露了我这个老码农只会搬砖，网络知识一窍不通、框架深度不够的弱点。二面结束已经5点，面试官说回头HR会有安排（100%没戏了）整体看，笔试题偏向基础，不难，只要工作中活学活用lodash，通过笔试没问题但非笔试部分比较难，考察面试者的表达能力，能否通过简单的描述让面试官了解你的工作，以及工作中遇到的问题等等。码农不仅要会写代码，在框架、网络、算法上也应该深入学习。总体收获颇丰，虽然面试第二天就收到了拒信，但并不意外，这点字节HR做的不错。面试失败肯定是能力不足，这点没有任何疑问。","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/%E8%80%81%E7%A0%81%E5%86%9C%E7%9A%84%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"title":"Less","text":"1、variable 1.1、通用1234567891011@link-color: #08aaef;@hover-color: darken(@link-color, 10%);a,a.link { color: @link-color;}a:hover { color: @hover-color;} 输出为： 1234567a,a.link { color: #08aaef;}a:hover { color: #0687be;} 1.2、插值上面的例子着重于使用变量来控制 CSS 规则中的值，但是它们也可以在其他地方使用，例如选择器名称、属性名称、url 和 @import 语句。 插值的使用形式为 @{variable-name} 拼接其他字符串或者单独使用。 1.2.1、选择器1234567@btn-prefix: ivu;.@{btn-prefix}-primary { border-radius: 5px; border: 1px solid #08aaef; color: #08aaef;} 输出为： 12345.ivu-primary { border-radius: 5px; border: 1px solid #08aaef; color: #08aaef;} 1.2.2、属性名123456@property-color: color;.widget { @{property-color}: #08aaef; background-@{property-color}: #e1e1e1;} 输出为： 1234.widget { color: #08aaef; background-color: #e1e1e1;} 1.2.3、URLs123456@images: '../../assets/images';.banner { background: url('@{images}/home/bg.png') no-repeat; background-size: 100% 100%;} 输出为： 1234.banner { background: url('../../assets/images/home/bg.png') no-repeat; background-size: 100% 100%;} 1.2.4、import1234@styles: '../../assets/styles';@import '@{styles}/variable.less';@import '@{styles}/mixin.less'; 1.3、变量中的变量在Less中，可以使用另一个变量定义一个变量的名称。 12345678910@primary: green;@secondary: blue;.section { @color: primary; .element { color: @@color; }} 输出为： 123.section .element { color: green;} 1.4、变量提升 Less 中的变量提升与 JavaScript 语言中的变量提升相同 Less 中的作用域原则与 JavaScript 语言中的作用域原则相同 2、&amp; 2.1、通用&amp; 运算符表示嵌套规则中对父选择器的引用。 1234567a { color: blue; &amp;:hover { color: lighten(blue, 10%); }} 输出为： 123456a { color: blue;}a:hover { color: #3333ff;} 2.2、插值12345678910111213.button { &amp;-ok { color: green; } &amp;-warning { color: yellow; } &amp;-error { color: red; }} 输出为： 123456789.button-ok { color: green;}.button-warning { color: yellow;}.button-error { color: red;} 2.3、复合1234567891011121314151617.button { &amp; &amp; { color: yellow; } &amp;&gt;&amp; { color: black; } &amp;+&amp; { color: white; } &amp;&amp; { color: red; }} 输出为： 123456789101112.button .button { color: yellow;}.button &gt; .button { color: black;}.button + .button { color: white;}.button.button { color: red;} 2.4、改变顺序12345div { a &amp; { color: red; }} 输出为： 123a div { color: red;} 2.5、组合12345p, div, a { &amp; + &amp; { color: red; }} 输出为： 1234567891011p + p,p + div,p + a,div + p,div + div,div + a,a + p,a + div,a + a { color: red;} 2.6、注意&amp; 表示所有嵌套选择器，而不是最近的父级。如下： 123456789div { p { a { &amp;:hover { color: white; } } }} 输出为： 123div p a:hover { color: white;} 而不是： 123a:hover { color: white;} 3、extendextend 是 less 中的一个伪类语法，负责将一个或一些选择器中的声明继承到指定选择器中。 3.1、语法12.b { color:red; }.a:extend(.b) { background: white; } 意为 a 选择器将继承 b 选择器的规则集，输出为： 12.b, .a { color:red; }.a { background: white; } 该语法的形式有如下几种： 跟在选择器之后：.a:extend(.b) 带空格： .a :extend(.b) 多个串联： .a:extend(.f):extend(.g) 只能跟在最后：因此 pre:hover:extend(div pre):nth-child(odd) 是不允许的 pre:hover:extend(.a):extend(.b) 等同于 pre:hover:extend(.a,.b) 选择器嵌套情形遵从上面原则 3.2、多重继承12345.a:extend(.f){}.a:extend(.g){}// 等同于.a:extend(.f,.g){} 统一输出为： 123.f,.a {}.g,.a {}.a {} 3.3、精准匹配默认情况下，less 在为 extend 查找继承选择器时，遵从精准匹配策略。即选择器形式必须完全统一才能匹配，如下列举的情况： .text:extend(.class) 与 .a.class 、.class.a 、.class &gt; .a 、.a &gt; .class、 *.class 不匹配 .text:extend(a:hover:visited) 与a:visited:hover 不匹配 .text:extend(:nth-child( 1n + 3 )) 与 :nth-child(n+3) 不匹配 但属性选择器的单双引号情况例外： .text:extend([title=identifier]) 与 [title='identifier'] 和 [title=&quot;identifier&quot;] 匹配 3.4、all1234567891011.a.b.test,.test.c { color: orange;}.test { &amp;:hover { color: green; }}.replacement:extend(.test all) {} 输出为： 12345678910.a.b.test,.test.c,.a.b.replacement,.replacement.c { color: orange;}.test:hover,.replacement:hover { color: green;} 3.5、选择器插值略 3.6、media 作用域作用域规则可类比 JavaScript 语言中的变量作用域，以 media 花括号为作用域范畴。 3.7、经典场景 3.7.1、减少基类123456789101112// CSS.animal { color: white; background-color: red;}.bear { color: black;}// HTML&lt;a classs=&quot;animal bear&quot;&gt;&lt;/a&gt; 可改为： 12345678910111213// CSS.animal { color: white; background-color: red;}.bear { &amp;:extend(.animal); color: black;}// HTML&lt;a classs=&quot;bear&quot;&gt;&lt;/a&gt; 3.7.2、减少重复1234567891011121314151617181920.my-inline-block() { display: inline-block; font-size: 0;}.thing1 { .my-inline-block;}.thing2 { .my-inline-block;}// 输出为.thing1 { display: inline-block; font-size: 0;}.thing2 { display: inline-block; font-size: 0;} 可改为： 123456789101112131415161718.my-inline-block { display: inline-block; font-size: 0;}.thing1 { &amp;:extend(.my-inline-block);}.thing2 { &amp;:extend(.my-inline-block);}// 输出为.my-inline-block,.thing1,.thing2 { display: inline-block; font-size: 0;} 4、merge合并：将多个属性的值合并到单个属性下的逗号或空格分隔的列表中，合并对于诸如背景和变换之类的属性很有用。 123456789101112131415161718192021222324252627282930// 不合并.mixin() { box-shadow: inset 0 1px 10px #e55;}.class { .mixin(); box-shadow: 0 0 20px black;}// 输出为.class { box-shadow: inset 0 1px 10px #e55; box-shadow: 0 0 20px black;}// 合并.mixin() { box-shadow+: inset 0 1px 10px #e55;}.class { .mixin(); box-shadow+: 0 0 20px black;}// 输出为.class { box-shadow: inset 0 1px 10px #e55, 0 0 20px black;} 语法： 逗号分隔： + 空格分隔： +- 5、mixins 5.1、语法1234567891011.class-name, #id-name { color: red;}.mixin-class { .class-name();}.mixin-id { #id-name();} 输出为： 12345678910.class-name,#id-name { color: red;}.mixin-class { color: red;}.mixin-id { color: red;} 5.2、不输出123456789101112.mixin-a { color: red;}.mixin-b() { color: green();}.class-a { .mixin-a(); .mixin-b();} 输出为： 1234567.mixin-a { color: red;}.class-a { color: red; color: green;} 5.3、Selectors in MixinsMixins 不仅可以包含属性，还可以包含其他的选择器。 1234567891011.mixin-hover() { color: red; &amp;:hover { background-color: white; }}button { .mixin-hover();} 输出为： 123456button { color: red;}button:hover { background-color: white;} 5.4、Namespace 减少与其他库混合使用时的冲突 一种组织 mixins 的方法 123456789101112#outer() { .inner-a { color: red; } .inner-b { color: green; }}.c { #outer &gt; .inner-a();} 5.5、守卫1234567#namespace when (@mode = huge) { .mixin() { /* */ }}#namespace { .mixin() when (@mode = huge) { /* */ }} 5.6、important123456789101112.foo(@bg: #e55, @color: #4e5) { background-color: @bg; color: @color;}.unimportant { .foo();}.important { .foo() !important;} 输出为： 12345678.unimportant { background-color: #e55; color: #4e5;}.important { background-color: #e55 !important; color: #4e5 !important;} 5.7、传参数略，待补充。 6、import @import 语句可以在文档的任何位置（区别于 css 中的只能在头部） 根据文件扩展名的不同， import 语句的处理方式可能会有所不同 @import “foo”; // foo.less is imported @import “foo.less”; // foo.less is imported @import “foo.php”; // foo.php imported as a Less file @import “foo.css”; // statement left in place, as-is 6.1、选项Syntax: @import (keyword) &quot;filename&quot;; reference: use a Less file but do not output it inline: include the source file in the output but do not process it less: treat the file as a Less file, no matter what the file extension css: treat the file as a CSS file, no matter what the file extension once: only include the file once (this is default behavior) multiple: include the file multiple times optional: continue compiling when file is not found 7、Maps略，待补充。","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/CSS/%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E8%A8%80/less/"},{"title":"Class","text":"一、概述 1. ES5ES5 中用构造函数来实现类和实例： 12345678function Person() {this.type = 'person'}Person.prototype.sayType = function () {return this.type}const personA = new Person()personA.sayType() ### 2. ES6 基本上，ES6 的 class 可以看做只是 ES5构造函数的语法糖，上面代码用 ES6 来实现如下： 1234567891011121314151617class Person { constructor() { this.type = 'person' } sayType() { return this.type } }const personA = new Person()personA.sayType() // persontypeof Person // functionPerson.prototype.constructor === Person // true ** 二、特性 1. 属性位置与 ES5 一样，实例的属性除非显示定义在其自身（即定义在 this 对象上），否则都是定义在原型上。** 12345678910111213141516171819class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')' }}const point = new Point(2,3)point.x // 2point.y // 3point.hasOwnProperty(x) // truepoint.hasOwnProperty(y) // truepoint.hasOwnProperty(toString) // false ### 2. 共享原型对象 123456class Point {}const point1 = new Point(2,3)const point2 = new Point(4,5)point1.__proto__ === point2.__proto__ ### 3. 属性表达式 类的属性名，可以采用表达式 12345let getName = 'getName'class Point { [getName](){}} ### 4. 不存在变量提升 12new Point() // Uncaught ReferenceError: Point is not definedclass Point {} ### 5. Generator 方法 如果在某个方法前加上星号（ * ），就表示该方法是一个 Generator函数。 123456789101112131415161718class Foo { constructor(...args) { this.args = args } *[Symbol.iterator]() { for (const iterator of this.args) { yield iterator } }}let foo = new Foo('hello', 'world')console.log(foo)for (const iterator of foo) { console.log(iterator)} ### 6. this 指向 类的方法内部的 this 默认指向该类的实例，但不小心也可能丢失（如 React 中 render 的事件绑定），至于具体为啥，可参考 this 指向一节（TODO）。显示绑定上下文对象，有以下几种形式： 12345678910111213141516171819class Person { constructor() { this.name = name this.sex = sex this.age = age this.getName = () =&gt; this.getName() // 形式 1 this.getAge = this.getAge.bind(this) // 形式 2 } getName() { } getAge() { } // 形式 3 getSex = () =&gt; { }} ## 三、静态属性 区别于实例属性，可以直接通过类调用的方法称为静态属性。 1. this 指向12345678910111213class Person { static getSelfName() { return this.name // Person } constructor({ name, sex, age }) { this.name = name this.sex = sex this.age = age }}Person.getSelfName() // Person ‌ 2. 继承 子类可以继承父类的静态属性123456789class Person { static getSelfName() { return this.name }}class Student extends Person {}Student.getSelfName() 通过 super 调用12345678910111213class Person { static getSelfName() { return this.name }}class Student extends Person { static getParentName() { return super.getSelfName() }}Student.getParentName() // Student ## 四、私有属性 在属性名称之前加 # 符号，可以声明此属性为私有的，即外部不可访问的。 12345678910111213141516class Person { #count = 1 getCount() { return this.#count } #getCount() { return this.#count }}let person = new Person()person.getCount() // 1person.#getCount() // Uncaught SyntaxError: Private field '#count' must be declared in an enclosing classperson.#count // Uncaught SyntaxError: Private field '#count' must be declared in an enclosing class ‌ 五、静态私有属性私有属性和私有方法前面，也可以加上static关键字，表示这是一个静态的私有属性或私有方法。 1234567891011121314151617181920class FakeMath { static PI = 22 / 7; static #totallyRandomNumber = 4; static #computeRandomNumber() { return FakeMath.#totallyRandomNumber; } static random() { console.log('I heard you like random numbers…') return FakeMath.#computeRandomNumber(); }}FakeMath.PI // 3.142857142857143FakeMath.random()// I heard you like random numbers…// 4FakeMath.#totallyRandomNumber // 报错FakeMath.#computeRandomNumber() // 报错 六、其他 ### 1. new.target new 是从构造函数生成实例对象的命令。ES6 为 new 命令引入了一个 new.target 属性，该属性只能用在类中的构造函数中，返回 new 命令作用于的那个构造函数。如果不是通过 new 命令或者 Reflec.construct() 调用， new.target 会返undefined 。 1234567891011121314151617// 形式 1class Person { constructor() { if (new.target === undefined) { throw new Error('必须使用 new 生成实例') } }}// 形式 2class Person { constructor() { if (new.target !== Person) { throw new Error('必须使用 new 生成实例') } }} 七、继承","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/JavaScript/ES6/Class/"},{"title":"解构赋值","text":"本质上，解构赋值这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 一、数组的解构赋值12345678910// 常规let [a, b] = [0, 1] // a: 0, b: 1// 不完全解构let [a, , c] = [0, 1, 2] // a: 0, c: 1// 嵌套let [x, [y], z] = [0, [1], 2] // x: 0, y: 1, z: 2 二、对象的解构赋值123456789101112131415161718// 常规let { foo } = { foo: 'foo' } // foo: 'foo'// 未匹配let { foo } = {} // undefined// 重命名let { foo: baz } = { foo: 'foo' } // baz: 'foo'// 默认值let { foo = 'foo' } = {} // foo: 'foo'// 批量let { foo, bar: baz } = { foo: 'foo', bar: 'bar' }// 多级嵌套let { foo: { bar } } = { foo: { bar: 'bar' } } // bar: 'bar'（此处foo 只是模式，不是变量） 三、可迭代类型 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 1234567891011121314// 从函数返回多个值function example() { return [1, 2, 3]}let [a, b, c] = example() // a: 1, b: 2, c: 3function example2() { return { x: 'x', y: 'y', z: 'z' }}let { x, y, z } = example2() // x: 'x', y: 'y', z: 'z'// 字符串let [a, b, c] = 'abc' // // a: 'a', b: 'b', c: 'c' 四、其他1234567// 对象嵌套let { foo: { bar } } = { foo: { bar: 'bar' } } // bar: 'bar'（此处foo 只是模式，不是变量）let { foo, foo: { bar } } = { foo: { bar: 'bar' } } // foo: {bar: 'bar'}, bar: 'bar'// 对象的解构赋值可以取到继承的属性let { sort } = [1, 2, 3]let { length } = 'abc' 五、异常场景1234567891011121314// 模式匹配抛错// ncaught TypeError: undefined is not a functionlet [a, [b], c] = [1, 2, 3]// Uncaught TypeError: Cannot read property 'bar' of undefinedlet { foo: { bar } } = {}// undefined 和默认值// ES6 内部使用严格相等运算符（===），判断一个位置是否有值// 所以，只有当一个数组成员严格等于undefined，默认值才会生效let [x = 1] = [] // x = 1let [x = 1] = [undefined] // x = 1let [x = 1] = [null] // x = null 六、应用场景123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1.交换变量let a = 'a'let b = 'b'let [b, a] = [a, b] // a: 'b', b: 'a'// 2.函数入参function foo([x, y, z]) { }function foo([x = 'x', y, z]) { }function foo([x = 'x', y, z] = []) { }function foo({ foo, bar: baz, zab = 'zab' }) { }function foo({ foo, bar: baz, zab = 'zab' } = {}) { }// 3.网络请求结果 json 数据let resp = { code: 10000, data: { foo: 'foo', bar: 'bar' }, msg: 'success' }$.ajax().then(({ code, data = {} }) =&gt; { console.log(data)})// 4.内置对象方法取值const { sin, cos, random } = Mathconst { log, error, group } = console// 5.输入模块方法取值import React from 'react'const { Component, useState, useEffect } = Reactlet { readFile, resolve } = require('path')// 6.取数组的首末元素let arr = [1, 2, 3, 4, 5]let { 0: first, [arr.length - 1]: last } = arr// 7.遍历 Map 结构// for (let item of map) {// console.log(`${item[0]} is ${item[1]}`)// }let map = new Map()map.set('first', 'hello')map.set('second', 'world')for (let [key, value] of map) { console.log(`${key} is ${value}`)}","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/JavaScript/ES6/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"title":"对象属性描述符","text":"","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/JavaScript/Feature/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/"},{"title":"真假值和相等性判断","text":"1、真假值以下六个均为 not truthy 的值： false 0 “” null undefined NaN 除以上六个外，其余情况均为 truthy 的值，如： if ({}) if ([]) 2、相等性JavaScript 中的相等性判断","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/JavaScript/Feature/%E7%9C%9F%E5%81%87%E5%80%BC%E5%92%8C%E7%9B%B8%E7%AD%89%E6%80%A7%E5%88%A4%E6%96%AD/"},{"title":"State","text":"关于 setState() 你应该了解三件事： 不要直接修改 State State 的更新可能是异步的 State 的更新会被合并 向下流动任何的 state 总是属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中低于他们的组件。","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/React/%E5%85%B3%E6%B3%A8%E7%82%B9/State/"},{"title":"插槽","text":"Vue 中有对插槽及作用域插槽的设计，但遗憾的是 React 中并没有。虽然 React 中并没有针对组件插槽的开发范式设计，但因此可能显得更为灵活和自由。 React 中使用插槽的几种形式如下： 1、props.children123456789101112131415161718// Slot.jsexport default function SlotDemo (props) { return ( &lt;div className=&quot;slot-demo-wrap&quot;&gt; {props.children} &lt;/div&gt; )}// App.jsReactDom.render( &lt;Slot&gt; &lt;p&gt;内部 slot1&lt;/p&gt; &lt;p&gt;内部 slot2&lt;/p&gt; &lt;/Slot&gt;, document.getElementById('root'),) 2、props12345678910111213141516171819202122// Slot.jsexport default function SlotDemo (props) { return ( &lt;div className=&quot;slot-demo-wrap&quot;&gt; &lt;div className=&quot;left-slot&quot;&gt; {props.leftSlot} &lt;/div&gt; &lt;div className=&quot;right-slot&quot;&gt; {props.rightSlot} &lt;/div&gt; &lt;/div&gt; )}// App.jsconst leftSlot = &lt;p&gt;左侧 slot&lt;/p&gt;const rightSlot = &lt;p&gt;右侧 slot&lt;/p&gt;ReactDom.render( &lt;Slot leftSlot={leftSlot} rightSlot={rightSlot}/&gt;, document.getElementById('root'),) 3、关于组合和继承在 Facebook，我们在成百上千个组件中使用 React。我们并没有发现需要使用继承来构建组件层次的情况。Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/React/%E8%AF%AD%E6%B3%95/%E6%8F%92%E6%A7%BD/"},{"title":"条件渲染","text":"条件渲染的几种形式 1、变量值判断1234567891011121314151617181920// 形式 1renderGreeting () { const { isLogin } = this.state if (isLogin) return &lt;div&gt;欢迎登录&lt;/div&gt; else return &lt;div&gt;请注册&lt;/div&gt;}// 形式 2renderGreeting () { const { isLogin } = this.state let greeting if (isLogin) greeting = &lt;div&gt;欢迎登录&lt;/div&gt; else greeting = &lt;div&gt;请注册&lt;/div&gt;} 2、与运算1234567891011renderUnReadMessage () { const { unreadMessages } = this.state return ( &lt;div className=&quot;unread-message&quot;&gt; {unreadMessages.length &gt; 0 &amp;&amp; ( &lt;p&gt;You have {unreadMessages.length} unread messages.&lt;/p&gt; )} &lt;/div&gt; )} 3、三目运算符1234567891011render() { const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; {isLoggedIn ? &lt;LogoutButton onClick={this.handleLogoutClick} /&gt; : &lt;LoginButton onClick={this.handleLoginClick} /&gt; } &lt;/div&gt; );} 返回 JSX 为 null 的情况，组件不会渲染，但生命周期依然执行","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/React/%E8%AF%AD%E6%B3%95/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"},{"title":"webpack 配置","text":"因为 @vue/cli-service 对 webpack 配置进行了抽象，如果想修改或者添加部分 webpack 的配置，可通过以下几种方式： @vue/cli-service 暴露出的可配置内容 package.json 中的 vue 字段； vue.config.js 文件； @vue/cli-service 未暴露出的其他 webpack 配置内容 vue.config.js 中的 configureWebpack 字段； vue.config.js 中的 chainWebpack 字段； 一、系统可配具体可对照查看官方文档：https://cli.vuejs.org 二、configureWebpack该属性值将会被 webpack-merge 合并入最终的 webpack 配置。 2.1 对象方式12345678910111213// vue.config.jsmodule.exports = { // other config item... configureWebpack: { resolve: { alias: { '@views': path.resolve(__dirname, './src/views'), '@images': path.resolve(__dirname, './src/images'), '@components': path.resolve(__dirname, './src/components') } } },} 2.2 函数方式1234567891011121314151617181920// vue.config.jsmodule.exports = { // other config item... configureWebpack: config =&gt; { if (process.env.NODE_ENV === 'production') { // 为生产环境修改配置 } else if (process.env.NODE_ENV === 'test') { // 为测试环境修改配置 } else { // 为开发环境修改配置 } // 注意：对象直接赋值有可能覆写原有的配置 config.resolve.alias['@views'] = path.resolve(__dirname, './src/views') config.resolve.alias['@images'] = path.resolve(__dirname, './src/images') config.resolve.alias['@components'] = path.resolve(__dirname, './src/components') }, } 三、chainWebpackVue CLI 内部的 webpack 配置是通过 webpack-chain 维护的， vue.config.js 中也开放了针对此库的形式的配置。 总结：有些 webpack 选项是基于 vue.config.js 中的值设置的，所以不能修改。保险起见，将所有的 webpack配置项分为两类： vue cli 配置文件开放出来的配置项，也就是 vue.config.js 中支持的配置项，均在 vue.config.js 中配置； 非vue cli 开放出来的配置项均可以通过 configureWebpack 或者 chainWebpack 配置","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/Vue/CLI/webpack%20%E9%85%8D%E7%BD%AE/"},{"title":"环境变量和模式","text":"一、模式 1.1 内嵌模式npm script 命令涉及的模式有 3 种 production：vue-cli-service build 和 vue-cli-service test:e2e test：vue-cli-service test:unit development：vue-cli-service serve 1.2 自定义模式可以通过传递 --mode 选项参数可以为命令行覆写默认的模式，eg： vue-cli-service build --mode staging 二、环境文件 .env 是不区分模式的环境变量配置文件，所有模式均会被加载； .env.[mode] 是特定某种模式下的环境变量配置文件，只在特定模式下加载； 每种模式都可以创建一份 local 模式文件，被 git 忽略，同模式下优先级更高； 优先级规则 .env.[mode].local &gt; .env.[mode] （同理：.env.local &gt; .env） .env.[mode] &gt; .env 环境变量配置文件读取顺序： .env &gt; .env.local &gt; .env.[mode] &gt; .env.[mode].local 后读取优先级则更高（相当于覆盖同名变量） 三、环境变量 3.1 自定义变量12345// 1. VUE_APP_开头VUE_APP_APPID=wx971b57edf7ea3fd2// 任意格式FOO=bar 只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中，可以这样访问： JavaScript 中：process.env.VUE_APP_XXX ； HTML 中： &lt;%= process.env.VUE_APP_XXX =&gt; 3.2 特殊变量除了 VUE_APP_* 变量之外，在你的应用代码中始终可用的还有两个特殊的变量： NODE_ENV - 可能是 production 、 test 、 development 或者自定义的模式名称 BASE_URL - 始终和 vue.config.js 中的 publicPath 选项相符，即你的应用汇部署到的基础路径 四、NODE_ENV NODE_ENV 挂载于 process.env 对象下，本身是不存在的，只有命令行显示指定才可用，新版 Vue Cli 中做了封装，对应模式都可以直接获取，也可以自定义 命令行指定后可直接在配置文件(webpack.config.js)中使用 如果需要在业务代码中使用，需要显示嵌入 webpack4 之前使用 DefinePlugin webpack4 之后使用 mode 详细介绍可以查看：NODE_ENV到底是个什么玩意？？","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/Vue/CLI/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"title":"ESLint","text":"配置ESLint 暴露出来的所有的可配置项如下： extends 、 plugins 、 parserOptions 、 env 、 globals 、 rules 。 extends继承 plugins插件 processor插件可以提供处理器 处理器可以从其他类型的文件中提取JavaScript代码，然后让ESLint对该JavaScript代码进行处理 或者处理器可以出于某种目的在预处理中转换JavaScript代码。 123456789101112131415{ &quot;plugins&quot;: [&quot;a-plugin&quot;], &quot;overrides&quot;: [ { &quot;files&quot;: [&quot;*.md&quot;], &quot;processor&quot;: &quot;a-plugin/markdown&quot; }, { &quot;files&quot;: [&quot;**/*.md/*.js&quot;], &quot;rules&quot;: { &quot;strict&quot;: &quot;off&quot; } } ]} parserparser ：ESLint 默认指定 Espree 作为解析器，可以通过该选项指定其他的解析器。 123{ &quot;parser&quot;: &quot;esprima&quot;} parserOptionsparserOptions ：默认情况下，ESLint 以 ECMAScript 5语法作为校验标准，可以使用该选项覆盖设置以启用对其他 ECMAScript 语言版本以及对 JSX 等的支持。 1234567891011121314151617181920{ &quot;parserOptions&quot;: { // ECMAScript 版本号 // 3、5、6、7、8、9、10、11 // 2015、2016、2017、2018、2019、2020 &quot;ecmaVersion&quot;: 11, // 脚本类型 // script：一般脚本类型 // module：ECMAScript 模块类型 &quot;sourceType&quot;: &quot;module&quot;, // 额外的语法特性 &quot;ecmaFeatures&quot;: { &quot;globalReturn&quot;: true, // 是否支持全局的 return 语句 &quot;impliedStrict&quot;: true, // 启用全局严格模式（如果ecmaVersion为5或更大） &quot;jsx&quot;: true // 是否支持 jsx 语法 } }} 支持 JSX 语法不等同于支持 React 支持 ES6 语法不等同于支持新的 ES6 全局变量。 对于支持 ES6 语法，设置项为： { &quot;parserOptions&quot;: {&quot;emcaVersion&quot;: 6}} 对于支持 ES6 新的全局对象，设置项为：{ &quot;env&quot;: {&quot;es6&quot;: true}} {&quot;env&quot;: {&quot;es6&quot;: true}} 默认开启 ES6 语法；{ &quot;parserOptions&quot;: {&quot;emcaVersion&quot;: 6} } 不能支持 ES6 新的全局对象； envenv ：指定脚本运行的环境（语言版本、宿主环境等都包含在内），每个环境都附带了一组特定的预定义全局变量。 123456{ &quot;env&quot;: { &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;], &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;] }} globalglobal ：可以指定额外的全局变量，比如全局引入了 jQuery。 123456{ &quot;globals&quot;: { &quot;$&quot;: true, &quot;_&quot;: true }} rulesrules ：该配置项指定启用哪些规则以及该规则处于什么错误级别，不指定默认全部关闭。 123456{ &quot;rules&quot;: { &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;], &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;] }} ESLint 规则分为两类： 代码格式规则：比如 max-len, no-mixed-spaces-and-tabs, keyword-spacing, comma-style… 代码质量规则：比如 no-unused-vars, no-extra-bind, no-implicit-globals, prefer-promise-reject-errors… 每条配置项的值可以为： 字符串形式（校验等级） 字符串数组（ [校验等级、校验形式] ） 校验等级分为以下三级： &quot;off&quot; / 0 ：规则关闭； &quot;warn&quot; / 1 ：规则开启，但只抛错不会影响校验进程（exit code = 0）； &quot;error&quot; / 2 ：规则开启，抛错并退出程序（exit code = 1）；","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/ESLint/"},{"title":"概述","text":"说明开发人员不同的编码习惯、不同的编辑器、不同的格式化规则，导致了项目协作时的代码风格不统一问题。因此即使业务逻辑没有任何改动的情况下，也可能会因为代码风格的不统一进行了格式化代码之后，造成文件的冲突，而且这种冲突一般很难解决。 关于代码风格的几个核心认知前提列举如下： 代码风格没有绝对的好坏，过多的争论没有意义 为了解决因代码风格不同而造成的冲突问题，因此代码风格很有必要统一 工具语言不同、场景不一样，所使用的工具和工具所对应的配置项也不一样。 Web 开发中，语言大体可分为： HTML（pug、jade、ejs 等模板语法） CSS（LESS、SASS 等预处理语言） JavaScript（不同的 ECMAScript 版本） 常用的组件化开发框架有： React（JSX 语法） Vue（template、script、style） 针对上述所提及到的不同编程语言和开发框架，分别对应的格式化工具为： HTML：htmllint（放弃吧，目标很美好、过程比较痛苦） CSS：Stylelint JavaScript：ESLint 接下来的几章，将分别介绍ESLint、Stylelint 和 Prettier这三个和代码风格统一相关的工具。","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/%E6%A6%82%E8%BF%B0/"},{"title":"Git 分支管理规范","text":"1.流程 Action 说明： 从master分支拉取对应的feature和dev分支，分支名：feature_需求编号，版本号：master版本号_时间戳_SNAPSHOT 当master代码发生变更后，需merge到仍在开发测试中的feature分支 从master分支拉取对应的hotfix分支，分支名：hotfix_BUG_11【hotfix_XG_99】，版本号：master版本号中z+1【如：master分支版本号为1.1.5，则hotfix分支版本号为1.1.6】 feature分支部分功能或全部功能已开发联调完成提测 feature分支在测试过程中修复BUG的过程 当dev或hotfix分支对应的需求测试完成后准备进入预发布阶段时，从此dev_XG_26或hotfix拉取对应的release_XG_26分支并修改版本号，发布到UAT环境进行回归测试 release分支在UAT回归测试过程中发现BUG进行修复，或者有已评估通过的紧急需求需要进行开发的过程 UAT回归验证通过后发布生产 提交merge request并找对应的模块负责人Code Review 已上线的分支合并到master分支并打Tag 待优化的点： 当Jira 需求状态变更为_开始开发_时，就自动执行1⃣️操作。 当Jira 上需要紧急发布的需求或紧急修复的BUG状态变更为_开始开发_时，就执行3⃣️操作。 当feature分支对应的需求在Jira上状态变更为_提测_时，就执行9⃣️操作。2.分支说明master 分支【线上分支】 master 分支时常保持着软件可以正常运行的状态。由于要维护这一状态，所以不允许开发者直接对master 分支的代码进行修改和提交。其他分支的开发工作进展到可以发布的程度后，将会与master分支进行合并，并且这一合并只在发布成品时进行。发布时将会附加版本编号的Git标签。 feature分支【功能分支】 feature 分支以master分支为起点，是开发者直接进行功能开发的分支。开发流程： 从master分支创建feature分支，分支名：feature_需求编号，版本号：master版本号_时间戳_SNAPSHOT 从feature分支中实现目标功能 通过GitLab 向dev分支发起merge request 接受其他开发者审核后，将merge request合并至dev分支 与dev分支合并后，开发人员发送提测邮件 测试人员将此dev分支发布至测试环境，开始测试 注意：每天早上将最新的master代码合并到feature分支时，记得一定要先git checkout master、git pull origin master，保证master分支处于最新状态。 dev分支【提测分支】 dev分支是提测分支，dev与对应的feature分支需同时从master中拉取出来，待feature分支功能开发完成后，将feature分支代码合并到dev分支，开始提测。与master 分支一样，这个分支也不允许开发者直接进行修改和提交。在多个版本需求并行测试的过程中，此分支会存在多个。 release分支【发布分支】 创建 release分支 ，在这个分支，我们只处理与发布前准备相关的提交，比如变更版本号。如果已经部署到UAT后测试出bug，相关修正也要提交到这个分支。注意：该分支绝对不能包含功能变更等重大修正。这一阶段的提交数应该限制到最低。 hotfix分支【紧急修复分支】 hotfix是从master或release分支上拉取出来的分支，主要用于线上紧急需求开发或紧急问题修复或预发环境的BUG修复。hotfix开发完成后，需要向release提交merge request。下述情况需要创建 hotfix 分支： 线上发生漏洞需要及早修复 紧急需求无法等到下一个版本一起发布 预发环境发现的BUG修复 3. 标签和发布 release分支每次发布完成后将代码合并到master分支，再从master分支上创建当前版本的tag，填写此版本相关发布内容。 4. 版本号分配规则 版本号的分配规则 x.y.z x: 在重大功能变更，或者版本不向下兼容+1，此时y、z归零 y: 在添加新功能或者删除已有功能+1 此时z归零 z: 紧急发布为奇数，日常周迭代为偶数","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E8%A7%84%E8%8C%83/Git%20%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/"},{"title":"中后台交互规范","text":"** ** ** 搜索 1、搜索项超过两行的添加折叠展开便捷选项（建议） 可参考 Antd 2、搜索项以 form-item 默认自适应排布，时间、省市区等不规则项尽量向后排布 原型稿不规范的，以此规则为准 列表 | 1、数据项根据创建时间降序排序 | 后端场景，特殊场景以产品PRD为准 || | 2、分页sizes：[20, 50, 100]，默认20 | || | 3、初始化不搜索的列表缺省页统一，Notification通知提醒 | 文案“请输入搜索条件后查询”； || | 4、分页器始终悬浮在顶部右上方，自适应，依次判断操作栏或标签栏是否有足够位置； | || | 5、列表字段的时间格式：YYYY-MM-DD hh:mm:ss； | || | 6、搜索约束： 关键词不区分大小写、 搜索关键词默认首尾去空格 编号搜索是精准搜索 文本搜索是模糊搜索| 空格问题：筛选条件必须处理、表单创建提交时对出错频次较高项做处理 || | 7、非删除操作按钮均已 primary 类型为准； | || | 8、列表型页面，筛选栏只放置重置、搜索操作，其余按钮均放置在表格头部； | || | 9、列表操作栏归并为一列，按钮类型 text ，fixed右侧； | || | 10、列表加载需添加loading状态 | || | 11、空值字段以中划线 “-” 占位 | || 操作类 | 1、特定操作提交前需经过确认 任何删除操作，文案“您确定要删除吗？”； 列表栏高风险类操作 表头操作：绑定/解绑、停用/启用、审核/驳回、解冻/冻结、关闭/开启、重置、复制、上架/下架、失效/生效/作废/恢复（尤其批量操作）| 绑定/解绑、停用/启用、审核/驳回、解冻/冻结、关闭/开启、重置、复制、上架/下架、失效/生效/作废/恢复（高风险类，需要弹窗确认） 查看详情、编辑等（非风险类）|| | 2、配色： 高危操作红色 警告提示黄色 正常操作蓝色| 操作类型同上 || | 3、涉及页面跳转的按钮，以 router-link 组件承载 | 目的是为满足既可以本页面打开，又可通过Ctrol（Command） + 点击 新标签打开 || 文案类 | 1、通用操作名称统一 | 添加、删除、编辑、查看、通知、执行、导出、导入、审核、上架、下架、备注、置顶（其他待补充） || | 2、平台会员账户 手机号 会员号| 无会员账户、会员Code~~一说 || 表单 | 1、右对齐，添加中文冒号做对齐标识； | |","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E8%A7%84%E8%8C%83/%E4%B8%AD%E5%90%8E%E5%8F%B0%E4%BA%A4%E4%BA%92%E8%A7%84%E8%8C%83/"},{"title":"代码命名规范","text":"为什么要强调代码命名规范？ 增强代码的可读性 增强代码的可维护性 正由于上述两个作用，从而使得开发效率 &amp; 维护效率得到大幅度的提高。 命名规则： camelCase(驼峰式)：videoExampleComponent PascalCase(大驼峰式)：VideoExampleComponent kebab-case(烤串式)：video-example-component Vue驼峰式： JavaScript 变量 JavaScript 函数 PascalCase： JavaScript 类 组件文件（VideoList.vue，操作系统不同、大小写敏感程度不同） kebab-case： HTML（大小写不敏感） React 组件，或者类名，首字母全部大写，遵守驼峰命名法。eg: LoginPage 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式，即首字母小写。 eg: passwordNum / getMessage() / inputPassword 监听事件的事件名 命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 正例: MAX_CAT_COUNT 反例: MAX_COUNT 4.文件夹命名统一小写。正例: components // 存放一些组件 资源图片名字不允许使用中文,全部小写,单词间用下划线隔开。正例: home_back.png // 图片名 页面组件,属性换行：组件属性调用多个时,需要进行换行处理 Vue","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E8%A7%84%E8%8C%83/%E4%BB%A3%E7%A0%81%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"},{"title":"魔鬼数字规范","text":"魔鬼数字的定义：在代码中没有具体含义的数字、字符串。魔鬼数字主要影响了代码可读性，读者看到的数字无法理解其含义，从而难以理解程序的意图。当程序中出现的魔鬼数字过多时，代码的可维护性将会急剧下降，代码变得难以修改，并容易引入错误。 例如： 1234567if (status === 1) { // code} else if (status === 2) { // code} else { // code} 修改后：const ACTIVITY_STATUS_NOT_EXIST = 0 // 活动不存在 const ACTIVITY_STATUS_START = 1 // 活动已开始 const ACTIVITY_STATUS_END = 2 // 活动已结束 1234567if (status === ACTIVITY_STATUS_START) { // code} else if (status === ACTIVITY_STATUS_END) { // code} else { // code} 通过设置常量，并已适当的名称和注释标明，提高代码可读性，名称命名规范为全大写，单词之间使用’_’分割或者将这些常量统一放在某个对象中： 12345678const ENUMSTATUS = { // 注释 ACTIVITY_STATUS_NOT_EXIST: 0, // 注释 ACTIVITY_STATUS_START: 1, // 注释 ACTIVITY_STATUS_END: 2}","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E8%A7%84%E8%8C%83/%E9%AD%94%E9%AC%BC%E6%95%B0%E5%AD%97%E8%A7%84%E8%8C%83/"},{"title":"H5视频播放踩坑记录","text":"场景某H5页面，页面由图片组成，其中某张图片点击后将全屏播放视频(其中视频定位到非可视区域)。视频播放组件采用的第三方库video-react 问题app webview下安卓视频无法播放、ios需要点击两次才播放，微信环境下全屏播放问题 1.居然是样式首先测试的时候pc浏览器以及手机浏览器环境下测试都是ok，所以初步判断问题出在webview上，通过debug，打印点击事件以及相关视频的信息，发现都是正常的并且没有发生报错情况。后猜测是否跟全屏播放有关，将视频取消定位后正常展示，此时播放正常。这时对比前面异常情况发现有个变量定位，遂找到对应样式，发现其中某个属性**z-index**: -1，去掉后一切正常了，Android和iOS均正常播放。至于为什么会受这个属性影响，暂不清楚。 2.关于全屏自动播放视频点击后全屏播放，取消全屏播放后视频暂停(因为视频不在可视区域，没有对应的操作可点)。组件提供了播放以及切换全屏方法，但是并没有切换全屏后的回调事件，好在组件额外提供了subscribeToStateChange方法，可以监听组件的所有状态，一波操作后： 1234567891011121314151617181920212223242526imgClick (item) { const v = this.player // 视频组件实例 v.toggleFullscreen() // 切换全屏 this.showVideoAndPlay = true}/** 监听视频信息变化 */handleStateChange(state) { const v = this.player.player if (!state.isFullscreen) { v.pause() this.showVideoAndPlay = false return } if (state.isFullscreen &amp;&amp; this.showVideoAndPlay){ v.play() /** 这里要重置 不然会无限播放暂停循环*/ this.showVideoAndPlay = false return } if (state.paused) { v.pause() }}componentDidMount() { this.player.subscribeToStateChange(this.handleStateChange.bind(this));} 看到app表现良好，暗暗点了点头，表面很冷静，心里美滋滋。但是，打脸这事，会迟到但是不会缺席，很快测试告知微信环境下播放有问题… 微信视频播放 微信浏览器的视频播放采用了自带的播放器，所以如果按照前面那个方式，点击打开后出现的是个黑屏,需要再次点击播放才能正常播放。经过一波调试，点击播放代码修改如下: 12345imgClick (item) { const v = this.player // 视频组件实例 v.play() v.toggleFullscreen() // 切换全屏 } 但是又发现安卓跟ios表现又是不一样 ios下正常，安卓下视频播放变为横屏，且没有自动播放，在点击播放然后退出全屏或者直接退出全屏后再次重新播放，正常竖屏并且自动播放。 同时，在app 安卓环境下，全屏后无法自动播放。 上诉两个问题在调整播放跟切换全屏两个方法后各自解决，于是代码修改为：1234567891011imgClick (item) { const v = this.player // 全屏跟播放顺序在app环境跟微信下是两个结果 ios默认播放全屏 if (bridge.isInApp()) { !this.$os.ios &amp;&amp; v.toggleFullscreen() // 切换全屏 v.play() } else { v.play() !this.$os.ios &amp;&amp; v.toggleFullscreen() // 切换全屏 } } 其中对全屏方法做了环境判断是因为 iso 下默认播放全屏至此，app与微信环境下全屏展示基本一致，只剩下安卓微信环境下自动播放问题。这个问题最终采用延时方案解决，但并不是完美解决，还是会存在偶发的不能自动播放的情况。具体什么原因全靠猜，其中机制并不是特别清楚，有待后续研究。所以最后代码修改如下： 1234567891011imgClick (item) { const v = this.player // 全屏跟播放顺序在app环境跟微信下是两个结果 ios默认播放全屏 if (bridge.isInApp()) { !this.$os.ios &amp;&amp; v.toggleFullscreen() // 切换全屏 v.play() } else { v.play() !this.$os.ios &amp;&amp; setTimeout(() =&gt; {v.toggleFullscreen()},500) // 切换全屏 } } 补充1ios 微信环境下视频初始化黑屏解决方案： // react ref … ref={player =&gt; { this.player = player // 微信sdk this.$JSBridge({ success: () =&gt; { this.player.pause(); } }, &quot;getNetworkType&quot;); }} … 1","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E9%97%AE%E9%A2%98%E8%B8%A9%E5%9D%91/H5%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"title":"微信不支持检测 HTML History PushState 变化的问题","text":"问题描述如果你在微信里面浏览一个网站，这个网站使用了 HTML History 的 PushState 来更改 URL 的话（SPA应用中的browser history模式），微信会无视这个 URL 的变化，于是导致你在分享这个 URL 的时候，发现始终是这个网站的最初的 URL，而不是最新的 URL。比如：访问A页面，然后进入B页面，分享到外部的链接依然是A页面的URL。 影响 分享验签时的targUrl无效 回退空白页 支付目录验证不通过解决方案 尝试：默认路由监听组件变更，通过以下形式： replaceState形式强制变更当前state location重定向自身位置 location重定向自身位置+时间戳 以上方案无效。 最终方案：react-router history跳转改为location.href重定向形式，导致状态管理可能会受限，多余资源请求。 React-Router并不是Router的问题，而是微信浏览器的功能缺陷（暂时理解）。 相关问题：IOS WeChat share address is not the current page routing addressapplication can’t rerendering view when application back from the third page","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E9%97%AE%E9%A2%98%E8%B8%A9%E5%9D%91/%E5%BE%AE%E4%BF%A1%E4%B8%8D%E6%94%AF%E6%8C%81%E6%A3%80%E6%B5%8B%20HTML%20History%20PushState%20%E5%8F%98%E5%8C%96%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"内置对象","text":"1、JSON123456789101112131415161718/** * 构造器 */// 无/** * 静态方法 */JSON.parse(text[, reviver])JSON.stringify(value[,replacer[,space]])/** * 静态属性 */// 无 2、Math123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 构造器 */// 无/** * 静态方法 */// 三角函数Math.cos(x)Math.acos(x)Math.sin(x)Math.asin(x)Math.tan(x)Math.atan(x)Math.atan2(y,x)// 双曲函数Math.sinh(x)Math.asinh(x)Math.cosh(x)Math.acosh(x)Math.tanh(x)Math.atanh(x)// 对数函数Math.log(x)Math.log2(x)Math.log1p(x)Math.log10(x)// 数学计算Math.abs(x)Math.pow(x,y)Math.sqrt(x)Math.cbrt(x)Math.exp(x)Math.expm1(x)Math.hypot(x[,y[,...]]])Math.imul(x,y)// 功能函数Math.floor(x)Math.ceil(x)Math.max([x,[y,...]]])Math.min([x,[y,...]]])Math.random(x)Math.round(x)Math.trunc(x)Math.sign(x)Math.fround(x)Math.clz32(x)/** * 静态属性 */Math.PIMath.EMath.LN2Math.LN10Math.LOG2EMath.LOG10EMath.SQRT1_2Math.SQRT1_2 3、Boolean1234567891011121314151617181920212223242526272829303132333435/** * 构造器 */// 一、类型转换// 1. 假值Boolean（）Boolean(0)Boolean(-0)Boolean(null)Boolean(false)Boolean(NaN)Boolean(undefined)Boolean(“”)// 2. 真值// 除去所有假值的情况，包括空数组、空对象或者&quot;false&quot;等// 二、对象构造new Boolean(false) // 对象构造/** * 静态方法 */// 无/** * 静态属性 */Boolean.prototype // Boolean 类型Boolean.prototype.constructorBoolean.prototype.toString()Boolean.prototype.valueOf() 4、Number123456789101112131415161718192021222324252627282930313233343536373839/** * 构造器 */Number(’123‘ ） // 类型转换new Number(123) // 对象构造/** * 静态方法 */Number.isNaN（）Number.isFinite（）Number.isInteger（）Number.isSafeInteger（）Number.parseFloat（）Number.parseInt（）/** * 静态属性 */Number.EPSILONNumber.MAX_SAFE_INTEGERNumber.MIN_SAFE_INTEGERNumber.MAX_VALUENumber.MIN_VALUENumber.NaNNumber.NEGATIVE_INFINITYNumber.POSITIVE_INFINITYNumber.prototype // Number 类型Number.prototype.constructorNumber.prototype.toExponential（）Number.prototype.toFixed（）Number.prototype.toLocaleString（）Number.prototype.toPrecision（）Number.prototype.toString（）Number.prototype.valueOf（） 5、Error123456789101112131415161718192021/** * 构造器 */Error() // 等铜于 new Error()/** * 静态方法 */// 无/** * 静态属性 */Error.prototype.constructorError.prototype.messageError.prototype.nameError.prototype.toString（） 其他错误类型对象： EvalError RangeError ReferenceError SyntaxError TypeError URIError 6、RegExp12345678910111213141516171819202122232425262728293031323334353637383940/** * 构造器 */RegExp() // 等铜于 new RegExp()/** * 静态方法 */// 无/** * 静态属性 */RegExp.RegExp[Symbol.species]RegExp.lastIndexRegExp.prototype //ObjectRegExp.prototype.constructorRegExp.prototype.globalRegExp.prototype.ignoreCaseRegExp.prototype.multipleRegExp.prototype.sourceRegExp.prototype.flagsRegExp.prototype.dotAllRegExp.prototype.stickyRegExp.prototype.unicodeRegExp.prototype.lastIndex // 在全局匹配的正则表达式上，exec、test 会改变此属性RegExp.prototype.exec（）RegExp.prototype.test（）RegExp.prototype.[Symbol.match]（）RegExp.prototype.[Symbol.matchAll]（）RegExp.prototype.[Symbol.replace]（）RegExp.prototype.[Symbol.search]（）RegExp.prototype.[Symbol.split]（）RegExp.prototype.toString（） 7、Date123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 一、构造器 */// 结果为字符串Date() // 表示实例化时刻的日期和时间，不接受参数// 结果为对象new Date() // 表示实例化时刻的日期和时间new Date(value) // 入参表示自 1970 年 1 月 1 日 00:00:00以来的毫秒数new Date(dateString) // dateString 为表示日期的字符串new Date（year,monthIndex,[day[,hours[,minutes[,seconds[,milliseconds]]]]]） // 至少提供年份与月份/** * 二、静态方法 */Date.now（） // 返回自 1970-1-1 00:00:00 UTC（世界标准时间）至今所经过的毫秒数Date.parse() // 解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00所经过的毫秒数Date.UTC() // 接受和构造函数最长形式的参数相同的参数，并返回从 1970-1-1 00:00:00 UTC 开始所经过的毫秒数/** * 三、静态属性 */Date.length // 继承自 Function 的属性，为7，即该构造函数可接受的参数个数Date.prototype // ObjectDate.prototype.constructor// GetDate.prototype.getFullYear（）Date.prototype.getUTCFullYear（）Date.prototype.getMonth（）Date.prototype.getUTCMonth（）Date.prototype.getDate（）Date.prototype.getUTCDate（）Date.prototype.getDay（）Date.prototype.getUTCDay（）Date.prototype.getHours（）Date.prototype.getUTCHours（）Date.prototype.getMinutes（）Date.prototype.getUTCMinutes（）Date.prototype.getSeconds（）Date.prototype.getUTCSeconds（）Date.prototype.getMilliseconds（）Date.prototype.getUTCMilliseconds（）// SetDate.prototype.setFullYear（）Date.prototype.setUTCFullYear（）Date.prototype.setMonth（）Date.prototype.setUTCMonth（）Date.prototype.setDate（）Date.prototype.setUTCDate（）Date.prototype.setHours（）Date.prototype.setUTCHours（）Date.prototype.setMinutes（）Date.prototype.setUTCMinutes（）Date.prototype.setSeconds（）Date.prototype.setUTCSeconds（）Date.prototype.setMilliseconds（）Date.prototype.setUTCMlliseconds（）Date.prototype.setTime（）// OtherDate.prototype.toDateString（）Date.prototype.toISOString（）Date.prototype.toJSON（）Date.prototype.toLocaleDateString（）Date.prototype.toLcaleString（）Date.prototype.toLocaleString（）Date.prototype.toLocaleTimeString（）Date.prototype.toString（）Date.prototype.toTimeSting（）Date.prototype.toUTCString（）Date.prototype.valueOf（） 8、String1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 一、构造器 */String(123) // 类型转换new String(123) // 对象构造/** * 二、静态方法 */String.fromCharCode()// 通过一串 Unicode 创建字符串String.fromCodePoint() // 通过一串 码点 创建字符串/** * 三、静态属性 */String.prototype // objectString.prototype.constructorString.prototype.length // 返回字符串长度// 查找索引位置字符String.prototype.N // 'abcd'[3] =&gt; dString.prototype.charAt()// 返回指定索引位置的字符String.prototype.charCodeAt() // 返回指定索引位置的字符的 Unicode 值String.prototype.codePointAt() // 返回使用 UTF-16 编码的给定位置的值的非负整数// 子串搜索String.prototype.includes() // 判断一个字符串里是否包含其他字符串String.prototype.indexOf()String.prototype.lastIndexOf()String.prototype.match()String.prototype.search() // 对正则表达式和指定字符串进行匹配搜索，返回第一个出现的匹配项的下标String.prototype.startsWith() // 判断当前字符串是否以另外一个给定的子字符串开头String.prototype.endsWith() // 判断当前字符串是否以另外一个给定的子字符串结尾// 片段截取String.prototype.slice()String.prototype.substring()String.prototype.substr()// 补位String.prototype.padStart()String.prototype.padEnd()// 去空格String.prototype.trim()String.prototype.trimStart()| trimLeft()String.prototype.trimEnd()| trimRight()// 大小写转换String.prototype.toLocaleLowerCase()String.prototype.toLowerCase()String.prototype.toLocaleUpperCase()String.prototype.toUpperCase()String.prototype.concat() // 连接String.prototype.split() // 拆分String.prototype.repeat() // 重复String.prototype.replace() // 替换String.prototype.localeCompare()String.prototype.normalize()String.prototype.toString()String.prototype.valueOf()String.prototype.String.prototype[@@iterator]() 9、Array123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 一、构造器 */new Array（） // 空数组：[]new Array（length） //（有且仅有一个参数，并且为 Number类型）：构造一个长度为入参、每一项为 undefined 的数组new Array（element0, element1[, ...[, elementN]]）/** * 二、静态方法 */Array.from(arrayLike，mapFn，thisArg) // 将类数组、可迭代对象创建为一个新的、浅拷贝的数组实例Array.of // 弥补 Array 构造函数入参为单个数字时的迷惑行为Array.isArray/** * 三、静态属性 */Array.prototype // ArrayArray.prototype.constructorArray.prototype.length// 变异方法Array.prototype.copyWithin(target，start，end) // 截取 start 到 end 区间的元素，复制到 target Array.prototype.fill(value，?start，?end) // 用 value 替换 start 到 end 区间的值Array.prototype.reverse()Array.prototype.sort(fn)Array.prototype.pop() // 删除末尾一个元素，并返回该元素的值Array.prototype.push(element1，...，elementN)// 向数组末尾添加新的元素Array.prototype.shift()// 删除第一个元素，并返回该元素的值Array.prototype.unshift(element1，...，elementN)// 向数组开头添加新的元素Array.prototype.splice(start，?deleteCount，item1，...，itemN)// 删除或替换现有元素，并且可以追加元素到当前删除位置 // 非变异方法Array.prototype.concat()// 返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。Array.prototype.includes()// 判断一个数组是否包含一个指定的值Array.prototype.join(?separator)// 返回数组所有元素以分隔符分割后的字符串Array.prototype.slice(start，end)// 返回包含某个区间内元素的新数组Array.prototype.toString()Array.prototype.toLocaleString()Array.prototype.indexOf(searchElement，?fromIndex)Array.prototype.lastIndexOf(searchElement，?fromIndex)Array.prototype.forEach// 迭代器Array.prototype.entries() // 返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。Array.prototype.keys() // 返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。Array.prototype.values()| [Symbol.iterator()] // 返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。// 条件检测Array.prototype.every() // 检测数组中是否每一个元素都满足测试函数Array.prototype.some()// 检测数组中是否至少有一个元素满足测试函数// 迭代修改Array.prototype.filter()// 将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。Array.prototype.map()// 返回一个由回调函数的返回值组成的新数组。// 扁平化Array.prototype.flat(depth = 1) // 数组扁平化Array.prototype.flatMap(cb(current，index，array)) // 还不太会用// 查找Array.prototype.find()Array.prototype.findIndex()// 从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。Array.prototype.reduce(cb(accumulator，item，index，sourceArray)，initialValue) // 从右到左为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。Array.prototype.reduceRight(cb(accumulator，item，index，sourceArray)，initialValue) 10、Function12345678910111213141516171819202122232425262728/** * 一、构造器 */new Function([arg1[, arg2[, ...argN]],] functionBody) // const sum = new Function('a', 'b', 'return a + b');Function([arg1[, arg2[, ...argN]],] functionBody)// 同 new Function（）/** * 二、静态方法 */// 无/** * 三、静态属性 */Function.arguments // 被全局变量 arguments 替代Function.caller // 获取调用函数的具体对象Function.length // 获取函数的接收参数个数Function.name // 'Function'Function.prototype // 'function'Function.prototype // 'function'Function.prototype.apply(thisArg，?[argsArray])Function.prototype.call(thisArg，?arg1，?arg2，...)Function.prototype.bind(thisArg，?arg1，?arg2，...)Function.prototype.isGenerator()Function.prototype.toString() 11、Object1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 一、构造器 */// 1: 如果给定值是 null 或 undefined，将会创建并返回一个空对象// 2: 如果传进去的是一个基本类型的值，则会构造其包装类型的对象// 3: 如果传进去的是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址new Object（[value]）Object（[value]）// 同 new Object（） /** * 二、静态方法 */Object.is(value1,value2)// 判断两者是否相等// 创建对象Object.assign（target，...source）// 复制对象Object.create（proto，?propertiesObject）// 使用现有对象作为原型对象来创建一个新对象// 原型Object.setPrototypeOf（obj，prototype）// 设置一个指定的对象的原型Object.getPrototypeOf（obj）// 返回指定对象的原型对象。// 属性遍历Object.keys（obj）// 返回一个由一个给定对象的自身可枚举属性组成的数组Object.values（obj）// 返回给定对象自身可枚举值的数组。Object.entries（obj）// 返回给定对象自身可枚举属性的键值对数组Object.preventExtensions（obj）// 防止对象的任何扩展Object.isExtensible（obj）// 判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）Object.freeze（obj）// 冻结一个对象Object.isFrozen（obj）// 判断对象是否已经冻结。Object.seal（obj）// 防止其他代码删除对象的属性。Object.isSealed（obj）// 判断一个对象是否被密封。Object.defineProperty（obj，prop，descriptor）// 给对象添加/修改一个属性并指定该属性的配置Object.defineProperties（obj，props）// 给对象添加多个属性并分别指定它们的配置。Object.getOwnPropertyDescriptor（obj）// 返回指定对象上的一个自有属性对应的描述符Object.getOwnPropertyNames（obj）// 返回一个由指定对象的所有自身属性的属性名称组成的数组Object.getOwnPropertySymbols（obj）// 返回一个给定对象自身的所有 Symbol 属性的数组。/** * 三、静态属性 */Object.prototype // 'object'Object.prototype.constructorObject.prototype.hasOwnProperty（）// 判断属性是否存在且存在于自身Object.prototype.isPrototypeOf（）// 检查一个对象是否存在于另一个对象的原型链上Object.prototype.propertyIsEnumerable（）// 判断指定属性是否可枚举Object.prototype.toString（）Object.prototype.toLocaleString（）// 同 toStringObject.prototype.valueOf（）constructorconstructorconstructorObject.prototype.apply(thisArg，?[argsArray])Function.prototype.call(thisArg，?arg1，?arg2，...)Function.prototype.bind(thisArg，?arg1，?arg2，...)Function.prototype.isGenerator()Function.prototype.toString() 12、Set123456789101112131415161718/** * 一、构造器 */new Set（[iterable]）/** * 二、静态属性 */Set.prototypeSet.prototype.constructorSet.prototype.sizeSet.prototype.add（value）Set.prototype.delete（value）Set.prototype.has（value）Set.prototype.clear（）Set.prototype.entries（）Set.prototype.keys（）Set.prototype.values（） 13、WeakSet12345678910111213/** * 一、构造器 */new WeakSet（[iterable]）/** * 二、静态属性 */Set.prototypeSet.prototype.constructorSet.prototype.add（value）Set.prototype.delete（value）Set.prototype.has（value） 14、Map1234567891011121314151617181920/** * 一、构造器 */new Map（[iterable]）/** * 二、静态属性 */Map.lengthMap.prototypeMap.prototype.constructorMap.prototype.set（key，value）Map.prototype.get（key）Map.prototype.delete（key）Map.prototype.clear（）Map.prototype.has（key）Map.prototype.entries（）Map.prototype.keys（）Map.prototype.values（）Map.prototype.forEach（cb，thisArg） 15、WeakMap123456789101112131415/** * 一、构造器 */new WeakMap（[iterable]）/** * 二、静态属性 */WeakMap.lengthWeakMap.prototypeWeakMap.prototype.constructorWeakMap.prototype.get（key）WeakMap.prototype.has（key）WeakMap.prototype.set（key，value）","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/JavaScript/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"},{"title":"三年前端面试经验加感悟","text":"19年年底的时候从工作了两年半的公司离职，用了半个月的时看面试题及刷算法，半个月后开始投递简历，分别投了阿里、百度、快手和字节跳动，除了阿里一面匆匆忙忙电话面试把我咔掉了之外，百度、快手是现场面，字节跳动视频面，三家offer全都拿到，最终选择了字节跳动三家面试，都是三轮技术面加一轮hr面，实际上，无论是哪家的面试，问的东西都是很相似的，都可以在网上搜到答案，都一定存在于某篇面试题汇总文章内，因为技术就是那个技术，就算是问出花来，本质或原理还是一样的，想看详细的真实面试题，掘金、牛客网、知乎都有很多，随便找下都看不完授人以鱼不如授人以渔，这篇文章还有其他我觉得更值得分享的东西，所以为了避免篇幅过长，我就不详细一一列举我在这些公司中都碰到过什么题目了，每家各提两句我印象比较深刻的 百度百度是我被阿里咔了之后面试的第一家公司，年前北京还是可以现场面试的，所以我也是去百度现场面一面问的基本上都是基本功了，值得一提的是，百度是三家中唯一一个问我 CSS 问题的，大概就是面试官现场从他正在做的业务中拿了一个布局场景，让我写样式做好布局（不是圣杯布局或者双飞翼布局之类的），主要考察对 CSS 的灵活运用，需要稍微动点脑筋二面也问了一点基础，主要还是考察了一些场景解决方案或设计方案，算法的话，就问了一个原理是二叉树后序遍历的题目，比较简单，没费什么事就做出来了三面应该是经理面，就问了一个场景设计题，然后就开始谈人生理想，为什么离职啊，有什么规划啊，在之前团队做过什么有贡献的事情啊，碰到过什么难题啊最后又是怎么解决的啊，加入百度后你想做什么啊，等等，反正我感觉我回答这些问题比我回答技术题难多了，因为有些问题太抽象了，我都不知道想问什么，但又不好一直追问他到底想问什么，我只能根据我的理解来回答，一边回答一边还要察言观色，直到面试官感觉差不多了才能停，说得我口干舌燥，我宁愿多问我几个技术问题总结一下，百度的这场面试，更倾向于考察实际做事能力，问的都是很实际的问题，如果恰好曾经在实际工作中碰到过这些问题，或者看过相关的文章，回答起来基本是问题不大的百度的部门是百度APP，算是主航道吧，也挺想去的，但最后因为一些原因还是拒了 快手一面同样还是考察基础，面试官的工作技术栈是 React，我的是 Vue，面试官也没有为难我，就从 Vue问起，问了一些面试题常见的什么响应式什么diff算法什么观察者模式之类的，因为我之前系统性地看过 Vue源码，所以回答起来也没什么难度，并且回答完了之后，顺便给他额外讲了下 Vue的执行流程和相关源码原理之类的，说得比较多，面试官还是挺满意的二面问了原型链等比较高级抽象的东西，然后问的其中一个算法是洗牌算法，我感觉问这个题目其实不太好，因为洗牌算法这个算法有点太独立了，不是什么回溯啊动态规划啊分治啊这些，是无法举一反三的一个题目，如果你恰好看过洗牌算法的实现，就那几行代码，你闭着眼睛都能写出来，如果你没看过，可能你想破脑袋都不知道该怎么写，当然，换个角度，运气也是实力的一部分三面应该是团队的前端负责人吧，和百度三面问得差不多的问题，都是先来一道场景设计题考察一下技能运用能力，然后开始问规划之类的人生理想总结一下，快手的这场面试考察得更加全面，同时和三面的前端负责人挺能聊得来，感觉挺合适的，而且快手也是我主动投递的最后一家公司，面完之后第二天我就回家过年了，就等着年后入职了，只不过还是没去成，因为我跳车字节跳动了 字节跳动其实我没打算投字节跳动的，是过年在家玩耍的时候字节的hr 把我从简历库捞出来给我打电话让我投一下，说可以年后视频面试，我想了下，投就投吧，反正也没事，万一快手那边出了什么岔子我还有后路可走，然后就约了视频面试，结果没成想就过了三面面试官就是我现在的leader，聊完后觉得也很对眼，再加上我一年前和半年前其实投过字节跳动两次，第一次过了，但因为某些原因我没去，第二次没过，现在是第三次，过了，比较纠结，因为已经接了快手的电子offer，反悔不太好，但又想了下，可能这就是缘分吧，我感觉就算我这次不进字节，将来早晚也要进，晚进不如早进，所以就只好对不住快手那边了 成功面试的几个经验经过这些面试，加上我看过的一些面经，我稍微总结了一下大厂面试成功的几个经验 学历这很好理解，无论你工作了几年，hr或面试官看简历第一眼想看的就是学历，这是一个很直观地给简历打分的点，好的学历不一定能让你通过面试，但却可以让你的简历通过初筛，很多人可能就因为学历这一关，导致连面试流程都进不去，可能空有一身本事却无法施展但这也是可以理解的，大厂简历太多了，hr不可能给所有人面试机会的，否则面试官其他的啥也不干加上24小时连抽转也面试不过来啊，学历是一个很直观的筛简历的方式 工作经历学历这种事情既然发生了就没法改变了，只能认了，但学历最大的作用其实还是让简历通过初筛，如果你的学历不足以让你的简历通过筛选，那么你还可以将希望放在一个好的工作经历上你的学历不够让你立刻进大厂，但可以先进一些二三线厂或者小型的独角兽啊，那这可选择的范围就很多了，在这个层次的公司老老实实待个两年，期间别忘了修炼好基本功，别荒废了两年后你的标签就是一个学历不是太好，但工作经历还不错，并且比较沉得住气的一个候选人，一般情况下，大厂给你个面试机会肯定还是没问题的，进入面试流程后，那就是你真正凭本事的时候了这里有三点需要注意： 作为跳板的公司不能太小了 最起码是二三线或者独角兽，公司太小了也不可能给你太好的项目经历，另外，面试官和hr大概率得听说过你这个公司 不要频繁跳槽 如果你是从腾讯跳到阿里再跳到微软谷歌，哪怕你半年一跳都没有任何问题，但如果你是从一个不知名小厂跳到另外一个不知名小厂，这种一年一跳hr都嫌你跳得太频繁了，觉得你不稳定，半年一跳就没法看了，如果你在小厂，然后将来想去大厂，那么就要稳住，别把简历搞花了 不要闷头搬砖 无论在哪工作，肯定都是以写业务代码居多，也就是搬砖了，但既然你打定了主意将来要去大厂，那么就绝对不能真的局限于搬砖，要把砖搬出花来比如发现项目中有个结构不太合理，但凑合着用问题也不是太大，那么你就得想我不能凑合，我得把它整舒服了才行，然后说干就干直到真的把它搞定，比如你觉得工作流程中有些步骤是重复工作，那你可以考虑下是不是可以造个轮子解决这个问题我经历的面试，很多情况下就是让你给出解决方案，考得就是技术的实际运用能力，几乎每一轮面试我都会碰到这种题目，这就要求你在平时工作中要有意识的积累，光搬砖你是说不出来完整的解决方案的，当然，一些常见的基础知识比如原型链、闭包、diff算法等也都是会问的，所以你不能因为平时搬砖很少用到这些就不管了，有些知识点你可能知道是怎么回事，但就是说不明白，那也是不行的，一定要真的弄明白了总而言之，就是要有自己的思考，不能光顾着搬砖，因为搬砖谁都会，大家都一样，都是搬砖的，凭什么你能去大厂我不能去？所以你就得比他们强才行，没条件创造条件也要上 个人修炼如果你因为实在太倒霉，去的公司接连倒闭或者领导们都太xx，你没办法不频繁跳槽，自然也没有可以拿出手的好项目，然后把简历搞花了，也不是就无法补救了的，外界条件靠不住，你还可以纯靠自己啊比如写博客，记录自己平日的技术思考，倒腾出的解决方案，创建或者参与开源项目，把自己的博客和 Github整得有模有样，各种分析、源码、解决方案、开源项目，面试官点进去看了后笑容满面，你还愁你没有面试机会吗？个人修炼也有助于我上面提到过的面试官喜欢问的场景设计题比如，现在需要你重构百度app首页的feed流，feed流的展示的每一条数据，它的功能、样式会根据这条数据不同归属有不同的效果，比如广告、百家号、小视频等，点击数据流会有一些操作，比如打开一个modal或者播放一个小视频或者跳转一个页面，那么请你说下当你接到这个需求时你想要怎么设计？这是一种考查知识点很多，并且问的问题范围比较大的题目？不会涉及到具体的问题点，考察的就是候选人的知识广度和深度，平时的积累，考虑问题的维度等方面，上面那个题，是没有明确答案的这个时候就是考验候选人个人修炼的时候了，有的人可能一脸懵逼随便说几句就不知道该继续说什么了，有的人则可以跟你说上几个小时还意犹未尽，如果我是候选人，我可能会从长列表的优化、跨域/跨页面通信、配置化（可维护性）、数据预加载、数据缓存、页面/组件无缝切换/转场动画、离线包/ssr等角度来回答这个问题，如果没有这些知识储备，是不可能想到这些的，场景设计题是一个可以让面试官全方位认知你，同时也是你自由发挥的一类题目，所以一般大厂面试都会问到这类题目然后也有几点需要注意： 高质量博客博客既然是反映你自己技术水平的一个地方，那么首先就要保证原创，确实是你的东西，如果全是搬运的 API文档或者其他人的东西或者小白教学的无脑文，那么还不如没有，面试官看了后只会觉得你难道就这点水平？所以，博客的质量一定要保证 持之以恒不能三天打鱼两天晒网，一定要坚持下去，形成一个连贯的体验，一是让人一看就觉得你这人确实是认真在做这件事情，二是只有这样你才能有足够多的积累，几十篇文章肯定比寥寥几篇文章更能让面试官全方面了解你 亮点这其实是一个在很多时候可以一招制胜的关键关于亮点这个东西，我在 前面一篇文章的最后 其实已经说过了，这里我就知道照抄过来了： 最近参加了几场面试，发现面试官们都很喜欢问你有哪些亮点，不管是业务层面还是技术层面，并会按照你给出的答案深入下去，看看你这个亮点到底有多亮一个追问你亮点的面试官，其实是比较愿意给你机会的，技术的范围太广，可能他问的你恰好不熟悉，这是很常见的事情，比如你熟悉 vue，他团队内用的都是 React，他追着你问 React可能很难问出结果来，另外一方面，你也无法保证在每场面试中都保持最佳状态，万一你跟面试官根本不在同一个频道上，你们之间相互听不懂对方在说什么，还怎么继续？所以把选择权交给你，给你机会让你自己选，那么这就引出另外一个问题，如果你真的没做过什么有亮点的事情怎么办？给你机会你都抓不住，这可怪不到别人了所以，如果你有一个较高的追求，那么在平时的工作中，哪怕是天天写业务代码，你也要有自己的思考，这个组件可不可以换一种写法，那个需求是不是可以简化一下，项目里的webpack需不需要升级到最新版，这个问题可不可以造个轮子来一劳永逸地搞定它？无关问题大小，都可以引发思考，实际上，一般情况下也不太可能有什么大问题等着你去解决，大部分情况下都是小问题，但问题再小，解决得多了那也是一种可观的积累，通过这种积累，在团队内部，你就有了可以拿出来说的输出贡献，离开了团队，你也能以此抓住面试官给你的机会有时候，这种亮点比你背面试题刷算法还好用，毕竟，面试题或者算法题会就是会，不会就是不会，但是亮点这种东西可没有标准答案，能说的可多了去了 需要注意的是，你的这个亮点一定要足够亮，不能就亮一秒就没了，容易闪着眼，必须要足够坚挺也就是你必须要在你这个亮点上有足够的深入和见解，上下游和细枝末节都要搞清楚，足以应对面试官展开而来的提问，这样面试官才会觉得你确实是擅长这方面 软素质 简历用点心 简历是招聘流程开始的第一步，首先最起码找个好点的模板，网上很多然后就是内容要好好写，切忌罗列毫无意义的技术点，什么jq/vue/vuex/react/redux/http/cdn/vim/git，不是不能写，而是你别占用太多篇幅煞有其事地介绍这些，一句话完事就行了，要突出重点不要写精通什么什么东西，精通这个东西每个人理解得都不一样，你觉得精通就是能在任意场景下熟悉运用。面试官可能觉得你既然精通 js，怎么 vue是 Evan You写的而不是你呢？搞不好要为难你一把，所以尽量避免这些可能引起争论的东西重点写你做过的项目，项目用到的技术栈，大概功能是什么，你在其中扮演了什么角色，写重点就行了，别写得跟文档一样又多又长，细枝末节的东西等到面试的时候会问你的，三年以内工作经验的简历最好不要超过两页如果你博客或 github上有点东西，最好把链接带上，如果就是一个空壳子，没什么内容，就别放上去了另外，个人建议，简历上最好放张照片，相当于给简历增添特定的主语，有明确的个人属性，跟长得好不好看关系不大，除非你实在是觉得自己长得有点对不住全国观众那就算了 一定要会表现自己 面试官的初衷肯定是想尽可能多地了解你，这样才能更好地评估你的能力，但问的问题可能就一两句话，那么作为候选人，你不能就因为面试官只问你1+1等于几然后你回答个2就完事了，这种回答虽然合格，但不是面试官最想得到的答案给出了标准答案后，你应该根据主动面试官问的问题继续发散开来，比如为什么等于2，有什么实际运用的场景，以往有没有等于3的情况？具体点话，比如面试官给你出了个原型链的题目，那么你要做的就不仅仅是把这个道题做出来，除此之外，最好还要主动说一下原型链的相关原理，最好现场画个关系图出来，然后说下有哪些应用场景，比如原型链继承，如果你说了这个，那么其实还可以继续往继承上延伸（尽管面试官根本没问你这个），总之就是要把你的知识点全都体现出来，尽可能多地给面试官透露你的能力这不是偷奸耍滑，这恰恰是面试官想要看到的，他不需要绞尽脑汁地刻意引导，你就自己主动坦白了，面试官肯定高兴啊，最起码说明你懂得确实多，因为知识点掌握的不咋滴的人，他也说不出这么多来你通过在某个知识上深入或发散的表现，一定程度上，也可以触发晕轮效应，某一方面的突出会给面试官留下深刻的印象，就像是月亮的光晕，导致面试官下意识地就忽略了你其他方面的不足很多的程序猿可能就是不善于言辞，但这又不是让你搞社交，技术方面的东西我觉得还是可以开口多说两句的 第一印象 面试有时候也要看眼缘，有的面试官，在你刚看到他的时候，你就知道这场面试肯定过不了，同样的，有的面试官，在刚看到你的时候，就决定不给你过了所以第一印象很重要，程序猿不需要西装革履，但也别太懒散，特别是个人的精气神方面，决不能弱了，一定要有精神，不要因为担心面试过不了而一副诚惶诚恐的样子，你越这样反而越过不了面试你的人，基本是就是你将来的同事、leader或者隔壁组的同事，换做是你，你肯定也不想招个看着就邋遢，性格太负面的人进来当同事，所以一定要自信，需要注意的是，自信和狂妄是两回事，自信和谦虚也并不冲突 小结作为技术人，最重要的就是自己的技术能力，很多人在刚毕业的时候一腔热血，每天打鸡血一般通宵工作也不嫌累，但是后来被社会毒打的次数多了，很容易就疲倦了，可能有的人喊着喊着就放弃了，开始安于现状，这是很危险的事情，技术这条路不进则退，只有持续学习才能在技术这条路上越走越远而另外一方面，客观的困难确实又是存在的，比如工作量太大没时间，前端技术发展太快学不完等，这就需要你找到一条可持续发展的道路，比如每周仔细研读一篇高质量技术文章，或者定期地进行总结，不要给自己太大的压力，但又必须要保持学习和进步无论你选择的方法是什么，最终最重要的还是要落到实处，收藏了一大堆优秀文章的链接放在收藏夹吃灰是没用的 作者：清夜链接：https://juejin.im/post/5e6ca27e6fb9a07c8076cea5来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/%E4%B8%89%E5%B9%B4%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%8A%A0%E6%84%9F%E6%82%9F/"},{"title":"史上最全前端面试题（啃完不秃头算我输）","text":"Vue面试题生命周期函数面试题 1.什么是 vue 生命周期 2.vue生命周期的作用是什么 3.第一次页面加载会触发哪几个钩子 4.简述每个周期具体适合哪些场景 5.created和mounted的区别 6.vue获取数据在哪个周期函数 7.请详细说下你对vue生命周期的理解？ vue路由面试题 1.mvvm 框架是什么？ 2.vue-router 是什么?它有哪些组件 3.active-class 是哪个组件的属性？ 4.怎么定义 vue-router 的动态路由? 怎么获取传过来的值 5.vue-router 有哪几种导航钩子? 6.route和router 的区别 7.vue-router响应路由参数的变化 8.vue-router传参 9.vue-router的两种模式 10.vue-router实现路由懒加载（ 动态加载路由 ） vue常见面试题 1.vue优点 2.vue父组件向子组件传递数据？ 3.子组件像父组件传递事件 4.v-show和v-if指令的共同点和不同点 5.如何让CSS只在当前组件中起作用 6.的作用是什么? 7.如何获取dom 8.说出几种vue当中的指令和它的用法？ 9.vue-loader是什么？使用它的用途有哪些？ 10.为什么使用key 11.axios及安装 12.axios解决跨域 13.v-modal的使用 14.scss的安装以及使用 15.请说出vue.cli项目中src目录每个文件夹和文件的用法？ 16.分别简述computed和watch的使用场景 17.v-on可以监听多个方法吗 18.$nextTick的使用 19.vue组件中data为什么必须是一个函数 20.vue事件对象的使用 21 组件间的通信 22.渐进式框架的理解 23.Vue中双向数据绑定是如何实现的 24.单页面应用和多页面应用区别及优缺点 25.vue中过滤器有什么作用及详解 26.v-if和v-for的优先级 27.assets和static的区别 28.列举常用的指令 29.vue常用的修饰符 30.数组更新检测 31.Vue.set视图更新 32.自定义指令详解 33.vue的两个核心点 34.vue和jQuery的区别 35 引进组件的步骤 36.Vue-cli打包命令是什么？打包后悔导致路径问题，应该在哪里修改 37.三大框架的对比 38.跨组件双向数据绑定 39.delete和Vue.delete删除数组的区别 40.SPA首屏加载慢如何解决 41.Vue-router跳转和location.href有什么区别 42.vue slot 43.你们vue项目是打包了一个js文件，一个css文件，还是有多个文件？ 44.vue遇到的坑，如何解决的？ 45.Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？ 46.Vue2中注册在router-link上事件无效解决方法 47.RouterLink在IE和Firefox中不起作用（路由不跳转）的问题 48.axios的特点有哪些 49.请说下封装 vue 组件的过程？ 50.vue 各种组件通信方法（父子 子父 兄弟 爷孙 毫无关系的组件） 51.params和query的区别 52.vue mock数据 53 vue封装通用组件 54.vue初始化页面闪动问题 55.vue禁止弹窗后的屏幕滚动 56.vue更新数组时触发视图更新的方法 57.vue常用的UI组件库 58.vue如何引进本地背景图片 59.vue如何引进sass 60.vue修改打包后静态资源路径的修改 vuex常见面试题 1.vuex是什么？怎么使用？哪种功能场景使用它？ 2.vuex有哪几种属性 3.不使用Vuex会带来什么问题 4.Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？ 5.vuex一个例子方法 6.Vuex中如何异步修改状态 7.Vuex中actions和mutations的区别 vue项目实战 1.顶部悬停效果 2.电话本列表效果（ 右边字母分类 上下滑动 旁边字母显示高亮） 3.vue做代理 4.Vue路由切换时的左滑和右滑效果示例ES6面试题 ES6新增方法面试题 1.let const var比较 2.反引号（`）标识 3.函数默认参数 4.箭头函数 5.属性简写 6.方法简写 7.Object.keys()方法，获取对象的所有属性名或方法名 8.Object.assign ()原对象的属性和方法都合并到了目标对象 9.for…of 循环 10.import和export 11.Promise对象 12.解构赋值 13.set数据结构（可用于快速去重） 14.Spread Operator 展开运算符(…) 15.字符串新增方法 ES6数组面试题 1.forEach() 2.map() 3.filter() 4.reduce() 5.some() 6.every() 7.all()方法 ES6编程题 1.使用解构，实现两个变量的值的交换 2.利用数组推导，计算出数组 [1,2,3,4] 每一个元素的平方并组成新的数组。 3.使用ES6改下面的模板 4.把以下代码使用两种方法，来依次输出0到9？react面试题 react生命周期面试题 1.react 生命周期函数 2.react生命周期中，最适合与服务端进行数据交互的是哪个函数 3.运行阶段生命周期调用顺序 4.shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？） 5.指出(组件)生命周期方法的不同 react 基础面试题 1.React 中 keys 的作用是什么？ 2.React 中 refs 的作用是什么？ 3.React 中有三种构建组件的方式 4.调用 setState 之后发生了什么？ 5.react diff 原理（常考，大厂必考） 6.为什么建议传递给 setState 的参数是一个 callback 而不是一个对象 7.除了在构造函数中绑定 this，还有其它方式吗 8.setState第二个参数的作用 9.(在构造函数中)调用 super(props) 的目的是什么 10.简述 flux 思想 11.在 React 当中 Element 和 Component 有何区别？ 12.描述事件在 React 中的处理方式。 13.createElement 和 cloneElement 有什么区别？ 14.如何告诉 React 它应该编译生产环境版本？ 15.Controlled Component 与 Uncontrolled Component 之间的区别是什么？ react组件面试题 1.展示组件(Presentational component)和容器组件(Container component)之间有何不同 2.类组件(Class component)和函数式组件(Functional component)之间有何不同 3.(组件的)状态(state)和属性(props)之间有何不同 4.何为受控组件(controlled component) 5.何为高阶组件(higher order component) 6.应该在 React 组件的何处发起 Ajax 请求 7.react中组件传值 8.什么时候在功能组件( Class Component )上使用类组件( Functional Component )？ 9.受控组件( controlled component )与不受控制的组件( uncontrolled component )有什么区别？ 10.react 组件的划分业务组件技术组件？ redux面试题 1.redux中间件 2.redux有什么缺点 3.了解 redux 么，说一下 redux 把 react性能比较面试题 1.vue和react的区别 2.react性能优化的方案 3.React 项目用过什么脚手架 4.介绍一下webpack webpack 5.如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？ 6.为什么我们需要使用 React 提供的 Children API 而不是 JavaScript 的 map？ js面试题 1.简述同步和异步的区别 2.怎么添加、移除、复制、创建、和查找节点 3.实现一个函数clone 可以对Javascript中的五种主要数据类型（Number、string、Object、Array、Boolean）进行复制 4.如何消除一个数组里面重复的元素 5.写一个返回闭包的函数 6.使用递归完成1到100的累加 7.Javascript有哪几种数据类型 8.如何判断数据类型 9.console.log(1+’2’)和console.log(1-‘2’)的打印结果 10.Js的事件委托是什么，原理是什么 11.如何改变函数内部的this指针的指向 12.列举几种解决跨域问题的方式，且说明原理 13.谈谈垃圾回收机制的方式及内存管理 14.写一个function ，清除字符串前后的空格 15.js实现继承的方法有哪些 16.判断一个变量是否是数组，有哪些办法 17.let ，const ，var 有什么区别 18.箭头函数与普通函数有什么区别 19.随机取1-10之间的整数 20.new操作符具体干了什么 21.Ajax原理 22.模块化开发怎么做 23.异步加载Js的方式有哪些 24.xml和 json的区别 25.webpack如何实现打包的 26.常见web安全及防护原理 27.用过哪些设计模式 28.为什么要同源限制 29.offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别 30.javascript有哪些方法定义对象 31.说说你对promise的了解 32.谈谈你对AMD、CMD的理解 33.web开发中会话跟踪的方法有哪些 34.介绍js有哪些内置对象？ 35.说几条写JavaScript的基本规范？ 36.javascript创建对象的几种方式？ 37.eval是做什么的？ 38.null，undefined 的区别？ 39.[“1”, “2”, “3”].map(parseInt) 答案是多少？ 40.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 41.js延迟加载的方式有哪些？ 42.defer和async 43.说说严格模式的限制 44.attribute和property的区别是什么？ 45.ECMAScript6 怎么写class么，为什么会出现class这种东西? 46.常见兼容性问题 47.函数防抖节流的原理 48.原始类型有哪几种？null是对象吗？ 49.为什么console.log(0.2+0.1==0.3) //false 50.说一下JS中类型转换的规则？ 51.深拷贝和浅拷贝的区别？如何实现 52.如何判断this？箭头函数的this是什么 53.== 和 ===的区别 54.什么是闭包 55.JavaScript原型，原型链 ? 有什么特点？ 56.typeof()和instanceof()的用法区别 57.什么是变量提升 58.all、apply以及bind函数内部实现是怎么样的 59.为什么会出现setTimeout倒计时误差？如何减少 60.谈谈你对JS执行上下文栈和作用域链的理解 61.new的原理是什么？通过new的方式创建对象和通过字面量创建有什么区别？ 62.prototype 和 proto 区别是什么？ 63.使用ES5实现一个继承？ 64.取数组的最大值（ES5、ES6） 65.ES6新的特性有哪些？ 66.promise 有几种状态, Promise 有什么优缺点 ? 67.Promise构造函数是同步还是异步执行，then呢 ?promise如何实现then处理 ? 68.Promise和setTimeout的区别 ? 69.如何实现 Promise.all ? 70.如何实现 Promise.finally ? 71.如何判断img加载完成 72.如何阻止冒泡？ 73.如何阻止默认事件？ 74.ajax请求时，如何解释json数据 75.json和jsonp的区别? 76.如何用原生js给一个按钮绑定两个onclick事件？ 77.拖拽会用到哪些事件 78.document.write和innerHTML的区别 79.jQuery的事件委托方法bind 、live、delegate、on之间有什么区别？ 80.浏览器是如何渲染页面的？ 81.$(document).ready()方法和window.onload有什么区别？ 82.jquery中.get()提交和post()提交有区别吗？ 83.对前端路由的理解？前后端路由的区别？ 84.手写一个类的继承 85.XMLHttpRequest：XMLHttpRequest.readyState;状态码的意思 正则表达式常见面试题 1.给一个连字符串例如：get-element-by-id转化成驼峰形式。 2.匹配二进制数字 3.非零的十进制数字 (有至少一位数字, 但是不能以0开头) 4.匹配一年中的12个月 5.匹配qq号最长为13为 6.匹配常见的固定电话号码 7.匹配ip地址 8.匹配用尖括号括起来的以a开头的字符串 9.分割数字每三个以一个逗号划分 10.判断字符串是否包含数字 11.判断电话号码 12.判断是否符合指定格式 13.判断是否符合USD格式 14.JS实现千位分隔符 15.获取 url 参数 16.验证邮箱 17.验证身份证号码 18.匹配汉字 19.去除首尾的’/‘ 20.判断日期格式是否符合 ‘2017-05-11’的形式，简单判断，只判断格式 21.判断日期格式是否符合 ‘2017-05-11’的形式，严格判断（比较复杂） 22.IPv4地址正则 23.十六进制颜色正则 24.车牌号正则 25.过滤HTML标签 26.密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符 27.URL正则 28.匹配浮点数 浏览器/html/css面试题1.什么是盒模型2.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？3.简述src和href的区别4.什么是css Hack5.什么叫优雅降级和渐进增强6.px和em的区别7.HTML5 为什么只写8.Http的状态码有哪些9.一次完整的HTTP事务是怎么一个过程10.HTTPS是如何实现加密11.浏览器是如何渲染页面的12.浏览器的内核有哪些？分别有什么代表的浏览器13.页面导入时，使用link和@import有什么区别14.如何优化图像，图像格式的区别15.列举你了解Html5. Css3 新特性16.可以通过哪些方法优化css3 animation渲染17.列举几个前端性能方面的优化18.如何实现同一个浏览器多个标签页之间的通信19.浏览器的存储技术有哪些20.css定位方式21.尽可能多的写出浏览器兼容性问题22.垂直上下居中的方法23.响应式布局原理25.清除浮动的方法26.http协议和tcp协议27.刷新页面，js请求一般会有哪些地方有缓存处理28.如何对网站的文件和资源进行优化29.你对网页标准和W3C重要性的理解30.Http和https的区别31.data-属性的作用32.如何让Chrome浏览器显示小于12px的文字33.哪些操作会引起页面回流（Reflow）34.CSS预处理器的比较less sass35.如何实现页面每次打开时清除本页缓存36.什么是Virtual DOM,为何要用Virtual DOM37.伪元素和伪类的区别38.http的几种请求方法和区别39.前端需要注意哪些SEO40.的title和alt有什么区别41.从浏览器地址栏输入url到显示页面的步骤42.如何进行网站性能优化43.语义化的理解44.HTML5的离线储存怎么使用，工作原理能不能解释一下？45.浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢46.iframe有那些缺点？47.WEB标准以及W3C标准是什么?48.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?49.HTML全局属性(global attribute)有哪些50.Canvas和SVG有什么区别？51.如何在页面上实现一个圆形的可点击区域？52.网页验证码是干嘛的，是为了解决什么安全问题53.请描述一下 cookies，sessionStorage 和 localStorage 的区别？54.CSS选择器有哪些？哪些属性可以继承？55.CSS优先级算法如何计算？56.CSS3有哪些新特性？57.请解释一下CSS3的flexbox（弹性盒布局模型）,以及适用场景？58.用纯CSS创建一个三角形的原理是什么？59.常见的兼容性问题？60.为什么要初始化CSS样式61.absolute的containing block计算方式跟正常流有什么不同？62.CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？63.display:none与visibility：hidden的区别？64.position跟display、overflow、float这些特性相互叠加后会怎么样？65.对BFC规范(块级格式化上下文：block formatting context)的理解？66.为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？67.上下margin重合的问题68.设置元素浮动后，该元素的display值是多少？69.移动端的布局用过媒体查询吗？70.CSS优化、提高性能的方法有哪些？71.浏览器是怎样解析CSS选择器的？72.在网页中的应该使用奇数还是偶数的字体？为什么呢？73.margin和padding分别适合什么场景使用？74.元素竖向的百分比设定是相对于容器的高度吗？75.全屏滚动的原理是什么？用到了CSS的哪些属性？76.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？77.视差滚动效果？78.::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用79.让页面里的字体变清晰，变细用CSS怎么做？80.position:fixed;在android下无效怎么处理？81.如果需要手动写动画，你认为最小时间间隔是多久，为什么？82.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？83.display:inline-block 什么时候会显示间隙？84.有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度85.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？86.style标签写在body后与body前有什么区别？87.CSS属性overflow属性定义溢出元素内容区的内容会如何处理?88.阐述一下CSS Sprites 微信小程序开发（持续更新）初识小程序 1.注册小程序 2.微信开发者工具 3.小程序与普通网页开发的区别 4.小程序尺寸单位rpx 5.样式导入（WeUI for） 6.选择器 7.小程序image高度自适应及裁剪问题 8.微信小程序长按识别二维码 9.给页面加背景色 10.微信小程序获取用户信息 11.代码审核和发布 12.小程序微信认证 13.小程序申请微信支付 14.小程序的目录解构及四种文件类型 15.小程序文件的作用域 16.小程序常用组件 1.view 2.scroll-view 3.swiper组件 4.movable-view 5.cover-view 6.cover-image 小程序基础 17.授权得到用户信息 18.数据绑定 19.列表渲染 20.条件渲染 21.公共模板建立 22.事件及事件绑定 23.引用 24.页面跳转 1.wx.switchTab 2.wx.reLaunch 3.wx.redirectTo 4.wx.navigateTo 5.wx.navigateBack 25.设置tabBar 26.页面生命周期 27.转发分享 小程序高级 28.request请求后台接口 29.http-promise 封装 30.webview 31.获取用户收货地址 32.获取地里位置 33.自定义组件 34.微信小程序支付问题 小程序项目实战 35.微信小程序本地数据缓存 36.下拉刷新和下拉加载 37.列表页向详情页跳转（动态修改title） 38.客服电话 39.星级评分组件 40.小程序插槽的使用slot 41.模糊查询 42.wxs过滤 43.小程序动画 44.列表根据索引值渲染 45.小程序动态修改class 46.小程序常用框架 47.参数传值的方法 48.提高小程序的应用速度 49.微信小程序的优劣势 50.小程序的双向绑定和vue的区别 51.微信小程序给按钮添加动画 52.微信小程序的tab按钮的转换 53.微信小程序引进echarts 54.APP打开小程序流程 55.小程序解析富文本编辑器 小程序常见bug 1.域名必须是HTTPS 2.input组件placeholder字体颜色 3.wx.navigateTo无法跳转到带tabbar的页面 4.tabbar在切换时页面数据无法刷新 5.如何去掉自定义button灰色的圆角边框 6.input textarea是APP的原生组件，z-index层级最高 7.一段文字如何换行 8.设置最外层标签的margin-bottom在IOS下不生效 9.小程序中canvas的图片不支持base64格式 10.回到页面顶部 11.wx.setStorageSync和wx.getStorageSync报错问题 12.如何获取微信群名称？ 13.new Date跨平台兼容性问题 14.wx.getSystemInfoSync获取windowHeight不准确 15.图片本地资源名称，尽量使用小写命名 移动端热点问题 px border问题 2.2X图 3X图适配 3.图片在安卓上，有些设备模糊问题 4.固定定位布局 键盘挡住输入框内容 5.click的300ms延迟问题和点击穿透问题 6.phone及ipad下输入框默认内阴影 7.防止手机中页面放大和缩小 8.flex布局 9.px、em、rem、%、vw、vh、vm这些单位的区别 10.移动端适配- dpr浅析 11.移动端扩展点击区域 12 上下拉动滚动条时卡顿、慢 13 长时间按住页面出现闪退 14.ios和android下触摸元素时出现半透明灰色遮罩 15.active兼容处理 即 伪类：active失效 16.webkit mask兼容处理 17.pc端与移动端字体大小的问题 18.transiton闪屏 19.圆角bug 20.如何解决禁用表单后移动端样式不统一问题 ? [链接](https://juejin.im/post/6845166890386456584)","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E5%95%83%E5%AE%8C%E4%B8%8D%E7%A7%83%E5%A4%B4%E7%AE%97%E6%88%91%E8%BE%93%EF%BC%89/"},{"title":"阿里 P6 能力","text":"作者：阿里巴巴淘系技术链接：https://www.zhihu.com/question/61281984/answer/1306626251来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。关于前端p6/p6+的水平和素质，来自阿里淘系技术部的前端技术专家磐冲，总结了一下之前所有的面试经历，写下自己总结的方法，希望能够给前端的同学，不论是否来面试阿里的职位，有一个参考。——————————————————————————————————————————我们想要的同学 JD 业务背景淘宝内部最大创新项目之一，大团队已有百人规模，大部分项目处于保密阶段，前景远大&gt; &gt; 职位描述1.负责组件库与业务页面开发。2.带领团队完成技术产品实现。3.负责大型多应用架构设计。4.利用前端技术与服务端协同完成团队业务目标。&gt; &gt; 职位要求0.掌握图形学，webgl或熟练使用threejs框架，熟练canvas相关渲染及动画操作的优先。1.熟练掌握JavaScript。2.熟悉常用工程化工具，掌握模块化思想和技术实现方案。3.熟练掌握React前端框架，了解技术底层。同时了解vue以及angular等其他框架者优先。4.熟练掌握react生态常用工具，redux/react-router等。5.熟悉各种Web前端技术，包括HTML/XML/CSS等，有基于Ajax的前端应用开发经验。6.有良好的编码习惯，对前端技术有持续的热情，个性乐观开朗,逻辑性强，善于和各种背景的人合作。7.具有TS/移动设备上前端开发/NodeJS/服务端开发等经验者优先。 翻译一下JD为什么起这个标题呢？因为有很多人看到职位描述，可能就在和自己做的事情一一比对，把关键字都核对上。而很多前端同学看到职位要求第一条里的图形学，可能就开始打退堂鼓了。或者看到几个关键字自己都认识，就觉得没问题，还挺简单的。就这样望而却步真的好吗？为什么职位描述看着简单，面试却这么难呢？你真的读懂这份职位描述了吗？现在，不妨先停一下，就上面的问题，我们来细细品一下。什么叫读懂职位描述呢？从我个人的理解，读懂职位描述，应该是读懂这个职位需要哪些基础能力，以及可能遇到哪些挑战。我们写自己简历的时候，“精通react”和“熟练使用react”，相信大家不会随意去写。同样的，JD里面的：掌握、熟练掌握、了解、熟悉，也不是随意写的，这代表了团队对新同学的能力要求。回想写自己简历的时候，我们会对这个前缀扪心自问一下。因为会担心一旦写了精通，面试官的问题会更难，甚至觉得只有源码倒背如流的人，才能称得上精通。当然也会有同学非常自信，用react做过几个项目，就写上了精通react。这两种都可以称为精通，也都不可以。没有客观标准，又怎么去衡量呢？而标准在哪里呢？所以在这里，我从阿里面试官角度，给出我认为的标准，尽可能的做到客观可量化。那么，基于上面这份职位标准，我来翻译一下职位要求：首先，总览全部的要求，会发现这个职位虽然提到了3d相关的技能，但是大部分却是应用开发相关的能力，所以这个职位并不是想找专业的3d领域同学，而是需要一个工程化能力强，对3d有了解的同学。 0.掌握图形学，webgl或熟练使用threejs框架，熟练canvas相关渲染及动画操作的优先。初级： 学习过图形学相关知识，知道矩阵等数学原理在动画中的作用，知道三维场景需要的最基础的构成，能用threejs搭3d场景，知道webgl和threejs的关系。 知道canvas是干嘛的，聊到旋转能说出canvas的api。 知道css动画，css动画属性知道关键字和用法(换句话说，电话面试会当场出题要求口喷css动画，至少能说对大概，而不是回答百度一下就会用)。 知道js动画，能说出1~2个社区js动画库，知道js动画和css动画优缺点以及适用场景。 知道raf和其他达到60fps的方法。 中级： 如果没有threejs，你也能基于webgl自己封装一个简单的threejs出来。 聊到原理能说出四元数，聊到鼠标操作能提到节流，聊到性能能提到restore，聊到帧说出raf和timeout的区别，以及各自在优化时候的作用。 知道怎样在移动端处理加载问题，渲染性能问题。 知道如何结合native能力优化性能。 知道如何排查性能问题。对chrome动画、3d、传感器调试十分了解。 高级： 搭建过整套资源加载优化方案，能说明白整体方案的各个细节，包括前端、客户端、服务端分别需要实现哪些功能点、依赖哪些基础能力，以及如何配合。 设计并实现过前端动画引擎，能说明白一个复杂互动项目的技术架构，知道需要哪些核心模块，以及这些模块间如何配合。 有自己实现的动画相关技术方案产出，这套技术方案必须是解决明确的业务或技术难点问题的。为了业务快速落地而封装一个库，不算这里的技术方案。如果有类似社区方案，必须能从原理上说明白和竞品的差异，各自优劣，以及技术选型的原因。 1.熟练掌握JavaScript。初级： JavaScript各种概念都得了解，《JavaScript语言精粹》这本书的目录都得有概念，并且这些核心点都能脱口而出是什么。这里列举一些做参考： 知道组合寄生继承，知道class继承。 知道怎么创建类function + class。 知道闭包在实际场景中怎么用，常见的坑。 知道模块是什么，怎么用。 知道event loop是什么，能举例说明event loop怎么影响平时的编码。 掌握基础数据结构，比如堆、栈、树，并了解这些数据结构计算机基础中的作用。 知道ES6数组相关方法，比如forEach，map，reduce。 中级： 知道class继承与组合寄生继承的差别，并能举例说明。 知道event loop原理，知道宏微任务，并且能从个人理解层面说出为什么要区分。知道node和浏览器在实现loop时候的差别。 能将继承、作用域、闭包、模块这些概念融汇贯通，并且结合实际例子说明这几个概念怎样结合在一起。 能脱口而出2种以上设计模式的核心思想，并结合js语言特性举例或口喷基础实现。 掌握一些基础算法核心思想或简单算法问题，比如排序，大数相加。 2.熟悉常用工程化工具，掌握模块化思想和技术实现方案。初级： 知道webpack，rollup以及他们适用的场景。 知道webpack v4和v3的区别。 脱口而出webpack基础配置。 知道webpack打包结果的代码结构和执行流程，知道index.js，runtime.js是干嘛的。 知道amd，cmd，commonjs，es module分别是什么。 知道所有模块化标准定义一个模块怎么写。给出2个文件，能口喷一段代码完成模块打包和执行的核心逻辑。 中级： 知道webpack打包链路，知道plugin生命周期，知道怎么写一个plugin和loader。 知道常见loader做了什么事情，能几句话说明白，比如babel-loader，vue-loader。 能结合性能优化聊webpack配置怎么做，能清楚说明白核心要点有哪些，并说明解决什么问题，需要哪些外部依赖，比如cdn，接入层等。 了解异步模块加载的实现原理，能口喷代码实现核心逻辑。 高级： 能设计出或具体说明白团队研发基础设施。具体包括但不限于： 项目脚手架搭建，及如何以工具形态共享。 团队eslint规范如何设计，及如何统一更新。 工具化打包发布流程，包括本地调试、云构建、线上发布体系、一键部署能力。同时，方案不仅限于前端工程部分，包含相关服务端基础设施，比如cdn服务搭建，接入层缓存方案设计，域名管控等。 客户端缓存及预加载方案。 3.熟练掌握React前端框架，了解技术底层。同时了解vue以及angular等其他框架者优先。初级： 知道react常见优化方案，脱口而出常用生命周期，知道他们是干什么的。 知道react大致实现思路，能对比react和js控制原生dom的差异，能口喷一个简化版的react。 知道diff算法大致实现思路。 对state和props有自己的使用心得，结合受控组件、hoc等特性描述，需要说明各种方案的适用场景。 以上几点react替换为vue或angular同样适用。 中级： 能说明白为什么要实现fiber，以及可能带来的坑。 能说明白为什么要实现hook。 能说明白为什么要用immutable，以及用或者不用的考虑。 知道react不常用的特性，比如context，portal。 能用自己的理解说明白react like框架的本质，能说明白如何让这些框架共存。 高级： 能设计出框架无关的技术架构。包括但不限于： 说明如何解决可能存在的冲突问题，需要结合实际案例。 能说明架构分层逻辑、各层的核心模块，以及核心模块要解决的问题。能结合实际场景例举一些坑或者优雅的处理方案则更佳。 4.熟练掌握react生态常用工具，redux/react-router等。初级： 知道react-router，redux，redux-thunk，react-redux，immutable，antd或同级别社区组件库。 知道vue和angular对应全家桶分别有哪些。 知道浏览器react相关插件有什么，怎么用。 知道react-router v3/v4的差异。 知道antd组件化设计思路。 知道thunk干嘛用的，怎么实现的。 中级： 看过全家桶源码，不要求每行都看，但是知道核心实现原理和底层依赖。能口喷几行关键代码把对应类库实现即达标。 能从数据驱动角度透彻的说明白redux，能够口喷原生js和redux结合要怎么做。 能结合redux，vuex，mobx等数据流谈谈自己对vue和react的异同。 高级： 有基于全家桶构建复杂应用的经验，比如最近很火的微前端和这些类库结合的时候要注意什么，会有什么坑，怎么解决 5.熟悉各种Web前端技术，包括HTML/XML/CSS等，有基于Ajax的前端应用开发经验。初级： HTML方面包括但不限于：语义化标签，history api，storage，ajax2.0等。 CSS方面包括但不限于：文档流，重绘重排，flex，BFC，IFC，before/after，动画，keyframe，画三角，优先级矩阵等。 知道axios或同级别网络请求库，知道axios的核心功能。 能口喷xhr用法，知道网络请求相关技术和技术底层，包括但不限于：content-type，不同type的作用；restful设计理念；cors处理方案，以及浏览器和服务端执行流程；口喷文件上传实现； 知道如何完成登陆模块，包括但不限于：登陆表单如何实现；cookie登录态维护方案；token base登录态方案；session概念； 中级： HTML方面能够结合各个浏览器api描述常用类库的实现。 css方面能够结合各个概念，说明白网上那些hack方案或优化方案的原理。 能说明白接口请求的前后端整体架构和流程，包括：业务代码，浏览器原理，http协议，服务端接入层，rpc服务调用，负载均衡。 知道websocket用法，包括但不限于：鉴权，房间分配，心跳机制，重连方案等。 知道pc端与移动端登录态维护方案，知道token base登录态实现细节，知道服务端session控制实现，关键字：refresh token。 知道oauth2.0轻量与完整实现原理。 知道移动端api请求与socket如何通过native发送，知道如何与native进行数据交互，知道ios与安卓jsbridge实现原理。 高级： 知道移动端webview和基础能力，包括但不限于：iOS端uiwebview与wkwebview差异；webview资源加载优化方案；webview池管理方案；native路由等。 登陆抽象层，能够给出完整的前后端对用户体系的整体技术架构设计，满足多业务形态用户体系统一。考虑跨域名、多组织架构、跨端、用户态开放等场景。 mock方案，能够设计出满足各种场景需要的mock数据方案，同时能说出对前后端分离的理解。考虑mock方案的通用性、场景覆盖度，以及代码或工程侵入程度。 埋点方案，能够说明白前端埋点方案技术底层实现，以及技术选型原理。能够设计出基于埋点的数据采集和分析方案，关键字包括：分桶策略，采样率，时序性，数据仓库，数据清洗等。 6.有良好的编码习惯，对前端技术有持续的热情，个性乐观开朗，逻辑性强，善于和各种背景的人合作。初级： 知道eslint，以及如何与工程配合使用。 了解近3年前端较重要的更新事件。 面试过程中遇到答不出来的问题，能从逻辑分析上给出大致的思考路径。 知道几个热门的国内外前端技术网站，同时能例举几个面试过程中的核心点是从哪里看到的。 高级： 在团队内推行eslint，并给出工程化解决方案。 面试过程思路清晰，面试官给出关键字，能够快速反应出相关的技术要点，但是也要避免滔滔不绝，说一堆无关紧要的东西。举例来说，当时勾股老师面试我的时候，问了我一个左图右文的布局做法，我的回答是：我自己总结过7种方案，其中比较好用的是基于BFC的，float的以及flex的三种。之后把关键css口喷了一下，然后css就面完了。 7.具有TS/移动设备上前端开发/NodeJS/服务端开发等经验者优先。 根据了解的深度分初/中/高级。 知道TS是什么，为什么要用TS，有TS工程化实践经验。 知道移动端前端常见问题，包括但不限于：rem + 1px方案；预加载；jsbridge原理等。 能说出大概的服务端技术，包括但不限于：docker；k8s；rpc原理；中后台架构分层；缓存处理；分布式；响应式编程等。 JD的要求很难吗？首先，感谢你能看到这里，如果你是仔细看的，那么我更加感动了。而且你已经用实际行动，证明了你的学习能力和耐心。上面那么大篇幅的JD翻译，有一个问题，大家应该都有答案了：为什么职位描述看着简单，面试却这么难呢？然而，有些同学可能会嘲讽起来：写了那么多，我认识的有些阿里P6，P7也不是都会啊，大厂都是螺丝钉，也就面试时候问问，实际工作不还是if else，何况我又遇不到这些场景，我怎么可能知道。 在这里，我想严肃的说明的是： 我所认识的淘宝前端，以及我所在团队的P6同学，上面初级都能做到，中级至少覆盖60%，高级覆盖20%；P6+同学，中级覆盖80%以上，高级覆盖50%以上；P7同学高级覆盖80%以上。 我们团队的前端，每一个人都负责多个复杂业务项目(客观数据上：至少对接20+服务端接口，5个以上router配置，涉及多个用户角色的综合业务系统)，以及一些通用能力，比如组件库等。不存在一个人只接一条业务线，只负责维护某几个组件这种螺丝钉式的工作。我不知道大厂都是螺丝钉的言论为什么会被复用到互联网企业，我个人感受是，如果我在阿里的工作是螺丝钉，那么我以前几份工作可能勉强算是螺纹。另外，如果你想要晋升，那么维护好这几个业务系统只是你的本职工作，晋升时请提供一些更高层面的思考和技术产出。 if else也分鲜花和牛粪。有的人写的是[].reduce，而有的人写的是var temp = ‘’; for() { temp += ‘xxx’ }。另外，如果不知道原理，那么类似webpack这种明星级的技术产品，将永远与你无缘。冷静下来想想，webpack难道也只是if else吗？是，又不全是。 聪明的你应该看出来了，上面JD翻译里的初级、中级和高级，对应的就是我认为的，阿里p6/p6+/p7的能力标准，同时也是一张知识图谱。初级的要求更偏实际应用和基础原理，中级的要求是基于原理的拓展和复杂技术架构的应用，高级的要求是对跨栈、跨端，多领域结合产出综合方案的能力。而且，我们对技术的要求，都是能够与实际业务场景结合，或者能对提升工作效率有帮助的。空谈和尬想，或者只是百度来的文章，没有经过内化，那么面试过程中将被瞬间拆穿。有时我会在boss直聘上直接打字面试，有时我也会听到面试过程中，电话那头传来键盘敲击的声音，甚至有时候我会主动让面试的同学去百度一下，或者挂电话思考一下，过15分钟再聊。我敢这么面试，因为我知道，我要的答案你查不出来，我看的是你真正理解的东西。能搜索到的，我不在乎，我也希望你去查，来为你更好的表现综合能力。我相信每个人都是能快速成长的，只是每个人缺少的东西不同。有的人少了些脚踏实地，有的人少了些登高望远的机会，更多的人或许只是没有找到那条正确的路。我希望这篇文章能够帮助到正在前端领域努力的人，也希望这一篇文章就能成为指路明灯之一。但同时我也深知，每个人都是不一样的。一起加油！共勉。——————————————————————————————————本账号主体为阿里巴巴淘系技术，淘系技术部隶属于阿里巴巴新零售技术事业群，旗下包含淘宝技术、天猫技术、农村淘宝技术、闲鱼、躺平等团队和业务，是一支是具有商业和技术双重基因的螺旋体。刚刚入驻知乎，将会给大家带来超多干货分享，立体化输出我们对于技术和商业的思考与见解。详情介绍可以看这里 阿里巴巴淘系技术介绍欢迎收藏点赞关注我们！共同进步~ ：）","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8C%20P6%20%E8%83%BD%E5%8A%9B/"},{"title":"前端生产方式：过去 10 年回顾和未来 10 年展望","text":"在写这篇文章之前，我一直在思考该用什么的方式能讲清楚前端为什么要向智能化方向切换的理由，真的反复思考很久，后来决定还是以我做前端的过去 10 年的所见所闻来做个解答吧，这样让大家也都更有些体感。 起源 这段是我跟前端的结缘，想必很多人也跟我一样，懵懵懂懂地就撞入了前端这个行业。 一脚入坑 我接触前端，那还是 2010 年的时候，在那个时候最火的是 网络三剑客 —— Adobe Dreamweaver、Adobe Flash、Adobe Fireworks。 这三款软件都很热门，第一款可以通过可视化编辑器拖拖拽拽、填填配配就可以搞定一张网页，虽然上手起来概念众多、也挺难用的，但至少是那个时代做网页最牛逼的软件了； 第二款是做 Flash 的，配备一门 ActionScript 的语言，当时网上下载了不少大牛做的很极客的 Flash 网站源码，不过代码读起来很吃力； 第三款是做海报的（因为海报图比较大、比较长，切割起来比较耗费内存，这款软件速度比较快）和 Gif 动画的，但我用的少，大部分时间都用 Photoshop CS4 来搞定。 虽说这三款软件最火，但真正让我入坑前端（那个时候还没有“前端”这个称呼，有的就是“切图仔”）的理由，是因为我想当一位网页设计师。 当时，想当一位网页设计师的理由有二： 软件工程搞 Java、C++、C 真是挺枯燥无聊的，写一段程序，还得编译、部署，等上个两三分钟的，特别无语；而当初接触 Web 页面开发时（当时还是一位外教授课），发现网页这东西很神奇，在一个 Text 文本编辑器里敲上几行代码，改个扩展名，双击页面就展示出来了，这种所见即所得的美的视觉冲击力，当时让我向这个方向上蠢蠢欲动，埋下了祸根😄。 在教育网庆幸地就是可以翻墙看了不少国外的网站，当时最大的感受就是美观、大气、留白充足，而国内的网页哪里是网页，UI 的设计简直龊的不要不要的，没什么美感，全是一堆文字 和 框，外加一堆闪来闪去的 gif（比如那个 “New”）堆砌，尤其是教育网的官网，那丑的简直不要不要的了。再加上当时的 QQ 空间很火，可以 DIY 自己的空间，但还是感觉不大气，所以当时就想着自己做出一款比较高端大气上档次的网页😄。 大学期间，虽然自己学设计做网页这个想法被身边同学嘲笑说这应该是专科同学才去搞的东西，但的确还是坚持下来了。平时自己除了读专业课程和完成课程实践以外，就是在寝室、在图书馆、在选修课、实验室里抱着一堆影楼的 P 图视频宝典和一本影印版的厚厚的设计资料度过的。当时自学了 Photoshop ，也学会了设计中的三原色原理，并应用在班级日常校园种海报设计、照片美化等工作上，如今拿着单反拍个照 P 个图的本领也都那个时候积累下来的。 再然后就是在校园里找了个实验室的项目，跟一伙人做一个外卖网站，自己担任网页的开发部分。老实说那个时候对方都不信任我能搞定网页开发，毕竟我还是初级的小白。所以自己那个时候啃 W3C，在网上边学边做，虽然当时有个不错的 jQuery 的框架，但自己还是纯手工用 HTML4、CSS、Javascript 撸出了级联地域菜单选择器，而且 UI 也是自己设计的，顿时信心感爆棚，所以一发不可收拾的一个项目一个项目地走向了网页开发或者叫切图仔这个行业。 这大概就是我与前端埋下的不解之缘吧，算是一脚踏入了前端这个行业。 两脚入坑 而要说真正接触“前端”这 2 个字的时候，那还是在面试淘宝时面试官向我提起的。虽然当时还是听不懂前端到底是干嘛的，但一听面试官说能跟设计师一起工作，而且未来想做设计师也可以内转，我就没有再半点犹豫，当时一天就搞定了所有面试流程，签下了淘宝前端开发工程师的 Offer ，从此就两脚都踏入了前端这个行业了😂。 回顾：前端发展的黄金10年（浅水区） 当你真正从校园出来，沉浸于工作之后，就会发现时间过得速度远比你在学校里快了不止一倍，每时每刻都觉得时间不够用、业务完全做不完，感觉自己的时间都给了工作，我过去也在反思这个原因到底是什么，后来也渐渐想明白，这种快本身与互联网的发展相辅相成的，从 2G 到 3G，再到 4G，以及接下来的 5G、6G……，正因为互联网大潮的发展，以及我们这些推潮者的存在，我们的时间变快也就变得正常了。我知道很多人不理解，但在这个圈子里的人都会理解或有同样的声音存在。就比如以前端发展的这 10 年为例，你就会深有体会了。 以下就是详细介绍前端发展的这黄金 10年，有兴趣的读者可以细读，没有兴趣的可以通过这点概述绕过：前端在最初，仅仅是为了完成一张网页的开发，到后来，要能在同时完成 5 张、10 张甚至更多张页面的开发，对前端的挑战变大，所以前端作业内容从单纯的网页开发，拆分成模块式开发，拆分到前后端分离，过渡到可视化搭建系统等等，职能范围也从网页开发逐渐过渡到后端开发、全栈开发，领域范围也从网页开发细分到 PC 端开发、移动端开发、游戏/互动开发、Nodejs 开发、架构工程开发等，工程内容也从一段 jQuery 代码就搞定的阶段发展到前端也需要构建、打包、集成、测试、灰度等高度工程体系化的复杂程度。但生产力还以人肉为主，互联网前端行业还是劳动密集型作业方式。 阶段一：刀耕与火种 &amp; 野蛮生长 2010 年的前端，IE6 还盛行，jQuery 是老大，YUI 虽然也不差，但用的人毕竟没有 jQuery 多。有个比较牛逼的工具叫 Firebug，这算是给前端的最大福利。这个时候的前端，在我看来应该还算刀耕火种阶段，虽然有 Dreamweaver 这样的网页可视化编辑工具，但产生的无用代码量真是挺多了，而且对接数据比较麻烦，维护成本也不低，在当时的网络条件下，用它的人可能也不少，但我一直不用它。 阶段二：模块化开发 &amp; 框架升级 2011 年，来到阿里实习之后，发现天猫（当时还叫淘宝商城）的页面的确很高端、大气，而且也的确跟设计师在一起工作（当时还叫 UED），很兴奋。当时的前端规模不大（算上外包，15~20 人左右），YUI 在公司还比较盛行，KISSY 开始展露头角，看到前人大牛写的代码有条有理、的确非常膜拜，所以基本那半年的实习生活里大部分周末都泡在公司里或者加班或者自己学习前人的东西。与此同时，公司内还有一款非常牛逼的产品叫 TMS ，可以通过模块化以及模板化的思想，分分钟就可以搭出一张页面来，简直牛逼的不要不要的，那个时候淘宝商城的双 11（虽然很多人当时还把双 11 当光棍节）活动页面就是用这款大杀器搭建完成的。用模块化搭建的思路来解决页面批量生产的问题，这个思路在当时业界也算领先，而且这个思路一直延续到今天。所以如果阿里有个产品历史博物馆的话，TMS 绝对位列其中。 在 2011 ~ 2014 年之间的历史阶段里，模块化的思路占为主导。当时为了进行 Assets 资源加载器的设计，就制定了模块化的协议规范。当时比较流行的模块化协议就是 AMD（RequireJS）、CMD（Seajs 为代表）、KMD（Kissy 为代表）。在淘宝、天猫，Kissy 应用的很火，YUI 退出历史舞台，所以 KMD 主导天下；在支付宝及外部社区，Seajs 应用的很火，所以 CMD 主导天下，玉伯大大的名气和威望也在前端圈里特别高；而 AMD 在国外比较流行，但渐渐也被后来出现的 CommonJS 规范削弱了气势。 当时的前端借助模块化的思想和各路框架（YUI、jQuery、Kissy、……），来支撑着网页页面的生产，前端 Assets 资源已经不再跟服务端代码捆绑在一起发布了，但 doc 页面还在服务端的 web 容器内，前后端的生产需要联调、需要注意发布顺序。TMS 虽然好用，但还是在营销活动（比如 618、双 11）上优势比较强，数据还是偏向静态化的居多，在如频道、搜索、交易等这种产品态的复杂主链路上还起不到快速生产的作用。不过庆幸的是，那个时候的营销活动并没有那么密集，一年之内活动屈指可数，所以对前端的生产压力还没有那么明显。但痛苦在框架升级上，每年一次的 Kissy 升级，让所有业务的前端痛心疾首。 阶段三：浏览器加持 &amp; 富体验化 伴随着浏览器大战，浏览器内核技术在向前发展（有兴趣的同学可以在网上自助看看浏览器的内核发展史，比如《全面了解浏览器（内核）发展史》），IE 逐渐跟不上 Firefox 、Safari 和 Chrome 的节奏。后起之秀 Chrome 非常关注 JavaScript 的引擎性能，觉得可以再提升 10 倍，所以自研一款高性能 JavaScript 引擎，名叫 V8，以 BSD 许可证开源，Chrome 在浏览器家族内的地位如日中天。给前端配套的 debug 工具链更加完善，通过控制台可以完成代码调试、性能检测、资源检测、网络检测、DOM 结构检测等等诸多工作， Chrome 在前端的眼里简直可以说是一款浏览器走天下，IDE 什么的完全通通不用。 因为 Chrome 的加持，前端的研发效能有所提升，外加 HTML5 + CSS3 诞生和浏览器对它的争先支持， Web 页面的性能体验也逐渐上了一个台阶，在网页上可以做的技术尝试也开始展露，如网页特效/动画、网页游戏。 阶段四：前后端分离 &amp; 工程完善 这个思想的提出当时是一位阿里的前端高 P，这种思想的诞生目的就是为了解决前后端在 Web 容器上的过度耦合，导致前后端的研发效率相互制约，所以将这种耦合转变成对数据的耦合，面向数据编程，将 Web 部分彻底交给前端，这样前后端的研发效率会大有提升。 而这个思想的提出时机恰好是在 NodeJS 和 NPM 生态初步建立的阶段，阿里借助 NodeJS 做前后端的分离尝试，在后端诸多质疑声中，干掉了 PHP、废弃了 Java 的 Web 容器，一路拿下了前端在 Web 容器上的主动权。前端在 NodeJS 生态上，也开始有 express、koa、egg、begg 这样的 Web 应用框架开源，也开始有了借助 NodeJS 完成的工程脚手架套件（如 webpack ），同时也衍生了一个新的工种 NodeJS 开发工程师，基本阿里的所有 Java 中间件生态，在 NodeJS 生态上也有对应的一份了。 前后端分离，让前端主导 Web 容器，带来的直接益处就是前端可以从 Client 和 Server 两端进行一体化的生产工程设计，让前端的页面加载性能达到极致化。当然，前端职能的拓宽，也给前端带来了额外的工作负担，所以如果没有充分人力准备的部门，轻易不会尝试负责 WebServer 端，毕竟运维需要成本。但庆幸的是，随着 docker 容器化技术的发展和云基础设施运维能力的发展，从 IaaS 发展到 PaaS，再到 SaaS，服务端的运维成本大幅度降低，所以前端运维 WebServer 的成本就降低很多。 后话：如今发展到 FaaS 阶段，基本就是 Serverless 化的，运维基本对上透明，上层更加感知不到。 当然，前后端分离并没有对前端的研发效率上有太多的改观，倒是在前端工程体系上更加完善和健全。以前的前端可以被叫页面仔，但这个阶段前端已经不再是了，因为前端的工程体系（如 IDE、研发、构建、打包、集成、测试、灰度、生产服务等等）不比 Java 的差多少。 阶段五：终端碎片化 &amp; 技术洗礼 2013 年，移动端兴起，阿里 All in Mobile，移动端浏览器的发展势弱，赶不上 App 的用户体验，多年在 PC 时代沉淀下的技术产物发现在移动端弱网的环境下难以应对，Mobile First 技术战略之下，很多基建又得从移动端开始重新设计。 比如：kissy 在移动端的 mini 版 kimi，但后来也因为 kissy 在业务前端的口碑形象下滑的厉害，以及社区内有 RN（React Native）和 Vue 的兴起，所以 kissy 的生态也在时代的车轮下渐渐消失。 再比如：上文提到的 TMS 系统，因为它对移动端的不适应，导致它在时代的车轮下渐渐消失，被新的产品替代，支撑住移动端的网页搭建。 随着 3G、4G 的发展和 iOS 和 Android 手机在市场的普及量大增，PC 业务主战场也逐渐过渡到移动端。前端的思维模式由 PC 转向了移动端，并向 App 的用户体验看齐。移动端的 HTML5 协议支持不完善，前端的生产配套不全，Android 的屏幕碎片化，所以那个时候的前端开发移动端页面适配的痛苦要远远超过 PC 时代。 阶段六：数据化驱动 &amp; 框架之争 不过，庆幸地是有 Angular、React、Vue、RN （React Native） 这样的 MVVM 框架出现，让前端接受了数据驱动思想的洗礼之外，还借助 RN 完成了移动端的体验升级，包括后来的 Weex、Flutter。 在这个阶段，前端开始有了终端的底层架构组，开始构思前端页面在移动终端上的加载性能和用户体验表现。前端在移动端的研发上在 Web 和 Weex 容器上来回迁移和犹豫，增加了技术选择的负担，而且相互间无法复用。 所以为了解决多端复用的问题，Weex 又借助生态上的 Vue 框架，打通 webview 和 weex 两端，梦想着一套代码跑天下。但现实中就是打脸的，两种终端容器能力不对齐，相互制约，一套代码写得瞻前顾后。这个时候的前端，被终端技术折磨的苦不堪言。 但好在 Web 在移动端的发展越来越强，同时借助客户端的一些能力加持（如 hybird、cache、prefetch 等），web 页面的体验强到可以与 App 分庭抗礼。所以经历过煎熬的四五年时间，如今 web 的声音已经在移动端占主导地位。对应的移动端框架也确定下来。 同时，2016 年，小程序的概念开始提出到上线，一种轻 App 的开放解决方案开始在国内掀起浪潮，微信、支付宝、百度等一堆互联网大厂（包括如小米、华为等的手机硬件厂商）在这个大潮之下分食。所以一种小程序的新 DSL 诞生在前端眼前，前端要兼顾 web 及各个厂商之间的 小程序 DSL，痛苦又翻倍增加。有痛苦就有人解痛，像 WePY 、 mpvue 、Taro 等小程序框架如雨后春笋，相继出现（《小程序第三方框架对比 ( wepy / mpvue / taro )》）。 除了移动端，在 PC 的 C 端和中后台业务上，分别该用什么样的技术方案呢？要不要用 MVVM 框架呢？用React（包括 Preact）、Vue、Angular 具体哪个框架呢？ 在经历过多方声音的反反复复多年的争吵下，最终总算确定了中后台全部采用 React ，PC 的 C 端采用跟移动端一样的同构方案。虽经历过几年的痛苦折磨期，但框架之争总算平静下来，前端的目光开始关注更上层的东西组件化物料（如 AntD、Fussion、ICE 中后台物料等）的建设以及前端行业领域的细分。 阶段七：领域细分 &amp; 可视化搭建 经历过上述的争鸣和冷静之后，前端的行业领域开始更加细分，领域上层建设和深度建设也更在紧锣密鼓的进行着，除了上面提到的 NodeJS 领域方向以外，还有以下这样的垂直方向。 小前台面向的是消费者端的 Web 与 轻 App 业务场景，在这个场景下，经历过多年营销活动的沉淀，面向运营、商家或 KOL 的页面的可视化搭建系统也非常成熟。所以营销活动基本靠这样的系统支撑。 中后台 面向的是企业 ERP、CRM 、OA 等业务场景，如供应链系统，在这个场景下，借助 AntD、Fusion、ICE 中后台物料，形成可视化的中后台搭建解决方案，为业务的前端、开发或产品角色提供一站式中后台生产解决方案。采用搭建，目的肯定是为了业务生产的提效。 数据可视化 面向的是企业的数据 BI 分析和可视化呈现场景，如 双 11 的阿里和商家的企业级数据实时大屏。在这个场景下，借助 echart、highcharts、 AntV 等数据可视化图表物料，形成一套数据可视化搭建系统，为业务的前端、开发或产品角色提供一站式数据可视化图表生产解决方案。采用搭建，目的肯定也是为了业务生产的提效。 互动内容AR、VR、3D、网游、短视频、直播（WebRTC）等新技术在 web 上的衍生和普及，更多富导购的交互形式层出不穷，所以这个方向就是在面向未来的用户富交互体验做投资建设。 …… 还有更多的垂直领域，在此不再细说。 回看这 10 年，是互联网发展和终端发展最快的 10 年，也是前端发展最快的 10 年，更是前端程序员掉头发、白头发最快的 10 年。因为没有哪个技术领域，可以层出不穷地出现新轮子、可以反复不断的推翻升级升级推翻，但庆幸的是，经历过百家争鸣之后的前端行业在各个领域内的建设深度也愈发地趋渐成熟。与此同时，大家也会发现，这些复杂的建设也都是围绕着能解决业务问题和能提升自身生产效率的角度出发的。 展望：前端发展的未来10年（深水区） 解决业务问题不说，那么前端为什么要关注生产效率问题呢？ 因为这直接与阿里的业务体量相关，阿里每一年的业务体量都是相比去年翻番的（比如出海、下沉、创新业务……），所以如果生产力效率跟不上业务的发展节奏，那么在市场竞争上就不占优势，以 2019 年三四线下沉市场高度竞对的场景为例，如果前端撑不住业务发展的节奏，还是慢慢悠悠地搞生产，那么企业就很难占据市场了。 所以，每个前端身上背负的都是业务体量的成倍增加，如何能快速支撑住业务发展以及如何帮助业务突围和增长（2017 年手机出货量触顶下滑，移动端的自然用户增长红利达到顶峰，可以从《用户流量红利消退的下半场，淘宝如何保持高速增长？》（https://blog.csdn.net/Taobaojishu/article/details/101488512）便可感知到）是我们每时每刻都在思考的问题。 前端已到瓶颈！ 我们知道，即便工程化能力已经成熟，但还是解决不了的问题就是“生产效率”的问题，试想： 假设 1 个中等水平的前端产出一张功能齐全的页面需要 1 周时间，1 个牛逼的前端可能只需 2 天时间；而即便都雇佣牛逼的前端，1 个前端单打独斗一周之内最多也就 4 张页面产出，如果仅是生产 10 张页面，那么雇佣 1~2 个牛逼的前端一周之内就搞定了，但如果是生产 100 张、1000 张页面呢？这个时候雇佣多少前端比较合适呢？高端人才的紧俏和招人成本的控制，都会导致厂内的前端的业务压力倍增。 解铃还须系铃人，所以业内开始不断地涌现 hardcode 向 lowcode 方向转变的提效热潮。不说外界，单以阿里为例，面向中后台、C 端、数据可视化方向的 lowcode 平台就层出不穷，虽说上手复杂度很高（毕竟解决问题的复杂度摆在那里，就像 Photoshop 一样），但也都在趋于成熟。 可这样就高枕无忧了嘛？其实并没有，因为业务的迭代速度太快了，即便有这些平台存在了，依然还是解决不了业务上的燃眉之急、前端效率问题依然是业内的瓶颈。 以我带的团队为例，我们服务的每一条线下的业务量和复杂度都是居高不下（每条线承接的是千万级流量，所以业务复杂度自然会高），除了日常产品迭代，每月至少有 1~2 次的营销活动同时进行，即便用了上述的 lowcode 产品，但还是解不了业务方频繁上诉要人的困局，甚至排期、砍需求这种传统小伎俩如今也对业务方没有药效了。 怎么办？一人难敌四手，更何况是一堆数都数不过来的手了。 前端如何突围？ 要讲清楚这一块，我们换个视角看看。众所周知，市场是有清浊、淘汰机制的，任何一个行业都不是一成不变的，只要有先进的出现，那么就势必会将落伍的清理淘汰掉，而这个过程自变量仅是时间。 就像电商互联网兴起的那一刻，有多少实体从业者会意识到自己的饭碗会跟不上时代？就像移动端来临的那一刻，有多少公司及个人还在沉淫在 PC 的时代产物上，再后知后觉地意识到落后时已经被竞争者甩了好几条街了。 就像当 iOS、Android App 生态刚开始兴起阶段，不断地有客户端的人才在向市场输入，而今当 App 在市场饱和、用户分配在终端上安装的 App 数量有限，以及移动端 Web 和轻 App 技术的飞速发展等客观因素冲击下，客户端的从业者发现保住自己的饭碗越发的困难了。 就像 AI、区块链兴起，有一大批的算法从业者和新技术的创业公司输出到市场，而经过市场竞争的洗涤下，又发现算法人才饱和过剩、创业公司也死了一大片。 所以要看一个行业的未来发展怎样，就看这个行业的人才目前和未来在市场上被密集需要的地方在哪、规则最混浊或混乱的地方在哪。如果说这个行业的规则出奇地清晰、人才的供给又出奇的冷静，那么基本上来说，这个行业在市场的发展已经达到平衡状态，而能打破这种平衡重新建立平衡的也肯定是另外的行业的发展渗入。 所以回归到我们所处的前端行业，如今前端人才被需要的肯定是在互联网公司，尤其是大厂，因为业务发展需要，且被需要的很密集（劳动密集型产业），而且这个行业恰巧也是发展规则相对混乱的。为何混乱呢？一方面是因终端多元化趋势严重，比如智能穿戴设备和 IOT 智能家居、智慧医疗、智能建筑等新兴产业的市场冲击，另一方面是因业务的发展形态、发展规模、发展距离（国内到国外）等因素的影响，都导致着过去的终端的技术规则无法适应到新兴终端领域内，所以规则在变、技术在变、框架在变、从业者的领域也在变。 所以从这个角度看前端的职能领域只会越来越宽，人才的需求量只会越来越大，供给的能力要求只会越来越高。可以说这是市场对前端这个行业利好的信号，但同样也是对前端这个行业压力提醒的信号，如果在这个市场内的前端不能很好的解决市场压力问题，一旦有新兴技术手段形成的新生产力出现，那么前端的这个香饽饽的行业饭碗也就不保了。市场就是这样冷静残酷的，当市场出清淘汰一个行业的时候或许连一声招呼都不会打，没有为什么，这是发展的必须。 如今我们看清形势，再反观我们的生产力手段，可以说还是人肉劳动密集型的，就算招再牛逼的人才进来，如还是以这种的生产手段生产，那么早晚都会被淘汰，不管有多资深，哪怕是专家、研究员。所以前端发展到这个档口下，看似成熟，实则危机四伏。 我们需要反思，更需要一种全景视角的突破和自我革命。与其让别人革我们的命，那么真不如我们自己革自己命。所以接下来前端的发展势必会面临着一个最习以为常却又最为关键的挑战 —— 前端生产效率该如何翻倍的提升？ 历史的经验告诉我们，一个行业的生产供给能力翻倍，那么一定跟这个行业的工艺手段脱不了关系。比如传统制造业制造一款鞋子、织一块布，都是人手工的，当这种供给达到瓶颈之后，就开始出现机械化来辅助人来生产，机械化达到一定程度就是自动化，自动化就可以完全脱离人工进行生产。 同样的道理，前端目前的生产工艺还是人肉的，即便有一定的程度的 lowcode 产品手段来辅助前端释放生产压力，但还是解决不了供不应求的问题，所以没有别的办法，只有一条路就是去人肉，改成完全自动化的生产手段，只有让供给能力远远超越需求的市场增长指数，那么才能彻底解决供不应求的问题。 那么，前端该如何将生产手段提升到自动化阶段呢？ 首先，我们能想到的生产手段上肯定不能重度依赖人，那么剩下的也仅有机器，对于我们而言，肯定就是计算机了。 其次，我们要想的问题是该如何用计算机来解决我们所面临的生产问题，想到第一步不难，而最难的恰巧就是这一步。该怎么解呢（how）？ 调研发现，市面上就 2 种形态的解决思路，一种就是堆人的 hardcode 方式，包括传统的组件化生态，也都停留在这个阶段上；再有一种解法是 lowcode 的方式，或者辅助自己或者辅助其他角色来做生产（换一句话来说就是生产关系转移到其他角色身上），这种方式在特定领域内能一定程度上提效，但一旦领域拓宽或稍有移植，就会面临着不适应，用它工作量反而比 hardcode 增加很多。目前我们就在第 2 阶段，但生产效率问题还是非常突出。所以我选择的解法是 nocode，虽然这个词也不是我新创的，但这个词的涵义足以表达我对生产力供给能力提升下一个阶段的看法。而能帮助前端实现 nocode 解法的技术，一定就是 AI（准确来说是机器学习）。Why？ 互联网的发展就是带来了海量的数据，依靠人脑已经无法去分析清楚一个行业的特征了，至少我们都是凡人大众，那种类似爱因斯坦的天才毕竟还是少见，不可能哪个行业都要等着爱因斯坦出现才能找到解决方案。所以凡人大脑做不到的事情我们就交给计算机来做，如今的 云计算发展和 AI 发展，已经降低了我们应用 AI 来解决我们问题的门槛，所以入行 AI 也是迟早的事，不可能每天都蒙着眼睛装看不到，而且也一定程度上得承认 AI 比我们更聪明，所以逃避不了的事实我们干脆一些接受好了。AI 就是为海量数据和复杂问题而生的。 思维方式转变 那么前端究竟该怎样加持 AI 的能力呢？ 这个问题对纯前端从业者来说很难，对算法从业者来说也很难，但对既懂前端又会算法的从业者来说就不难了。为了讲清楚这个问题，那么我首先来讲解下这两者解题思维的惯性差异是什么，帮助大家先从思想上进行转变，这样大家也就更易接受一些。 我们以一个具体的案例为例：当你的产品经理让你做一款类似下图这样过障的小游戏，管道洞口高度固定，且是匀速向左移动的，小鸟只会上下，同时受重力影响会跳动，你如何让这只小鸟自己会躲避障碍成功过关呢？ demo 地址：https://xviniette.github.io/FlappyLearning/ 如果前端看到上面需求时，他的思维惯式一般是这样的：首先，要有一张画布，上面有小鸟、管道这两种对象（Object），小鸟对象中有 x、y、width、height、alive 等属性，x、y 代表它的水平和垂直位移，width、height 代表小鸟自身宽高，alive 代表小鸟的生死；管道对象中至少有 x、y、width、height、speed 5 个属性，x、y 代表管道的水平和垂直坐标位置，width、height 代表管道的宽高，speed 代表的是管道向左的移动速度。其次，要根据管道的移动速度给小鸟建立一个雷达预警机制，通过轮询的方式不断地探测正前方是否有障碍物，一旦有了就不断地在垂直方向上上下位移来做避障。最后，依次类推的方式达到终点。 如果算法看到上面需求时，他的思维惯式一般这样的：首先，需要找一款模型，拿 network 为例，可以利用遗传算法来解决上面的问题，具体就是通过 50 代小鸟不断地尝试碰撞，将每一代失败的小鸟的基因记录下来，然后遗传给下一代，形成遗传记忆，这样小鸟就不会以失败的方式过障，以此类推，直到没有失败的小鸟出现，那么成功的基因就训练完毕，这样的一代小鸟就可以完全过障了。 大家可以看到，前端的给的解题思路的代码里是有具体交代小鸟应该怎样判断过障的；而看算法解题思路的代码里其实并没有具体教小鸟过障的代码逻辑，有的只是将一些特征和反馈抽取传递给到 network，而真正的过障判断过程是模型去做的。而这就是这两种思路的关键差别，准确说是 程序员 和 AI 算法工程师的思维惯式差别，程序员的脑海里有着“我能用代码定义世界”的思维，而 AI 算法工程师脑海里有着“我该用什么样的数据训练模式让模型自己尽快掌握对错”的思维。前者是一种由自己来解问题的主观视角，所以写的代码纯粹是翻译给计算机要怎么去解这个问题；后者是一种由机器来替我解决问题的客观视角，所以写的代码纯粹是怎样把问题抛给计算机，并告知输入及结果对错，至于计算机是怎么解决这个问题的过程和规律算法工程师都不关心，只关心结果。 看到这里，想必大家对 2 种思维模式有了一个切身的体感，如果还有不太理解的，也可以看 甄子 老师的《前端智能化—思维转变之路》（https://juejin.im/post/5e7d8b87f265da79861b7e0e）文章，这更是对这个思维差异做了更深入的介绍。 重新审视求解 那么既然知道了 2 者的差异，我们就可以将前端领域内遇到的生产效率问题以最新的视角重新进行审视了。前端，里面的关键字是“端”，所谓的“前”就是交代离用户最近的地方。所以用户接触到的终端（包括各种异形屏的、没屏幕的仅有传感器的终端等等）上面所呈现的任何人机交互内容（可视觉传达、听觉传达、肢体传达、甚至可能嗅觉传达等等）都可以认为是前端职责范围内的工作。面对这种形式多样的终端，要想快速产出人机交互的内容，我们用 AI 该怎么做呢？ 鉴于话题有点大，我们还是聚焦在 Web 页面上（其他的以此类推），如何借助 AI 实现高效地生产呢？ 一种思路是，首先，聚焦在网页上能呈现的内容形态看看到底有哪几种（空间轴上的语言），比如文字、图片、视频（视频可以理解为图片的逐帧动画，加上音频）、音频；然后，我们再看下网页上什么样的内容是经常变化的（时间轴上无序状态），什么样的内容是通过交互方式产生变化的（时间轴上的有序状态）。最后，我们的生产策略是，优先考虑将一组时间轴上的训练数据喂给一个模型让它识别出时间轴上的变化内容，然后再借助 CV 或 NLP 模型针对变化的内容进行实体识别（实体识别可能具体到一系列的模型存在，比如细化到商品图识别模型），再然后借助另外的 CV 或 NLP 模型来识别时间轴上不变的内容（往往这部分内容就是页面布局和容器框架），再通过一系列实体识别模型来做页面结构代码上的映射（高维空间向量余弦值相等）。理论上来说，如有大量的训练样本数据，那么模型针对时间轴上的有序状态（即事件响应）也是可以慢慢自己学习出规律出来的。 上面这种思路是纯算法的思路，其中没有借助前端的任何思维模式来影响，但具体效果怎样和实施难度上有多大呢，目前还不好说，至少我们自己也还没开始这种尝试。 也许上面思维未来是对的，但今天来说，前端还没有准备好，还在一步步进行思维上的转变和迭代，这的确是需要一个过程。而且机器学习也不是万能的，它受模型的制约因素很大，而模型往往也是一种算力的象征。我们可以把机器学习比作是一个拥有高复杂度并行密集计算能力（高维空间上的矩阵计算）的统计学计算器，而模型就是这款计算器的内核。也许它能在背后计算出 这样的宇宙规律，但至少也是进行了深度计算的，而这种深度的计算需要的就是海量的样本。而样本就是这款计算器内核塑造成型的灵魂，但这种海量样本的制造工作也绝非是一朝一夕依靠一个软件工程出身的技术人员搞得定的。样本本身就是数据，所以一定要有存量的数据才会有往深度学习方向上发展的可能性。否则人肉制造的样本，要不质量太差（不够客观）、要么就是量的规模不够。当然，也可以先把计算器搭起来，至于样本可以随着时间进行积累，这样的办法也不是不可以，就是等待的时日可能比较长，没法立竿见影收到奇效。 所以，针对商业行为来说，我们至少得有 2 套方案，一套是长远的（如上的方案）的准备，一套是短期眼前的方案。如果做短期的，就借助规则系统 + 机器学习的混合方式来做方案。但不管哪种，样本问题都是要解的。2 套方案也是 2 种选择，也许你还有第 3 种选择，都是选择，所以多与少没有什么差别，只是看能在选择之后投入多少和坚持多久。这种投入就涉及到知识和技能的储备了，所以前端想解决问题，还是得尽快上手机器学习。至于具体怎么上手在此就不做过多介绍了，网上的课程有很多，也可以看西瓜书上手，但关键是动手。可以先从 CV 领域入手，NLP 工程对个人来说单机部署有点难，得借助云（比如谷歌的 TPU 平台）。 长远来看，前端 + AI 的这种前端智能化方向肯定是持续存在的，前端也会因为 AI 能力的加入，会产生诸多不一样的生产力变化。这种变化可能是阶段性的，也可能是终极的，总之生产力会慢慢向计算机身上过渡，前端做的工作是驱动这一切的更深层工作。这个方向没有退路，也绕不过去（专家系统不可能无敌），所以要解的问题直到彻底解决为止。 智能化的10年 最后，我还是带着大家一起展望一下前端智能化的未来 10 年（以如今的互联网发展节奏看，或许下面的 5 年内就达到也是有可能的）： 2~3 年内，前端智能化从业者数量翻倍，AI 在前端领域内或多或少有一些产品形态上的应用，终端开始浮现各种前端机器学习框架，用户产品在智能化体验方面的设计也有对应的倾斜，社区上也开始浮现出各种前端智能化的工程框架、训练框架和 AI 平台； 3~5 年内，前端智能化从业者数量继续增长，传统前端已经被淘汰，前端领域内智能化在特定领域内小有成绩，可以解决特定领域内的一些业务或人力生产效率问题，终端智能体验会趋渐成熟，给用户带来的沉浸式体验增强，线上线下无屏化无差异体验趋近相同，社区上开始开源一些前端的智能化产品； 5~10年内，前端智能化从业市场已趋近饱和，端智能体验设计者应该在市场上比较吃香（如沉浸式人机对抗游戏等），nocode 问题应该能彻底解决，但同时带来其他的消费诉求，可能会引入新的领域难题。 结语 如今危机四伏，未来无限可期，所以大家还是要未雨绸缪，提前做好准备。如今前端智能化是新赛道，如果想直接参加前端智能化第一线的，也可以通过下面这种方式加入我们。团队产品 imgcook —— 由设计稿一键智能生成代码（https://www.imgcook.com/） pipcook —— 前端算法工程框架，前端应用机器学习的最后一公里（https://github.com/alibaba/pipcook） 也欢迎加入我们的社区群， 一群已满，请加二群。 福利来了 重磅下载！《2020 前端工程师必读手册》 阿里巴巴前端委员会推荐！覆盖语言框架、前端智能化、微前端、Serverless及工程化** 5 大热点前端技术方向、10+ 核心实战的前端手册，**解锁前端新方式，挖掘前端新思路，尽在此刻，赶紧来先睹为快！关注 alibabaf2e 微信公众号回复 必读手册 立即获取下载链接。 关注「Alibaba F2E」把握阿里巴巴前端新动向","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/%E5%89%8D%E7%AB%AF%E7%94%9F%E4%BA%A7%E6%96%B9%E5%BC%8F%EF%BC%9A%E8%BF%87%E5%8E%BB%2010%20%E5%B9%B4%E5%9B%9E%E9%A1%BE%E5%92%8C%E6%9C%AA%E6%9D%A5%2010%20%E5%B9%B4%E5%B1%95%E6%9C%9B/"},{"title":"04道 CSS 面试题，助你查漏补缺","text":"CSS 面试知识点总结最近在整理 CSS 的时候发现遇到了很多面试中常见的面试题，本部分主要原作者在 Github 等各大论坛收录的 CSS 相关知识和一些相关面试题时所做的笔记，分享这份总结给大家，对大家对 CSS 的可以来一次全方位的检漏和排查，感谢原作者 CavsZhouyou 的付出，原文链接放在文章最下方，如果出现错误，希望大家共同指出！ 1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？相关知识点： 123456789（1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）（2）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分IE盒模型和W3C标准盒模型的区别：（1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding（2）IE盒模型：属性width，height包含content、border和padding，指的是content+padding+border。在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。 回答： 1234盒模型都是由四个部分组成的，分别是margin、border、padding和content。标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。 详细的资料可以参考：《CSS 盒模型详解》 2.CSS 选择符有哪些？1234567891011（1）id选择器（#myid）（2）类选择器（.myclassname）（3）标签选择器（div,h1,p）（4）后代选择器（h1p）（5）相邻后代选择器（子）选择器（ul&gt;li）（6）兄弟选择器（li~a）（7）相邻兄弟选择器（li+a）（8）属性选择器（a[rel=&quot;external&quot;]）（9）伪类选择器（a:hover,li:nth-child）（10）伪元素选择器（::before、::after）（11）通配符选择器（*） 3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。相关知识点： 1234567单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。如果按堆栈视角，::after生成的内容会在::before生成的内容之上。 回答： 123在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。 4.伪类与伪元素的区别123456789css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是CSS3的一部分，并尝试区分伪类和伪元素。大多数浏览器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的W3C规范并未对此进行特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。 详细资料可以参考：《总结伪类与伪元素》 5.CSS 中哪些属性可以继承？相关资料： 1234567891011121314151617181920212223每个CSS属性定义的概述都指出了这个属性是默认继承的，还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算值。当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应该是在该属性本身的定义中的默认值）。当元素的一个非继承属性（在Mozillacode里有时称之为resetproperty）没有指定值时，则取属性的初始值initialvalue（该值在该属性的概述里被指定）。有继承性的属性：（1）字体系列属性font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust（2）文本系列属性text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color（3）表格布局属性caption-sideborder-collapseempty-cells（4）列表属性list-style-type、list-style-image、list-style-position、list-style（5）光标属性cursor（6）元素可见性visibility（7）还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地指定继承性，可用于任何继承性/非继承性属性。 回答： 12345每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值来作为自己的值。一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。表格的一些布局属性、列表属性如list-style等。还有光标属性cursor、元素可见性visibility。当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。 详细的资料可以参考：《继承属性》《CSS 有哪些属性可以继承？》 6.CSS 优先级算法如何计算？相关知识点： 123456789101112131415161718192021222324CSS的优先级是根据样式声明的特殊性值来判断的。选择器的特殊性值分为四个等级，如下：（1）标签内选择符x,0,0,0（2）ID选择符0,x,0,0（3）class选择符/属性选择符/伪类选择符 0,0,x,0（4）元素和伪元素选择符0,0,0,x计算方法：（1）每个等级的初始值为0（2）每个等级的叠加为选择器出现的次数相加（3）不可进位，比如0,99,99,99（4）依次表示为：0,0,0,0（5）每个等级计数之间没关联（6）等级判断从左向右，如果某一位数值相同，则判断下一位数值（7）如果两个优先级相同，则最后出现的优先级高，!important也适用（8）通配符选择器的特殊性值为：0,0,0,0（9）继承样式优先级最低，通配符样式优先级高于继承样式（10）!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。计算实例：（1）#demoa{color:orange;}/*特殊性值：0,1,0,1*/（2）div#demoa{color:red;}/*特殊性值：0,1,0,2*/注意：（1）样式应用时，css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。（2）特殊性值越大的声明优先级越高。（3）相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的） 回答： 12345678判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引入的顺序，后出现的规则的优先级最高。 对于组合声明的特殊性值计算可以参考：《CSS 优先级计算及应用》《CSS 优先级计算规则》 7.关于伪类 LVHA 的解释?123456789a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；当链接未访问过时：（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明；（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。当链接访问过时，情况基本同上，只不过需要将:link换成:visited。这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。 8.CSS3 新增伪类有那些？123456789101112131415（1）elem:nth-child(n)选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数值，也可以接受函数。（2）elem:nth-last-child(n)作用同上，不过是从后开始查找。（3）elem:last-child选中最后一个子元素。（4）elem:only-child如果elem是父元素下唯一的子元素，则选中之。（5）elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。（6）elem:first-of-type选中父元素下第一个elem类型元素。（7）elem:last-of-type选中父元素下最后一个elem类型元素。（8）elem:only-of-type如果父元素下的子元素只有一个elem类型元素，则选中该元素。（9）elem:empty选中不包含子元素和内容的elem类型元素。（10）elem:target选择当前活动的elem元素。（11）:not(elem)选择非elem元素的每个元素。（12）:enabled 控制表单控件的禁用状态。（13）:disabled 控制表单控件的禁用状态。(14):checked单选框或复选框被选中。 详细的资料可以参考：《CSS3 新特性总结(伪类)》《浅谈 CSS 伪类和伪元素及 CSS3 新增伪类》 9.如何居中 div？-水平居中：给 div 设置一个宽度，然后添加 margin:0auto 属性 1234div { width: 200px; margin: 0auto;} -水平居中，利用 text-align:center 实现 1234567891011.container { background: rgba(0, 0, 0, 0.5); text-align: center; font-size: 0;}.box { display: inline-block; width: 500px; height: 400px; background-color: pink;} -让绝对定位的 div 居中 1234567891011div { position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /*方便看效果*/} -水平垂直居中一 123456789/*确定容器的宽高宽500高300的层设置层的外边距div{*/position:absolute;/*绝对定位*/width:500px;height:300px;top:50%;left:50%;margin:-150px00-250px;/*外边距为自身宽高的一半*/background-color:pink;/*方便看效果*/} -水平垂直居中二 12345678910/*未知容器的宽高，利用`transform`属性*/div { position: absolute; /*相对定位或绝对定位均可*/ width: 500px; height: 300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; /*方便看效果*/} -水平垂直居中三 1234567891011/*利用flex布局实际使用时应考虑兼容性*/.container { display: flex; align-items: center; /*垂直居中*/ justify-content: center; /*水平居中*/}.containerdiv { width: 100px; height: 100px; background-color: pink; /*方便看效果*/} -水平垂直居中四 123456789101112131415161718192021222324252627/*利用text-align:center和vertical-align:middle属性*/.container { position: fixed; top: 0; right: 0; bottom: 0; left: 0; background: rgba(0, 0, 0, 0.5); text-align: center; font-size: 0; white-space: nowrap; overflow: auto;}.container::after { content: &quot;&quot;; display: inline-block; height: 100%; vertical-align: middle;}.box { display: inline-block; width: 500px; height: 400px; background-color: pink; white-space: normal; vertical-align: middle;} 回答： 123456789101112一般常见的几种居中的方法有：对于宽高固定的元素（1）我们可以利用margin:0auto来实现元素的水平居中。（2）利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。（3）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。（4）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。（5）使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。 10.display 有哪些值？说明他们的作用。1234567block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。none 元素不显示，并从文档流中移除。inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。inline-block默认宽度为内容宽度，可以设置宽高，同行显示。list-item 像块类型元素一样显示，并添加样式列表标记。table 此元素会作为块级表格来显示。inherit 规定应该从父元素继承display属性的值。 详细资料可以参考：《CSSdisplay 属性》 11.position 的值 relative 和 absolute 定位原点是？相关知识点： 1234567891011absolute生成绝对定位的元素，相对于值不为static的第一个父元素的paddingbox进行定位，也可以理解为离自己这一级元素最近的一级position设置为absolute或者relative的父元素的paddingbox的左上角为原点的。fixed（老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。relative生成相对定位的元素，相对于其元素本身所在正常位置进行定位。static默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。inherit规定从父元素继承position属性的值。 回答： 1234relative定位的元素，是相对于元素本身的正常位置来进行定位的。absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的paddingbox来进行定位的。这句话我们可以这样来理解，我们首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元素的paddingbox来定位，也就是说在计算定位距离的时候，padding的值也要算进去。 12.CSS3 有哪些新特性？（根据项目回答）12345678910新增各种CSS选择器 （:not(.input)：所有class不是“input”的节点）圆角 （border-radius:8px）多列布局 （multi-columnlayout）阴影和反射 （Shadow\\Reflect）文字特效 （text-shadow）文字渲染 （Text-decoration）线性渐变 （gradient）旋转 （transform）缩放，定位，倾斜，动画，多背景例如：transform:\\scale(0.85,0.90)\\translate(0px,-30px)\\skew(-9deg,0deg)\\Animation: 13.请解释一下 CSS3 的 Flexbox（弹性盒布局模型），以及适用场景？相关知识点： 12345678910111213141516171819202122Flex是FlexibleBox的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。采用Flex布局的元素，称为Flex容器（flexcontainer），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为Flex项目（flexitem），简称&quot;项目&quot;。容器默认存在两根轴：水平的主轴（mainaxis）和垂直的交叉轴（crossaxis），项目默认沿主轴排列。以下6个属性设置在容器上。flex-direction属性决定主轴的方向（即项目的排列方向）。flex-wrap属性定义，如果一条轴线排不下，如何换行。flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为rownowrap。justify-content属性定义了项目在主轴上的对齐方式。align-items属性定义项目在交叉轴上如何对齐。align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。以下6个属性设置在项目上。order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为01auto。align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 回答： 1234567flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。 详细资料可以参考：《Flex 布局教程：语法篇》《Flex 布局教程：实例篇》 14.用纯 CSS 创建一个三角形的原理是什么？123456789101112采用的是相邻边框连接处的均分原理。 将元素的宽高设为0，只设置 border ，把任意三条边隐藏掉（颜色设为 transparent），剩下的就是一个三角形。 #demo { width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparenttransparentredtransparent;} 15.一个满屏品字布局如何设计?1234简单的方式： 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 16.CSS 多列等高如何实现？123456（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度的特性，来实现多列等高。 详细资料可以参考：《前端应该掌握的 CSS 实现多列等高布局》《CSS：多列等高布局》 17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？12345678910111213141516171819202122232425262728293031323334（1）png24位的图片在iE6浏览器上出现背景解决方案：做成PNG8，也可以引用一段脚本处理。（2）浏览器默认的margin和padding不同解决方案：加一个全局的*{margin:0;padding:0;}来统一。（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。#box{float:left;width:10px;margin:00010px;}这种情况之下IE会产生20px的距离解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)（4）渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用&quot;\\9&quot;这一标记，将IE游览器从所有情况中分离出来。接着，再次使用&quot;+&quot;将IE8和IE7、IE6分离开来，这样IE8已经独立识别。.bb{background-color:#f1ee18;/*所有识别*/.background-color:#00deff\\9;/*IE6、7、8识别*/+background-color:#a200ff;/*IE6、7识别*/_background-color:#1e0bd1;/*IE6识别*/}（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性解决方法：统一通过getAttribute()获取自定义属性。（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有pageX、pageY属性，但是没有x、y属性。解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示解决方法：1.可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome更新到27版本之后就不可以用了。2.还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block/inline-block/...；（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了解决方法：改变CSS属性的排列顺序L-V-H-A（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。 http://18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？123456789浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个&lt;li&gt;放在一行，这导致&lt;li&gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。解决办法：（1）为&lt;li&gt;设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。（2）将所有&lt;li&gt;写在同一行。不足：代码不美观。（3）将&lt;ul&gt;内的字符尺寸直接设为0，即font-size:0。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。（4）消除&lt;ul&gt;的字符间隔letter-spacing:-8px，不足：这也设置了&lt;li&gt;内的字符间隔，因此需要将&lt;li&gt;内的字符间隔设为默认letter-spacing:normal。 详细资料可以参考：《li 与 li 之间有看不见的空白间隔是什么原因引起的？》 19.为什么要初始化 CSS 样式？1234567891011121314151617181920-因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。-当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。最简单的初始化方法：*{padding:0;margin:0;}（强烈不建议）淘宝的样式初始化代码：body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend,button,input,textarea,th,td{margin:0;padding:0;}body,button,input,select,textarea{font:12px/1.5tahoma,arial,\\5b8b\\4f53;}h1,h2,h3,h4,h5,h6{font-size:100%;}address,cite,dfn,em,var{font-style:normal;}code,kbd,pre,samp{font-family:couriernew,courier,monospace;}small{font-size:12px;}ul,ol{list-style:none;}a{text-decoration:none;}a:hover{text-decoration:underline;}sup{vertical-align:text-top;}sub{vertical-align:text-bottom;}legend{color:#000;}fieldset,img{border:0;}button,input,select,textarea{font-size:100%;}table{border-collapse:collapse;border-spacing:0;} 20.什么是包含块，对于包含块的理解?123456789101112包含块（containingblock）就是元素用来计算和定位的一个框。（1）根元素（很多场景下可以看成是&lt;html&gt;）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的contentbox边界形成。（3）如果元素position:fixed，则“包含块”是“初始包含块”。（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：如果该祖先元素是纯inline元素，则规则略复杂：•假设给内联元素的前后各生成一个宽度为0的内联盒子（inlinebox），则这两个内联盒子的paddingbox外面的包围盒就是内联元素的“包含块”；•如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥否则，“包含块”由该祖先的paddingbox边界形成。如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。 21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？1234567（1）对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。（2）但例外的是，如果这个元素是table相关的元素，例如table行，tablegroup，table列，tablecolumngroup，它的表现却跟display:none一样，也就是说，它们占用的空间也会释放。在不同浏览器下的区别：在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。 详细资料可以参考：《CSS 里的 visibility 属性有个鲜为人知的属性值：collapse》 22.width:auto 和 width:100%的区别123一般而言width:100%会使元素box的宽度等于父元素的contentbox的宽度。width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。 23.绝对定位元素与非绝对定位元素的百分比计算的区别12绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的paddingbox来计算的。非绝对定位元素的宽高百分比则是相对于父元素的contentbox来计算的。 24.简单介绍使用图片 base64 编码的优点和缺点。1234567891011base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的url属性。使用base64的优点是：（1）减少一个图片的HTTP请求使用base64的缺点是：（1）根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。（2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要差很多。（3）兼容性的问题，ie8以前的浏览器不支持。一般一些网站的小图标可以使用base64图片来引入。 详细资料可以参考：《玩转图片 base64 编码》《前端开发中，使用 base64 图片的弊端是什么？》《小 tip:base64:URL 背景图片与 web 页面性能优化》 25.’display’、’position’和’float’的相互关系？1234567891011（1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。总的来说，可以把它看作是一个类似优先级的机制，&quot;position:absolute&quot;和&quot;position:fixed&quot;优先级最高，有它存在的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是&quot;none&quot;的时候或者它是根元素的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。 详细资料可以参考：《position 跟 display、margincollapse、overflow、float 这些特性相互叠加后会怎么样？》 26.margin 重叠问题的理解。相关知识点： 1234567891011121314151617181920212223242526272829303132333435块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合并”。产生折叠的必备条件：margin必须是邻接的!而根据w3c规范，两个margin是邻接的必须满足以下条件：•必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。•没有线盒，没有空隙，没有padding和border将他们分隔开•都属于垂直方向上相邻的外边距，可以是下面任意一种情况•元素的margin-top与其第一个常规文档流的子元素的margin-top•元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top•height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom•高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottommargin合并的3种场景：（1）相邻兄弟元素margin合并。解决办法：•设置块状格式化上下文元素（BFC）（2）父级和第一个/最后一个子元素的margin合并。解决办法：对于margin-top合并，可以进行如下操作（满足一个条件即可）：•父元素设置为块状格式化上下文元素；•父元素设置border-top值；•父元素设置padding-top值；•父元素和第一个子元素之间添加内联元素进行分隔。对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：•父元素设置为块状格式化上下文元素；•父元素设置border-bottom值；•父元素设置padding-bottom值；•父元素和最后一个子元素之间添加内联元素进行分隔；•父元素设置height、min-height或max-height。（3）空块级元素的margin合并。解决办法：•设置垂直方向的border；•设置垂直方向的padding；•里面添加内联元素（直接Space键空格是没用的）；•设置height或者min-height。 回答： 123456789101112margin重叠指的是在垂直方向上，两个相邻元素的margin发生重叠的情况。一般来说可以分为四种情形：第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC来解决。第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC来解决。第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、padding或者高度来解决这个问题。 27.对 BFC 规范（块级格式化上下文：blockformattingcontext）的理解？相关知识点： 1234567891011块格式化上下文（BlockFormattingContext，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。通俗来讲•BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。•如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。创建BFC（1）根元素或包含根元素的元素（2）浮动元素float＝left|right或inherit（≠none）（3）绝对定位元素position＝absolute或fixed（4）display＝inline-block|flex|inline-flex|table-cell或table-caption（5）overflow＝hidden|auto或scroll(≠visible) 回答： 1234BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。 详细资料可以参考：《深入理解 BFC 和 MarginCollapse》《前端面试题-BFC（块格式化上下文）》 28.IFC 是什么？1234IFC指的是行级格式化上下文，它有这样的一些布局规则：（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。（2）当一行不够的时候会自动切换到下一行。（3）行级上下文的高度由内部最高的内联盒子的高度决定。 详细资料可以参考：《BFC 和 IFC 的理解（布局）》 29.请解释一下为什么需要清除浮动？清除浮动的方式123456789浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。清除浮动的方式（1）使用clear属性清除浮动。参考28。（2）使用BFC块级格式化上下文来清除浮动。参考26。因为BFC元素不会影响外部元素的特点，所以BFC元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违BFC元素的子元素不会影响外部元素的设定。 30.使用 clear 属性清除浮动的原理？12345678910111213141516171819使用clear属性清除浮动，其语法如下：clear:none|left|right|both如果单看字面意思，clear:left应该是“清除左浮动”，clear:right应该是“清除右浮动”的意思，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。官方对clear属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。还需要注意的一点是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。一般使用伪元素的方式清除浮动.clear::after{content:'';display:table;//也可以是'block'，或者是'list-item'clear:both;}clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。 31.zoom:1 的清除浮动原理?123456789清除浮动，触发hasLayout；zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。来龙去脉大概如下：当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。zoom属性是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在CSS3.0规范草案中。目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。 32.移动端的布局用过媒体查询吗？123456假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）。包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。 详细资料可以参考：《CSS3@media 查询》《响应式布局和自适应布局详解》 33.使用 CSS 预处理器吗？喜欢哪个？1SASS（SASS、LESS没有本质区别，只因为团队前端都是用的SASS） 34.CSS 优化、提高性能的方法有哪些？1234567891011121314151617181920212223242526272829303132加载性能：（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top0bottom0;但margin-bottom:bottom;margin-left:left;执行的效率更高。（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。选择器性能：（1）关键选择器（keyselector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。（3）避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。（4）尽量少的去对标签进行选择，而是用class。（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。渲染性能：（1）慎重使用高性能属性：浮动、定位。（2）尽量减少页面重排、重绘。（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。（4）属性值为0时，不加单位。（5）属性值为浮动小数0.**，可以省略小数点之前的0。（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。（7）不使用@import前缀，它会影响css的加载速度。（8）选择器优化嵌套，尽量避免层级过深。（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。webfonts通常体积庞大，而且一些浏览器在下载webfonts时会阻塞页面渲染损伤性能。可维护性、健壮性：（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。（2）样式与内容分离：将css代码定义到外部css中。 详细资料可以参考：《CSS 优化、提高性能的方法有哪些？》《CSS 优化，提高性能的方法》 35.浏览器是怎样解析 CSS 选择器的？1234样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。 详细资料可以参考：《探究 CSS 解析原理》 36.在网页中应该使用奇数还是偶数的字体？为什么呢？1234（1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14×0.5=7px的margin，在另一些地方用14×1.5=21px的标题字号。（2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。（3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。 详细资料可以参考：《谈谈网页中使用奇数字体和偶数字体》《现在网页设计中的为什么少有人用 11px、13px、15px 等奇数的字体？》 37.margin 和 padding 分别适合什么场景使用？1234567891011margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干。padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。何时应当使用margin：•需要在border外侧添加空白时。•空白处不需要背景（色）时。•上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。何时应当时用padding：•需要在border内测添加空白时。•空白处需要背景（色）时。•上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。 38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]12我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放进业务相关的库里面做成对应功能的模块儿。 详细资料可以参考：《CSS 规范-分类方法》 39.简单说一下 css3 的 all 属性。1234567all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始值。inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。 详细资料可以参考：《简单了解 CSS3 的 all 属性》 40.为什么不建议使用统配符初始化 css 样式。12345采用*{pading:0;margin:0;}这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一套初始化样式。出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即可，并不需使用通配符*来初始化。 41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？123（1）内联元素也可以作为“包含块”所在的元素；（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；（3）边界是paddingbox而不是contentbox。 42.对于 hasLayout 的理解？1234hasLayout是IE特有的一个属性。很多的IE下的cssbug都与其息息相关。在IE中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。 详细资料可以参考：《CSS 基础篇–CSS 中 IE 浏览器的 hasLayout，IE 低版本的 bug 根源》《CSS 魔法堂：hasLayout 原来是这样的！》 43.元素竖向的百分比设定是相对于容器的高度吗？12如果是height的话，是相对于包含块的高度。如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。 44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）1234原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，容器及容器内的页面取当前可视区高度，同时容器的父级元素overflow属性值设为hidden，通过更改容器可视区的位置来实现全屏滚动效果。主要是响应鼠标事件，页面通过CSS的动画效果，进行移动。overflow：hidden；transition：all1000msease； 详细资料可以参考：《js 实现网页全屏切换（平滑过渡），鼠标滚动切换》《用 ES6 写全屏滚动插件》 45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）12响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有meta声明的viewport。 详细资料可以参考：《响应式布局原理》《响应式布局的实现方法和原理》 46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）1视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。 详细资料可以参考：《如何实现视差滚动效果的网页？》 47.如何修改 chrome 记住密码后自动填充表单的黄色背景？1234567891011121314chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的input表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：{background-color:rgb(250,255,189)!important;background-image:none!important;color:rgb(0,0,0)!important;}对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是其他属性可使用。使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill{-webkit-box-shadow:000px1000pxwhiteinset;border:1pxsolid#CCC!important;} 详细资料可以参考：《去掉 chrome 记住密码后的默认填充样式》《修改谷歌浏览器 chrome 记住密码后自动填充表单的黄色背景》 48.怎么让 Chrome 支持小于 12px 的文字？123456789在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。解决办法：（1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。（2）还可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/...；（3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。 详细资料可以参考：《谷歌浏览器不支持 CSS 设置小于 12px 的文字怎么办？》 49.让页面里的字体变清晰，变细用 CSS 怎么做？123webkit内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。在MacOS测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设置后无效。 详细资料可以参考：《让字体变的更清晰 CSS 中-webkit-font-smoothing》 50.font-style 属性中 italic 和 oblique 的区别？123italic和oblique这两个关键字都表示“斜体”的意思。它们的区别在于，italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，则退而求其次，解析为oblique，也就是单纯形状倾斜。 51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？123456设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr=1。在iphone4时，苹果推出了retina屏幕，它的dpr为2。屏幕的缩放会改变dpr的值。ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。 详细资料可以参考：《什么是物理像素、虚拟像素、逻辑像素、设备像素，什么又是 PPI,DPI,DPR 和 DIP》《前端工程师需要明白的「像素」》《CSS 像素、物理像素、逻辑像素、设备像素比、PPI、Viewport》《前端开发中像素的概念》 52.layoutviewport、visualviewport 和 idealviewport 的区别？相关知识点： 123456789如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的viewport叫做layoutviewport。layoutviewport的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小，ppk把这个viewport叫做visualviewport。idealviewport是最适合移动设备的viewport，idealviewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为idealviewport的宽度（单位用px），那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。idealviewport的意义在于，无论在何种分辨率的屏幕下，那些针对idealviewport而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。 回答： 1234567891011移动端一共需要理解三个viewport的概念的理解。第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整个页面的布局都会显示错乱。所以移动端浏览器提供了一个layoutviewport布局视口的概念，使用这个视口来对页面进行布局展示，一般layoutviewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。第二个视口指的是视觉视口，visualviewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visualviewport和layoutviewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口中的网页内容。第三个视口是理想视口，由于layoutviewport一般比visualviewport要大，所以想要看到整个页面必须通过拖动和缩放才能实现。所以又提出了idealviewport的概念，idealviewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在不同分辨率下显示的内容大小相同。idealviewport其实就是通过修改layoutviewport的大小，让它等于设备的宽度，这个宽度可以理解为是设备独立像素，因此根据idealviewport设计的页面，在不同分辨率的屏幕下，显示应该相同。 详细资料可以参考：《移动前端开发之 viewport 的深入理解》《说说移动前端中 viewport（视口）》《移动端适配知识你到底知多少》 53.position:fixed;在 android 下无效怎么处理？123456因为移动端浏览器默认的viewport叫做layoutviewport。在移动端显示时，因为layoutviewport的宽度大于移动端屏幕的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layoutviewport来固定位置的，而不是移动端屏幕来固定位置的，所以会出现感觉fixed无效的情况。如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为idealviewport，可以如下设置：&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;/&gt; 54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）1多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms 55.如何让去除 inline-block 元素间间距？1移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing 详细资料可以参考：《去除 inline-block 元素间间距的 N 种方法》 56.overflow:scroll 时不能平滑滚动的问题怎么处理？12以下代码可解决这种卡顿的问题：-webkit-overflow-scrolling:touch;是因为这行代码启用了硬件加速特性，所以滑动很流畅。 详细资料可以参考：《解决页面使用 overflow:scroll 在 iOS 上滑动卡顿的问题》 57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。123（1）外层div使用position：relative；高度要求自适应的div使用position:absolute;top:100px;bottom:0;left:0;right:0;（2）使用flex布局，设置主轴为竖轴，第二个div的flex-grow为1。 详细资料可以参考：《有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度(三种方案)》 58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？相关知识点： 1234567891011121314151617181920212223（1）BMP，是无损的、既支持索引色也支持直接色的、点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常具有较大的文件大小。（2）GIF是无损的、采用索引色的、点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但，GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。（3）JPEG是有损的、采用直接色的、点阵图。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。（4）PNG-8是无损的、使用索引色的、点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。现在，除非需要动画的支持，否则我们没有理由使用GIF而不是PNG-8。（5）PNG-24是无损的、使用直接色的、点阵图。PNG-24的优点在于，它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。（6）SVG是无损的、矢量图。SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企业Logo、Icon等。（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。•在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；•在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；•WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。但是目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。 回答： 12345678910111213141516我了解到的一共有七种常见的图片的格式。（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比较大。（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般适合于用来制作一些网站logo或者图标之类的图片。（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。 详细资料可以参考：《图片格式那么多，哪种更适合你？》 59.浏览器如何判断是否支持 webp 格式图片12345（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格式的图片。（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持。 详细资料可以参考：《判断浏览器是否支持 WebP 图片》《toDataURL()》 60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）1234567网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开，静态资源放CDN。因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的http请求的解析速度。 详细资料可以参考：《CDN 是什么？使用 CDN 有什么优势？》 61.style 标签写在 body 后与 body 前有什么区别？123页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题） 62.什么是 CSS 预处理器/后处理器？12345678910CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。预处理器例如：LESS、Sass、Stylus，用来预编译Sass或lesscsssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。 详细资料可以参考：《CSS 预处理器和后处理器》 63.阐述一下 CSSSprites12345678910将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites能减少图片的字节。优点：减少HTTP请求数，极大地提高页面加载速度增加图片信息重复度，提高压缩比，减少图片大小更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现缺点：图片合并麻烦维护麻烦，修改一个图片可能需要重新布局整个图片，样式 64.使用 rem 布局的优缺点？12345678优点：在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好。缺点：（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。 详细资料可以参考：《css3 的字体大小单位 rem 到底好在哪？》《VW:是时候放弃 REM 布局了》《为什么设计稿是 750px》《使用 Flexible 实现手淘 H5 页面的终端适配》 65.几种常见的 CSS 布局详细的资料可以参考：《几种常见的 CSS 布局》 66.画一条 0.5px 的线123采用metaviewport的方式采用border-image的方式采用transform:scale()的方式 详细资料可以参考：《怎么画一条 0.5px 的边（更新）》 67.transition 和 animation 的区别12transition关注的是CSSproperty的变化，property值和时间的关系是一个三次贝塞尔曲线。animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。 详细资料可以参考：《CSSanimation 与 CSStransition 有何区别？》《CSS3Transition 和 Animation 区别及比较》《CSS 动画简介》《CSS 动画：animation、transition、transform、translate》 68.什么是首选最小宽度？12345“首选最小宽度”，指的是元素最适合的最小宽度。东亚文字（如中文）最小宽度为每个汉字的宽度。西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短横线、问号以及其他非英文字符等。如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。 69.为什么 height:100%会无效？1234对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，所以无法参与计算。使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。 70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？12（1）max-width会覆盖width，即使width是行类样式或者设置了!important。（2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。 71.内联盒模型基本概念1234567（1）内容区域（contentarea）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子（characterbox）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些元素，内容区域可以看成元素自身。（2）内联盒子（inlinebox）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。（3）行框盒子（linebox），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。（4）包含块（containingbox），由一行一行的“行框盒子”组成。 72.什么是幽灵空白节点？123“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。 73.什么是替换元素？12345678910111213通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;iframe&gt;或者表单元素&lt;textarea&gt;和&lt;input&gt;和&lt;select&gt;都是典型的替换元素。替换元素除了内容可替换这一特性以外，还有以下一些特性。（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口，（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如&lt;video&gt;、&lt;iframe&gt;或者&lt;canvas&gt;等，也有少部分替换元素为0像素，如&lt;img&gt;图片，而表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律。（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。（4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。 74.替换元素的计算规则？12345678910111213替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。（1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。（2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括&lt;img&gt;的width和height属性、&lt;input&gt;的size属性、&lt;textarea&gt;的cols和rows属性等。（3）CSS尺寸特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的contentbox。这3层结构的计算规则具体如下（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。 75.content 与替换元素的关系？123456content属性生成的对象称为“匿名替换元素”。（1）我们使用content生成的文本是无法选中、无法复制的，好像设置了userselect:none声明一般，但是普通元素的文本却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。（2）content生成的内容不能左右:empty伪类。（3）content动态生成值无法获取。 76.margin:auto 的填充规则？1234margin的'auto'可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发margin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。（1）如果一侧定值，一侧auto，则auto为剩余空间大小。（2）如果两侧均是auto，则平分剩余空间。 77.margin 无效的情形12345（1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有margin合并的问题。（2）表格中的&lt;tr&gt;和&lt;td&gt;元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。（3）绝对定位元素非定位方位的margin值“无效”。（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。 78.border 的特殊性？123456（1）border-width却不支持百分比。（2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-color没有边框显示的原因。（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。（4）border-color默认颜色就是color色值。（5）默认background背景图片是相对于paddingbox定位的。 79.什么是基线和 x-height？12345字母x的下边缘（线）就是我们的基线。x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在CSS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。 80.line-height 的特殊性？123456789101112131415161718（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。（3）行距=line-height-font-size。（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下边距，则向上取整。（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度实现的。（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-size相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。 81.vertical-align 的特殊性？1234567891011121314（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行内联元素的基线。（2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display计算值是table-cell的元素，我们不妨脑补成&lt;td&gt;元素，则和&lt;tr&gt;元素上边缘对齐。（3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。（4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上偏移。（5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。（6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元素。（7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。 82.overflow 的特殊性？12345（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度高度限制的时候，剪裁的边界是borderbox的内边缘，而非paddingbox的内边缘。（2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素&lt;html&gt;，另一个是文本域&lt;textarea&gt;。（3）滚动条会占用容器的可用宽度或高度。（4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！ 83.无依赖绝对定位是什么？12没有设置left/top/right/bottom属性值的绝对定位称为“无依赖绝对定位”。无依赖绝对定位其定位的位置和没有设置position:absolute时候的位置相关。 84.absolute 与 overflow 的关系？12345（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute元素进行剪裁。（2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也都不会出现滚动条。（3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。 85.clip 裁剪是什么？12所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。 86.relative 的特殊性？123（1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。（3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。 87.什么是层叠上下文？123456789101112层叠上下文，英文称作stackingcontext，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。层叠上下文元素有如下特性：（1）层叠上下文的层叠水平要比普通元素高（原因后面会说明）。（2）层叠上下文可以阻断元素的混合模式。（3）层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。（4）每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。（5）每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。层叠上下文的创建：（1）页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是&lt;html&gt;元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。（2）对于position值为relative/absolute以及Firefox/IE浏览器（不包括Chrome浏览器）下含有position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。Chrome等WebKit内核浏览器下，position:fixed元素天然层叠上下文元素，无须z-index为数值。根据我的测试，目前IE和Firefox仍是老套路。（3）其他一些CSS3属性，比如元素的opacity值不是1。 88.什么是层叠水平？123层叠水平，英文称作stackinglevel，决定了同一个层叠上下文中元素在z轴上的显示顺序。显而易见，所有的元素都有层叠水平，包括层叠上下文元素，也包括普通元素。然而，对普通元素的层叠水平探讨只局限在当前层叠上下文元素中。 89.元素的层叠顺序？层叠顺序，英文称作 stackingorder，表示元素发生层叠时有着特定的垂直显示顺序。 90.层叠准则？12（1）谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。（2）后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。 91.font-weight 的特殊性？1如果使用数值作为font-weight属性值，必须是100～900的整百数。因为这里的数值仅仅是外表长得像数值，实际上是一个具有特定含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。 92.text-indent 的特殊性？123456（1）text-indent仅对第一行内联盒子内容有效。（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inline-table则会生效。（3）&lt;input&gt;标签按钮text-indent值无效。（4）&lt;button&gt;标签按钮text-indent值有效。（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。 93.letter-spacing 与字符间距？12345678letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。letter-spacing具有以下一些特性。（1）继承性。（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。（5）支持小数值，即使0.1px也是支持的。（6）暂不支持百分比值。 94.word-spacing 与单词间距？12letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙宽度。 95.white-space 与换行和空格的控制？123456789white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否生效）等。其属性值包括下面这些。•normal：合并空白字符和换行符。•pre：空白字符不合并，并且内容只在有换行符的地方换行。•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。 96.隐藏元素的 background-image 到底加不加载？相关知识点： 1234567根据测试，一个元素如果display计算值为none，在IE浏览器下（IE8～IE11，更高版本不确定）依然会发送图片请求，Firefox浏览器不会，至于Chrome和Safari浏览器则似乎更加智能一点：如果隐藏元素同时又设置了background-image，则图片依然会去加载；如果是父元素的display计算值为none，则背景图不会请求，此时浏览器或许放心地认为这个背景图暂时是不会使用的。如果不是background-image，而是&lt;img&gt;元素，则设置display:none在所有浏览器下依旧都会请求图片资源。还需要注意的是如果设置的样式没有对应的元素，则background-image也不会加载。hover情况下的background-image，在触发时加载。 回答：-（1）元素的背景图片-元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求-:hover 样式下，触发时请求-（2）img 标签图片任何情况下都会请求图片详细资料可以参考：《CSS 控制前端图片 HTTP 请求的各种情况示例》 97.如何实现单行／多行文本溢出的省略（…）？123456789101112131415161718192021/*单行文本溢出*/p { overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}/*多行文本溢出*/p { position: relative; line-height: 1.5em; /*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/ height: 3em; overflow: hidden;}p:after { content: &quot;...&quot;; position: absolute; bottom: 0; right: 0; background-color: #fff;} 详细资料可以参考：《【CSS/JS】如何实现单行／多行文本溢出的省略》《CSS 多行文本溢出省略显示》 98.常见的元素隐藏方式？-（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。-（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。-（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。-（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。-（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。-（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。-（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。详细资料可以参考：《CSS 隐藏元素的八种方法》 99.css 实现上下固定中间自适应布局？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647利用绝对定位实现body { padding: 0; margin: 0;}.header { position: absolute; top: 0; width: 100%; height: 100px; background: red;}.container { position: absolute; top: 100px; bottom: 100px; width: 100%; background: green;}.footer { position: absolute; bottom: 0; height: 100px; width: 100%; background: red;}利用flex布局实现html,body { height: 100%;}body { display: flex; padding: 0; margin: 0; flex-direction: column;}.header { height: 100px; background: red;}.container { flex-grow: 1; background: green;}.footer { height: 100px; background: red;} 详细资料可以参考：《css 实现上下固定中间自适应布局》 100.css 两栏布局的实现？相关资料： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。*//*以左边宽度固定为200px为例*//*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*/.outer { height: 100px;}.left { float: left; height: 100px; width: 200px; background: tomato;}.right { margin-left: 200px; width: auto; height: 100px; background: gold;}/*（2）第二种是利用flex布局，将左边元素的放大和缩小比例设置为0，基础大小设置为200px。将右边的元素的放大比例设置为1，缩小比例设置为1，基础大小设置为auto。*/.outer { display: flex; height: 100px;}.left { flex-shrink: 0; flex-grow: 0; flex-basis: 200px; background: tomato;}.right { flex: auto; /*11auto*/ background: gold;}/*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。*/.outer { position: relative; height: 100px;}.left { position: absolute; width: 200px; height: 100px; background: tomato;}.right { margin-left: 200px; height: 100px; background: gold;}/*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*/.outer { position: relative; height: 100px;}.left { width: 200px; height: 100px; background: tomato;}.right { position: absolute; top: 0; right: 0; bottom: 0; left: 200px; background: gold;} 《两栏布局 demo 展示》回答：两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。以左边宽度固定为 200px 为例-（1）利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。-（2）第二种是利用 flex 布局，将左边元素的放大和缩小比例设置为 0，基础大小设置为 200px。将右边的元素的放大比例设置为 1，缩小比例设置为 1，基础大小设置为 auto。-（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。-（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。 101.css 三栏布局的实现？相关资料： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/*三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。这里以左边宽度固定为100px，右边宽度固定为200px为例。*//*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*/.outer { position: relative; height: 100px;}.left { position: absolute; width: 100px; height: 100px; background: tomato;}.right { position: absolute; top: 0; right: 0; width: 200px; height: 100px; background: gold;}.center { margin-left: 100px; margin-right: 200px; height: 100px; background: lightgreen;}/*（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto*/.outer { display: flex; height: 100px;}.left { flex: 00100px; background: tomato;}.right { flex: 00200px; background: gold;}.center { flex: auto; background: lightgreen;}/*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*/.outer { height: 100px;}.left { float: left; width: 100px; height: 100px; background: tomato;}.right { float: right; width: 200px; height: 100px; background: gold;}.center { height: 100px; margin-left: 100px; margin-right: 200px; background: lightgreen;}/*（4）双飞翼布局，利用浮动和负边距来实现。父级元素设置左右的pedding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。*/.outer { height: 100px; padding-left: 100px; padding-right: 200px;}.left { position: relative; left: -100px; float: left; margin-left: -100%; width: 100px; height: 100px; background: tomato;}.right { position: relative; left: 200px; float: right; margin-left: -200px; width: 200px; height: 100px; background: gold;}.center { float: left; width: 100%; height: 100px; background: lightgreen;}/*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的pedding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*/.outer { height: 100px;}.left { float: left; margin-left: -100%; width: 100px; height: 100px; background: tomato;}.right { float: left; margin-left: -200px; width: 200px; height: 100px; background: gold;}.wrapper { float: left; width: 100%; height: 100px; background: lightgreen;}.center { margin-left: 100px; margin-right: 200px; height: 100px;} 《三栏布局 demo 展示》回答： 1234567三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。这里以左边宽度固定为100px，右边宽度固定为200px为例。（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto。（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的pedding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。双飞翼布局中间列的宽度不能小于两边任意列的宽度，而双飞翼布局则不存在这个问题。（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的pedding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。 102.实现一个宽高自适应的正方形123456789101112131415161718192021222324/*1.第一种方式是利用vw来实现*/.square { width: 10%; height: 10vw; background: tomato;}/*2.第二种方式是利用元素的margin/padding百分比是相对父元素width的性质来实现*/.square { width: 20%; height: 0; padding-top: 20%; background: orange;}/*3.第三种方式是利用子元素的margin-top的值来实现的*/.square { width: 30%; overflow: hidden; background: yellow;}.square::after { content: &quot;&quot;; display: block; margin-top: 100%;} 《自适应正方形 demo 展示》 103.实现一个三角形12345678/*三角形的实现原理是利用了元素边框连接处的等分原理。*/.triangle { width: 0; height: 0; border-width: 100px; border-style: solid; border-color: tomatotransparenttransparenttransparent;} 《三角形 demo 展示》 104.一个自适应矩形，水平垂直居中，且宽高比为 2:112345678910111213/*实现原理参考自适应正方形和水平居中方式*/.box { position: absolute; top: 0; right: 0; left: 0; bottom: 0; margin: auto; width: 10%; height: 0; padding-top: 20%; background: tomato;} 推荐笔者再次墙裂推荐收藏这篇原文，转载于 CavsZhouyou - 前端面试复习笔记，这个仓库是原作者校招时的前端复习笔记，主要总结一些比较重要的知识点和前端面试问题，希望对大家有所帮助。最后如果文章和笔记能带您一丝帮助或者启发，请不要吝啬你的赞和收藏，你的肯定是我前进的最大动力","link":"/2020/09/30/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/04%E9%81%93%20CSS%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%8A%A9%E4%BD%A0%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}],"tags":[{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"代码风格","slug":"代码风格","link":"/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"}],"categories":[{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"CSS","slug":"前端/CSS","link":"/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"内存管理","slug":"前端/内存管理","link":"/categories/%E5%89%8D%E7%AB%AF/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"React","slug":"前端/React","link":"/categories/%E5%89%8D%E7%AB%AF/React/"},{"name":"Vue","slug":"前端/Vue","link":"/categories/%E5%89%8D%E7%AB%AF/Vue/"},{"name":"HTML","slug":"前端/HTML","link":"/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"所思所想","slug":"前端/所思所想","link":"/categories/%E5%89%8D%E7%AB%AF/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/"},{"name":"面试","slug":"前端/面试","link":"/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"},{"name":"Less","slug":"前端/CSS/Less","link":"/categories/%E5%89%8D%E7%AB%AF/CSS/Less/"},{"name":"ES6","slug":"前端/JavaScript/ES6","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/ES6/"},{"name":"Feature","slug":"前端/JavaScript/Feature","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/Feature/"},{"name":"关注点","slug":"前端/React/关注点","link":"/categories/%E5%89%8D%E7%AB%AF/React/%E5%85%B3%E6%B3%A8%E7%82%B9/"},{"name":"语法","slug":"前端/React/语法","link":"/categories/%E5%89%8D%E7%AB%AF/React/%E8%AF%AD%E6%B3%95/"},{"name":"CLI","slug":"前端/Vue/CLI","link":"/categories/%E5%89%8D%E7%AB%AF/Vue/CLI/"},{"name":"方案沉淀","slug":"前端/方案沉淀","link":"/categories/%E5%89%8D%E7%AB%AF/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/"},{"name":"规范","slug":"前端/规范","link":"/categories/%E5%89%8D%E7%AB%AF/%E8%A7%84%E8%8C%83/"},{"name":"代码风格","slug":"前端/方案沉淀/代码风格","link":"/categories/%E5%89%8D%E7%AB%AF/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"name":"问题踩坑","slug":"前端/方案沉淀/问题踩坑","link":"/categories/%E5%89%8D%E7%AB%AF/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E9%97%AE%E9%A2%98%E8%B8%A9%E5%9D%91/"}]}