<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Zero`s House</title><meta property="og:type" content="blog"><meta property="og:title" content="Zero`s House"><meta property="og:url" content="http://jizhi77.github.io/"><meta property="og:site_name" content="Zero`s House"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://jizhi77.github.io/img/og_image.png"><meta property="article:author" content="Zero"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://jizhi77.github.io"},"headline":"Zero`s House","image":["http://jizhi77.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Zero"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?39c0fa34ad7b1193212d1fd95391d891";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><script>(function(h,o,t,j,a,r){
            h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
            h._hjSettings={hjid:2012812,hjsv:6};
            a=o.getElementsByTagName('head')[0];
            r=o.createElement('script');r.async=1;
            r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
            a.appendChild(r);
        })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Zero`s House" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-28T03:48:42.292Z" title="2020-09-28T03:48:42.292Z">2020-09-28</time>发表</span><span class="level-item"><time dateTime="2020-09-28T03:48:42.292Z" title="2020-09-28T03:48:42.292Z">2020-09-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span> / </span><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/">所思所想</a></span><span class="level-item">8 分钟读完 (大约1170个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/28/%E5%89%8D%E7%AB%AF/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%8F%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%20%5B%E5%8E%9F%E5%88%9B%5D/">业务中台系统的一些想法 [原创]</a></h1><div class="content"><p>正直商家一期的契机，商家中心后台迎来大改版的机会，在经历了整个商家中心的重构之后，给我们中台系统建设的思路带来了哪些问题，又该有哪些思考？</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><p>很多人喜欢讲解决方案，那么什么才是解决方案，电商系统？Sass？Antd？如果站在一个初创期公司的一线前端开发人员的角度来讲，对于内外部中后台系统，可以认为一整套的快速高效、质量可靠的业务满足流程就是一套解决方案。</p>
<h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a><strong>工程化</strong></h2><p>下面是之前在微博上看到的对前端工程化的理解，其实这里更确切的讲是广义上的前端工程。</p>
<p>什么是前端工程？其实就是面向具体的业务形态，抽象的一套标准化研发过程管理方法。通过规范化的研发全生命周期管理，帮助团队高质高效地保障业务生长。<br>一定规模的前端工程化，少不了数据收集、权限管控、流程管控、规范设计、工具整合等；并非所有的团队都需要实现前端工程化，小规模的组织或个人通过工具提效即可满足基本诉求，复杂的工程管理维护的成本是巨高的，不同业务类型的前端工程设计也会存在差异。<br>前端工程的演进，大致为：工具化-&gt;流程化-&gt;工程化-&gt;平台化，足够体量的规模才需要进入平台化，进入平台化，也意味着统一和一致协同，业务的个性化差异太多，抹平不同团队的差异，阻力很大。一个好的思路是“全控代码、扼制发布”。<br>然后再看一个系统演变的一般的节奏是什么样子？</p>
<p>我们现在处于哪个阶段其实很明显，被需求绊住了腿、被业务压完了腰的起步阶段，阶段不同，所以核心目标也会不一样。</p>
<h2 id="中台系统"><a href="#中台系统" class="headerlink" title="中台系统"></a><strong>中台系统</strong></h2><p>对于中台系统，MVVM + UI Library 基本就可以满足90%的业务需求。那么这个阶段我们</p>
<ul>
<li>要不要交互？</li>
<li>要不要视觉？</li>
<li>要不要自研所有的工具？</li>
<li>要不要做规范输出？</li>
<li>要不要做基础平台支撑？</li>
</ul>
<p>我的理解是不需要，起码是大部分都不需要。以新的商家中心作为例子来说，核心是 Vue + AntD(Vue) ，其他的npm包只是零星的功能点暂且不表。一个中台系统要解决的问题包括：</p>
<ol>
<li>菜单、路由、权限（为什么将这三者合并到一起来讲，因为在常规的设计上他们是高耦合的）；</li>
<li>网络请求（错误码要做哪些统一封装？接口模块按照页面级还是后端微服务维度？）</li>
<li>webpack配置（devServer、拆包优化、打包路径、压缩等等的处理，其实Vue和React现在都倾向于脚手架定制，但还是要关心）</li>
<li>Utils（模块划分合理，达成共识，增量添加，不要出现分叉各用各的）</li>
<li>状态管理（做了这么多项目下来，其实真正将状态管理重度使用的场景并不是很多，大多数只是用来做了登录态的保存，这还是结合了本地存储的能力）</li>
<li>公共组件（这是一个存在巨大分歧的地方，像对form表单的封装，做不好最后就会成为项目里最头疼的一块，本身form表单组件设计就复杂，然后你做一层看似提效的抽象，殊不知无形中又加重了开发人员的理解成本）</li>
</ol>
<p>只要合理的解决了上面所提到这些问题，然后具象后落地为一套模板，无论公司启动多少新的项目，新的系统，PRD给过来，合理的工时评估是可期的，而且开发模式共通，相互之间的技术补位也成为可能（当然业务逻辑复杂的场景补位还是会存在问题）。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-28T03:48:42.292Z" title="2020-09-28T03:48:42.292Z">2020-09-28</time>发表</span><span class="level-item"><time dateTime="2020-09-28T03:48:42.292Z" title="2020-09-28T03:48:42.292Z">2020-09-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span> / </span><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/">所思所想</a></span><span class="level-item">1 小时读完 (大约12807个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/28/%E5%89%8D%E7%AB%AF/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/%E5%89%8D%E7%AB%AF%E7%94%9F%E4%BA%A7%E6%96%B9%E5%BC%8F%EF%BC%9A%E8%BF%87%E5%8E%BB%2010%20%E5%B9%B4%E5%9B%9E%E9%A1%BE%E5%92%8C%E6%9C%AA%E6%9D%A5%2010%20%E5%B9%B4%E5%B1%95%E6%9C%9B/">前端生产方式：过去 10 年回顾和未来 10 年展望</a></h1><div class="content"><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/85733/1590065864823-e02ef2c7-db52-46b4-a89a-9408bb8221bd.jpeg#align=left&display=inline&height=93&margin=%5Bobject%20Object%5D&originHeight=682&originWidth=1024&size=0&status=done&style=none&width=140"></p>
<p>在写这篇文章之前，我一直在思考该用什么的方式能讲清楚前端为什么要向智能化方向切换的理由，真的反复思考很久，后来决定还是以我做前端的过去 10 年的所见所闻来做个解答吧，这样让大家也都更有些体感。</p>
<p><strong>起源</strong></p>
<p>这段是我跟前端的结缘，想必很多人也跟我一样，懵懵懂懂地就撞入了前端这个行业。</p>
<p><strong>一脚入坑</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864758-f49bffb0-3c79-4bcf-81fe-d5296fbf44dc.png#align=left&display=inline&height=55&margin=%5Bobject%20Object%5D&originHeight=422&originWidth=1080&size=0&status=done&style=none&width=140"><br>我接触前端，那还是 2010 年的时候，在那个时候最火的是 网络三剑客 —— Adobe Dreamweaver、Adobe Flash、Adobe Fireworks。</p>
<p>这三款软件都很热门，第一款可以通过可视化编辑器拖拖拽拽、填填配配就可以搞定一张网页，虽然上手起来概念众多、也挺难用的，但至少是那个时代做网页最牛逼的软件了；</p>
<p>第二款是做 Flash 的，配备一门 ActionScript 的语言，当时网上下载了不少大牛做的很极客的 Flash 网站源码，不过代码读起来很吃力；</p>
<p>第三款是做海报的（因为海报图比较大、比较长，切割起来比较耗费内存，这款软件速度比较快）和 Gif 动画的，但我用的少，大部分时间都用 Photoshop CS4 来搞定。</p>
<p>虽说这三款软件最火，但真正让我入坑前端（那个时候还没有“前端”这个称呼，有的就是“切图仔”）的理由，是因为我想当一位网页设计师。</p>
<p>当时，想当一位网页设计师的理由有二：</p>
<ol>
<li><p>软件工程搞 Java、C++、C 真是挺枯燥无聊的，写一段程序，还得编译、部署，等上个两三分钟的，特别无语；而当初接触 Web 页面开发时（当时还是一位外教授课），发现网页这东西很神奇，在一个 Text 文本编辑器里敲上几行代码，改个扩展名，双击页面就展示出来了，这种所见即所得的美的视觉冲击力，当时让我向这个方向上蠢蠢欲动，埋下了祸根😄。</p>
</li>
<li><p>在教育网庆幸地就是可以翻墙看了不少国外的网站，当时最大的感受就是美观、大气、留白充足，而国内的网页哪里是网页，UI 的设计简直龊的不要不要的，没什么美感，全是一堆文字 和 框，外加一堆闪来闪去的 gif（比如那个 “New”）堆砌，尤其是教育网的官网，那丑的简直不要不要的了。再加上当时的 QQ 空间很火，可以 DIY 自己的空间，但还是感觉不大气，所以当时就想着自己做出一款比较高端大气上档次的网页😄。</p>
</li>
</ol>
<p>大学期间，虽然自己学设计做网页这个想法被身边同学嘲笑说这应该是专科同学才去搞的东西，但的确还是坚持下来了。平时自己除了读专业课程和完成课程实践以外，就是在寝室、在图书馆、在选修课、实验室里抱着一堆影楼的 P 图视频宝典和一本影印版的厚厚的设计资料度过的。当时自学了 Photoshop ，也学会了设计中的三原色原理，并应用在班级日常校园种海报设计、照片美化等工作上，如今拿着单反拍个照 P 个图的本领也都那个时候积累下来的。</p>
<p>再然后就是在校园里找了个实验室的项目，跟一伙人做一个外卖网站，自己担任网页的开发部分。老实说那个时候对方都不信任我能搞定网页开发，毕竟我还是初级的小白。所以自己那个时候啃 W3C，在网上边学边做，虽然当时有个不错的 jQuery 的框架，但自己还是纯手工用 HTML4、CSS、Javascript 撸出了级联地域菜单选择器，而且 UI 也是自己设计的，顿时信心感爆棚，所以一发不可收拾的一个项目一个项目地走向了网页开发或者叫切图仔这个行业。</p>
<p>这大概就是我与前端埋下的不解之缘吧，算是一脚踏入了前端这个行业。</p>
<p><strong>两脚入坑</strong></p>
<p>而要说真正接触“前端”这 2 个字的时候，那还是在面试淘宝时面试官向我提起的。虽然当时还是听不懂前端到底是干嘛的，但一听面试官说能跟设计师一起工作，而且未来想做设计师也可以内转，我就没有再半点犹豫，当时一天就搞定了所有面试流程，签下了淘宝前端开发工程师的 Offer ，从此就两脚都踏入了前端这个行业了😂。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864836-4f7aeb46-f610-4f35-8751-3032b4e0aa7d.png#align=left&display=inline&height=51&margin=%5Bobject%20Object%5D&originHeight=391&originWidth=1080&size=0&status=done&style=none&width=140"></p>
<p><strong>回顾：前端发展的黄金10年（浅水区）</strong></p>
<p>当你真正从校园出来，沉浸于工作之后，就会发现时间过得速度远比你在学校里快了不止一倍，每时每刻都觉得时间不够用、业务完全做不完，感觉自己的时间都给了工作，我过去也在反思这个原因到底是什么，后来也渐渐想明白，这种快本身与互联网的发展相辅相成的，从 2G 到 3G，再到 4G，以及接下来的 5G、6G……，正因为互联网大潮的发展，以及我们这些推潮者的存在，我们的时间变快也就变得正常了。我知道很多人不理解，但在这个圈子里的人都会理解或有同样的声音存在。就比如以前端发展的这 10 年为例，你就会深有体会了。</p>
<p>以下就是详细介绍前端发展的这黄金 10年，有兴趣的读者可以细读，没有兴趣的可以通过这点概述绕过：前端在最初，仅仅是为了完成一张网页的开发，到后来，要能在同时完成 5 张、10 张甚至更多张页面的开发，对前端的挑战变大，所以前端作业内容从单纯的网页开发，拆分成模块式开发，拆分到前后端分离，过渡到可视化搭建系统等等，职能范围也从网页开发逐渐过渡到后端开发、全栈开发，领域范围也从网页开发细分到 PC 端开发、移动端开发、游戏/互动开发、Nodejs 开发、架构工程开发等，工程内容也从一段 jQuery 代码就搞定的阶段发展到前端也需要构建、打包、集成、测试、灰度等高度工程体系化的复杂程度。但生产力还以人肉为主，互联网前端行业还是劳动密集型作业方式。</p>
<p><strong>阶段一：刀耕与火种 &amp; 野蛮生长</strong></p>
<p>2010 年的前端，IE6 还盛行，jQuery 是老大，YUI 虽然也不差，但用的人毕竟没有 jQuery 多。有个比较牛逼的工具叫 Firebug，这算是给前端的最大福利。这个时候的前端，在我看来应该还算刀耕火种阶段，虽然有 Dreamweaver 这样的网页可视化编辑工具，但产生的无用代码量真是挺多了，而且对接数据比较麻烦，维护成本也不低，在当时的网络条件下，用它的人可能也不少，但我一直不用它。</p>
<p><strong>阶段二：模块化开发 &amp; 框架升级</strong></p>
<p>2011 年，来到阿里实习之后，发现天猫（当时还叫淘宝商城）的页面的确很高端、大气，而且也的确跟设计师在一起工作（当时还叫 UED），很兴奋。当时的前端规模不大（算上外包，15~20 人左右），YUI 在公司还比较盛行，KISSY 开始展露头角，看到前人大牛写的代码有条有理、的确非常膜拜，所以基本那半年的实习生活里大部分周末都泡在公司里或者加班或者自己学习前人的东西。与此同时，公司内还有一款非常牛逼的产品叫 TMS ，可以通过模块化以及模板化的思想，分分钟就可以搭出一张页面来，简直牛逼的不要不要的，那个时候淘宝商城的双 11（虽然很多人当时还把双 11 当光棍节）活动页面就是用这款大杀器搭建完成的。用模块化搭建的思路来解决页面批量生产的问题，这个思路在当时业界也算领先，而且这个思路一直延续到今天。所以如果阿里有个产品历史博物馆的话，TMS 绝对位列其中。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864861-61222dd1-8be3-4981-8ec9-35344c7597e0.png#align=left&display=inline&height=29&margin=%5Bobject%20Object%5D&originHeight=223&originWidth=1080&size=0&status=done&style=none&width=140"></p>
<p>在 2011 ~ 2014 年之间的历史阶段里，模块化的思路占为主导。当时为了进行 Assets 资源加载器的设计，就制定了模块化的协议规范。当时比较流行的模块化协议就是 AMD（RequireJS）、CMD（Seajs 为代表）、KMD（Kissy 为代表）。在淘宝、天猫，Kissy 应用的很火，YUI 退出历史舞台，所以 KMD 主导天下；在支付宝及外部社区，Seajs 应用的很火，所以 CMD 主导天下，玉伯大大的名气和威望也在前端圈里特别高；而 AMD 在国外比较流行，但渐渐也被后来出现的 CommonJS 规范削弱了气势。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864850-52bec221-175c-4279-b922-ef1f680dff44.png#align=left&display=inline&height=36&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=1080&size=0&status=done&style=none&width=140"></p>
<p>当时的前端借助模块化的思想和各路框架（YUI、jQuery、Kissy、……），来支撑着网页页面的生产，前端 Assets 资源已经不再跟服务端代码捆绑在一起发布了，但 doc 页面还在服务端的 web 容器内，前后端的生产需要联调、需要注意发布顺序。TMS 虽然好用，但还是在营销活动（比如 618、双 11）上优势比较强，数据还是偏向静态化的居多，在如频道、搜索、交易等这种产品态的复杂主链路上还起不到快速生产的作用。不过庆幸的是，那个时候的营销活动并没有那么密集，一年之内活动屈指可数，所以对前端的生产压力还没有那么明显。但痛苦在框架升级上，每年一次的 Kissy 升级，让所有业务的前端痛心疾首。</p>
<p><strong>阶段三：浏览器加持 &amp; 富体验化</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065865011-6ac74883-aff7-45b3-854c-e8948c72c5e3.png#align=left&display=inline&height=46&margin=%5Bobject%20Object%5D&originHeight=358&originWidth=1080&size=0&status=done&style=none&width=140"></p>
<p>伴随着浏览器大战，浏览器内核技术在向前发展（有兴趣的同学可以在网上自助看看浏览器的内核发展史，比如《全面了解浏览器（内核）发展史》），IE 逐渐跟不上 Firefox 、Safari 和 Chrome 的节奏。后起之秀 Chrome 非常关注 JavaScript 的引擎性能，觉得可以再提升 10 倍，所以自研一款高性能 JavaScript 引擎，名叫 V8，以 BSD 许可证开源，Chrome 在浏览器家族内的地位如日中天。给前端配套的 debug 工具链更加完善，通过控制台可以完成代码调试、性能检测、资源检测、网络检测、DOM 结构检测等等诸多工作， Chrome 在前端的眼里简直可以说是一款浏览器走天下，IDE 什么的完全通通不用。</p>
<p>因为 Chrome 的加持，前端的研发效能有所提升，外加 HTML5 + CSS3 诞生和浏览器对它的争先支持， Web 页面的性能体验也逐渐上了一个台阶，在网页上可以做的技术尝试也开始展露，如网页特效/动画、网页游戏。</p>
<p><strong>阶段四：前后端分离 &amp; 工程完善</strong></p>
<p>这个思想的提出当时是一位阿里的前端高 P，这种思想的诞生目的就是为了解决前后端在 Web 容器上的过度耦合，导致前后端的研发效率相互制约，所以将这种耦合转变成对数据的耦合，面向数据编程，将 Web 部分彻底交给前端，这样前后端的研发效率会大有提升。</p>
<p>而这个思想的提出时机恰好是在 NodeJS 和 NPM 生态初步建立的阶段，阿里借助 NodeJS 做前后端的分离尝试，在后端诸多质疑声中，干掉了 PHP、废弃了 Java 的 Web 容器，一路拿下了前端在 Web 容器上的主动权。前端在 NodeJS 生态上，也开始有 express、koa、egg、begg 这样的 Web 应用框架开源，也开始有了借助 NodeJS 完成的工程脚手架套件（如 webpack ），同时也衍生了一个新的工种 NodeJS 开发工程师，基本阿里的所有 Java 中间件生态，在 NodeJS 生态上也有对应的一份了。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/gif/85733/1590065864873-ff930821-ac66-4652-acab-5e021150c69a.gif#align=left&display=inline&height=1&margin=%5Bobject%20Object%5D&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br>前后端分离，让前端主导 Web 容器，带来的直接益处就是前端可以从 Client 和 Server 两端进行一体化的生产工程设计，让前端的页面加载性能达到极致化。当然，前端职能的拓宽，也给前端带来了额外的工作负担，所以如果没有充分人力准备的部门，轻易不会尝试负责 WebServer 端，毕竟运维需要成本。但庆幸的是，随着 docker 容器化技术的发展和云基础设施运维能力的发展，从 IaaS 发展到 PaaS，再到 SaaS，服务端的运维成本大幅度降低，所以前端运维 WebServer 的成本就降低很多。</p>
<p>后话：如今发展到 FaaS 阶段，基本就是 Serverless 化的，运维基本对上透明，上层更加感知不到。</p>
<p>当然，前后端分离并没有对前端的研发效率上有太多的改观，倒是在前端工程体系上更加完善和健全。以前的前端可以被叫页面仔，但这个阶段前端已经不再是了，因为前端的工程体系（如 IDE、研发、构建、打包、集成、测试、灰度、生产服务等等）不比 Java 的差多少。</p>
<p><strong>阶段五：终端碎片化 &amp; 技术洗礼</strong></p>
<p>2013 年，移动端兴起，阿里 All in Mobile，移动端浏览器的发展势弱，赶不上 App 的用户体验，多年在 PC 时代沉淀下的技术产物发现在移动端弱网的环境下难以应对，Mobile First 技术战略之下，很多基建又得从移动端开始重新设计。</p>
<p>比如：kissy 在移动端的 mini 版 kimi，但后来也因为 kissy 在业务前端的口碑形象下滑的厉害，以及社区内有 RN（React Native）和 Vue 的兴起，所以 kissy 的生态也在时代的车轮下渐渐消失。</p>
<p>再比如：上文提到的 TMS 系统，因为它对移动端的不适应，导致它在时代的车轮下渐渐消失，被新的产品替代，支撑住移动端的网页搭建。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864835-7e393ede-c67b-4962-ac52-60c520898ec9.png#align=left&display=inline&height=69&margin=%5Bobject%20Object%5D&originHeight=529&originWidth=1080&size=0&status=done&style=none&width=140"><br>随着 3G、4G 的发展和 iOS 和 Android 手机在市场的普及量大增，PC 业务主战场也逐渐过渡到移动端。前端的思维模式由 PC 转向了移动端，并向 App 的用户体验看齐。移动端的 HTML5 协议支持不完善，前端的生产配套不全，Android 的屏幕碎片化，所以那个时候的前端开发移动端页面适配的痛苦要远远超过 PC 时代。</p>
<p><strong>阶段六：数据化驱动 &amp; 框架之争</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/gif/85733/1590065864879-4964ff6c-7937-401f-9df1-5e431b8c59ea.gif#align=left&display=inline&height=1&margin=%5Bobject%20Object%5D&name=image.gif&originHeight=1&originWidth=1&size=70&status=done&style=none&width=1" alt="image.gif"><br>不过，庆幸地是有 Angular、React、Vue、RN （React Native） 这样的 MVVM 框架出现，让前端接受了数据驱动思想的洗礼之外，还借助 RN 完成了移动端的体验升级，包括后来的 Weex、Flutter。</p>
<p>在这个阶段，前端开始有了终端的底层架构组，开始构思前端页面在移动终端上的加载性能和用户体验表现。前端在移动端的研发上在 Web 和 Weex 容器上来回迁移和犹豫，增加了技术选择的负担，而且相互间无法复用。</p>
<p>所以为了解决多端复用的问题，Weex 又借助生态上的 Vue 框架，打通 webview 和 weex 两端，梦想着一套代码跑天下。但现实中就是打脸的，两种终端容器能力不对齐，相互制约，一套代码写得瞻前顾后。这个时候的前端，被终端技术折磨的苦不堪言。</p>
<p>但好在 Web 在移动端的发展越来越强，同时借助客户端的一些能力加持（如 hybird、cache、prefetch 等），web 页面的体验强到可以与 App 分庭抗礼。所以经历过煎熬的四五年时间，如今 web 的声音已经在移动端占主导地位。对应的移动端框架也确定下来。</p>
<p>同时，2016 年，小程序的概念开始提出到上线，一种轻 App 的开放解决方案开始在国内掀起浪潮，微信、支付宝、百度等一堆互联网大厂（包括如小米、华为等的手机硬件厂商）在这个大潮之下分食。所以一种小程序的新 DSL 诞生在前端眼前，前端要兼顾 web 及各个厂商之间的 小程序 DSL，痛苦又翻倍增加。有痛苦就有人解痛，像 WePY 、 mpvue 、Taro 等小程序框架如雨后春笋，相继出现（《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NTA4NTIwNA==&mid=2247483699&idx=1&sn=be677b76e0ee5965aaf0c6ecca4f8c58&scene=21#wechat_redirect">小程序第三方框架对比 ( wepy / mpvue / taro )</a>》）。</p>
<p>除了移动端，在 PC 的 C 端和中后台业务上，分别该用什么样的技术方案呢？要不要用 MVVM 框架呢？用React（包括 Preact）、Vue、Angular 具体哪个框架呢？</p>
<p>在经历过多方声音的反反复复多年的争吵下，最终总算确定了中后台全部采用 React ，PC 的 C 端采用跟移动端一样的同构方案。虽经历过几年的痛苦折磨期，但框架之争总算平静下来，前端的目光开始关注更上层的东西组件化物料（如 AntD、Fussion、ICE 中后台物料等）的建设以及前端行业领域的细分。</p>
<p><strong>阶段七：领域细分 &amp; 可视化搭建</strong></p>
<p>经历过上述的争鸣和冷静之后，前端的行业领域开始更加细分，领域上层建设和深度建设也更在紧锣密鼓的进行着，除了上面提到的 NodeJS 领域方向以外，还有以下这样的垂直方向。</p>
<p><strong>小前台</strong><br>面向的是消费者端的 Web 与 轻 App 业务场景，在这个场景下，经历过多年营销活动的沉淀，面向运营、商家或 KOL 的页面的可视化搭建系统也非常成熟。所以营销活动基本靠这样的系统支撑。</p>
<p><strong>中后台</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864895-b752f211-23b4-41c1-ac84-a0cffe92a270.png#align=left&display=inline&height=17&margin=%5Bobject%20Object%5D&originHeight=129&originWidth=1080&size=0&status=done&style=none&width=140"></p>
<p>面向的是企业 ERP、CRM 、OA 等业务场景，如供应链系统，在这个场景下，借助 AntD、Fusion、ICE 中后台物料，形成可视化的中后台搭建解决方案，为业务的前端、开发或产品角色提供一站式中后台生产解决方案。采用搭建，目的肯定是为了业务生产的提效。</p>
<p><strong>数据可视化</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864835-7ca79bc2-c364-4ff3-9d3e-fe5c2faf9fc8.png#align=left&display=inline&height=15&margin=%5Bobject%20Object%5D&originHeight=114&originWidth=1080&size=0&status=done&style=none&width=140"></p>
<p>面向的是企业的数据 BI 分析和可视化呈现场景，如 双 11 的阿里和商家的企业级数据实时大屏。在这个场景下，借助 echart、highcharts、 AntV 等数据可视化图表物料，形成一套数据可视化搭建系统，为业务的前端、开发或产品角色提供一站式数据可视化图表生产解决方案。采用搭建，目的肯定也是为了业务生产的提效。</p>
<p><strong>互动内容</strong><br>AR、VR、3D、网游、短视频、直播（WebRTC）等新技术在 web 上的衍生和普及，更多富导购的交互形式层出不穷，所以这个方向就是在面向未来的用户富交互体验做投资建设。</p>
<p>……</p>
<p>还有更多的垂直领域，在此不再细说。</p>
<p>回看这 10 年，是互联网发展和终端发展最快的 10 年，也是前端发展最快的 10 年，更是前端程序员掉头发、白头发最快的 10 年。因为没有哪个技术领域，可以层出不穷地出现新轮子、可以反复不断的推翻升级升级推翻，但庆幸的是，经历过百家争鸣之后的前端行业在各个领域内的建设深度也愈发地趋渐成熟。与此同时，大家也会发现，这些复杂的建设也都是围绕着能解决业务问题和能提升自身生产效率的角度出发的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864851-844837f1-7050-4b03-b0c8-74d90f21352c.png#align=left&display=inline&height=79&margin=%5Bobject%20Object%5D&originHeight=607&originWidth=1080&size=0&status=done&style=none&width=140"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><strong>展望：前端发展的未来10年（深水区）</strong></p>
<p>解决业务问题不说，那么前端为什么要关注生产效率问题呢？</p>
<p>因为这直接与阿里的业务体量相关，阿里每一年的业务体量都是相比去年翻番的（比如出海、下沉、创新业务……），所以如果生产力效率跟不上业务的发展节奏，那么在市场竞争上就不占优势，以 2019 年三四线下沉市场高度竞对的场景为例，如果前端撑不住业务发展的节奏，还是慢慢悠悠地搞生产，那么企业就很难占据市场了。</p>
<p>所以，每个前端身上背负的都是业务体量的成倍增加，如何能快速支撑住业务发展以及如何帮助业务突围和增长（2017 年手机出货量触顶下滑，移动端的自然用户增长红利达到顶峰，可以从《用户流量红利消退的下半场，淘宝如何保持高速增长？》（<a target="_blank" rel="noopener" href="https://blog.csdn.net/Taobaojishu/article/details/101488512">https://blog.csdn.net/Taobaojishu/article/details/101488512</a>）便可感知到）是我们每时每刻都在思考的问题。</p>
<p><strong>前端已到瓶颈！</strong></p>
<p>我们知道，即便工程化能力已经成熟，但还是解决不了的问题就是“生产效率”的问题，试想：</p>
<p>假设 1 个中等水平的前端产出一张功能齐全的页面需要 1 周时间，1 个牛逼的前端可能只需 2 天时间；而即便都雇佣牛逼的前端，1 个前端单打独斗一周之内最多也就 4 张页面产出，如果仅是生产 10 张页面，那么雇佣 1~2 个牛逼的前端一周之内就搞定了，但如果是生产 100 张、1000 张页面呢？这个时候雇佣多少前端比较合适呢？高端人才的紧俏和招人成本的控制，都会导致厂内的前端的业务压力倍增。</p>
<p>解铃还须系铃人，所以业内开始不断地涌现 hardcode 向 lowcode 方向转变的提效热潮。不说外界，单以阿里为例，面向中后台、C 端、数据可视化方向的 lowcode 平台就层出不穷，虽说上手复杂度很高（毕竟解决问题的复杂度摆在那里，就像 Photoshop 一样），但也都在趋于成熟。</p>
<p>可这样就高枕无忧了嘛？其实并没有，因为业务的迭代速度太快了，即便有这些平台存在了，依然还是解决不了业务上的燃眉之急、前端效率问题依然是业内的瓶颈。</p>
<p>以我带的团队为例，我们服务的每一条线下的业务量和复杂度都是居高不下（每条线承接的是千万级流量，所以业务复杂度自然会高），除了日常产品迭代，每月至少有 1~2 次的营销活动同时进行，即便用了上述的 lowcode 产品，但还是解不了业务方频繁上诉要人的困局，甚至排期、砍需求这种传统小伎俩如今也对业务方没有药效了。</p>
<p>怎么办？一人难敌四手，更何况是一堆数都数不过来的手了。</p>
<p><strong>前端如何突围？</strong></p>
<p>要讲清楚这一块，我们换个视角看看。众所周知，市场是有清浊、淘汰机制的，任何一个行业都不是一成不变的，只要有先进的出现，那么就势必会将落伍的清理淘汰掉，而这个过程自变量仅是时间。</p>
<p>就像电商互联网兴起的那一刻，有多少实体从业者会意识到自己的饭碗会跟不上时代？就像移动端来临的那一刻，有多少公司及个人还在沉淫在 PC 的时代产物上，再后知后觉地意识到落后时已经被竞争者甩了好几条街了。</p>
<p>就像当 iOS、Android App 生态刚开始兴起阶段，不断地有客户端的人才在向市场输入，而今当 App 在市场饱和、用户分配在终端上安装的 App 数量有限，以及移动端 Web 和轻 App 技术的飞速发展等客观因素冲击下，客户端的从业者发现保住自己的饭碗越发的困难了。</p>
<p>就像 AI、区块链兴起，有一大批的算法从业者和新技术的创业公司输出到市场，而经过市场竞争的洗涤下，又发现算法人才饱和过剩、创业公司也死了一大片。</p>
<p>所以要看一个行业的未来发展怎样，就看这个行业的人才目前和未来在市场上被密集需要的地方在哪、规则最混浊或混乱的地方在哪。如果说这个行业的规则出奇地清晰、人才的供给又出奇的冷静，那么基本上来说，这个行业在市场的发展已经达到平衡状态，而能打破这种平衡重新建立平衡的也肯定是另外的行业的发展渗入。</p>
<p>所以回归到我们所处的前端行业，如今前端人才被需要的肯定是在互联网公司，尤其是大厂，因为业务发展需要，且被需要的很密集（劳动密集型产业），而且这个行业恰巧也是发展规则相对混乱的。为何混乱呢？一方面是因终端多元化趋势严重，比如智能穿戴设备和 IOT 智能家居、智慧医疗、智能建筑等新兴产业的市场冲击，另一方面是因业务的发展形态、发展规模、发展距离（国内到国外）等因素的影响，都导致着过去的终端的技术规则无法适应到新兴终端领域内，所以规则在变、技术在变、框架在变、从业者的领域也在变。</p>
<p>所以从这个角度看前端的职能领域只会越来越宽，人才的需求量只会越来越大，供给的能力要求只会越来越高。可以说这是市场对前端这个行业利好的信号，但同样也是对前端这个行业压力提醒的信号，如果在这个市场内的前端不能很好的解决市场压力问题，一旦有新兴技术手段形成的新生产力出现，那么前端的这个香饽饽的行业饭碗也就不保了。市场就是这样冷静残酷的，当市场出清淘汰一个行业的时候或许连一声招呼都不会打，没有为什么，这是发展的必须。</p>
<p>如今我们看清形势，再反观我们的生产力手段，可以说还是人肉劳动密集型的，就算招再牛逼的人才进来，如还是以这种的生产手段生产，那么早晚都会被淘汰，不管有多资深，哪怕是专家、研究员。所以前端发展到这个档口下，看似成熟，实则危机四伏。</p>
<p>我们需要反思，更需要一种全景视角的突破和自我革命。与其让别人革我们的命，那么真不如我们自己革自己命。所以接下来前端的发展势必会面临着一个最习以为常却又最为关键的挑战 —— 前端生产效率该如何翻倍的提升？</p>
<p>历史的经验告诉我们，一个行业的生产供给能力翻倍，那么一定跟这个行业的工艺手段脱不了关系。比如传统制造业制造一款鞋子、织一块布，都是人手工的，当这种供给达到瓶颈之后，就开始出现机械化来辅助人来生产，机械化达到一定程度就是自动化，自动化就可以完全脱离人工进行生产。</p>
<p>同样的道理，前端目前的生产工艺还是人肉的，即便有一定的程度的 lowcode 产品手段来辅助前端释放生产压力，但还是解决不了供不应求的问题，所以没有别的办法，只有一条路就是去人肉，改成完全自动化的生产手段，只有让供给能力远远超越需求的市场增长指数，那么才能彻底解决供不应求的问题。</p>
<p><strong>那么，前端该如何将生产手段提升到自动化阶段呢？</strong></p>
<p>首先，我们能想到的生产手段上肯定不能重度依赖人，那么剩下的也仅有机器，对于我们而言，肯定就是计算机了。</p>
<p>其次，我们要想的问题是该如何用计算机来解决我们所面临的生产问题，想到第一步不难，而最难的恰巧就是这一步。该怎么解呢（how）？</p>
<p>调研发现，市面上就 2 种形态的解决思路，一种就是堆人的 hardcode 方式，包括传统的组件化生态，也都停留在这个阶段上；再有一种解法是 lowcode 的方式，或者辅助自己或者辅助其他角色来做生产（换一句话来说就是生产关系转移到其他角色身上），这种方式在特定领域内能一定程度上提效，但一旦领域拓宽或稍有移植，就会面临着不适应，用它工作量反而比 hardcode 增加很多。目前我们就在第 2 阶段，但生产效率问题还是非常突出。所以我选择的解法是 nocode，虽然这个词也不是我新创的，但这个词的涵义足以表达我对生产力供给能力提升下一个阶段的看法。而能帮助前端实现 nocode 解法的技术，一定就是 AI（准确来说是机器学习）。Why？</p>
<p>互联网的发展就是带来了海量的数据，依靠人脑已经无法去分析清楚一个行业的特征了，至少我们都是凡人大众，那种类似爱因斯坦的天才毕竟还是少见，不可能哪个行业都要等着爱因斯坦出现才能找到解决方案。所以凡人大脑做不到的事情我们就交给计算机来做，如今的 云计算发展和 AI 发展，已经降低了我们应用 AI 来解决我们问题的门槛，所以入行 AI 也是迟早的事，不可能每天都蒙着眼睛装看不到，而且也一定程度上得承认 AI 比我们更聪明，所以逃避不了的事实我们干脆一些接受好了。AI 就是为海量数据和复杂问题而生的。</p>
<p><strong>思维方式转变</strong></p>
<p><strong>那么前端究竟该怎样加持 AI 的能力呢？</strong></p>
<p>这个问题对纯前端从业者来说很难，对算法从业者来说也很难，但对既懂前端又会算法的从业者来说就不难了。为了讲清楚这个问题，那么我首先来讲解下这两者解题思维的惯性差异是什么，帮助大家先从思想上进行转变，这样大家也就更易接受一些。</p>
<p>我们以一个具体的案例为例：当你的产品经理让你做一款类似下图这样过障的小游戏，管道洞口高度固定，且是匀速向左移动的，小鸟只会上下，同时受重力影响会跳动，你如何让这只小鸟自己会躲避障碍成功过关呢？</p>
<p>demo 地址：<a target="_blank" rel="noopener" href="https://xviniette.github.io/FlappyLearning/">https://xviniette.github.io/FlappyLearning/</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864844-02b15b76-0c67-49f2-91e2-b8f7d2b3c5c1.png#align=left&display=inline&height=142&margin=%5Bobject%20Object%5D&originHeight=511&originWidth=503&size=0&status=done&style=none&width=140"><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864861-0bbf655b-d2d3-4321-a2a2-1ce5813155ce.png#align=left&display=inline&height=143&margin=%5Bobject%20Object%5D&originHeight=512&originWidth=500&size=0&status=done&style=none&width=140"></p>
<p>如果前端看到上面需求时，他的思维惯式一般是这样的：首先，要有一张画布，上面有小鸟、管道这两种对象（Object），小鸟对象中有 x、y、width、height、alive 等属性，x、y 代表它的水平和垂直位移，width、height 代表小鸟自身宽高，alive 代表小鸟的生死；管道对象中至少有 x、y、width、height、speed 5 个属性，x、y 代表管道的水平和垂直坐标位置，width、height 代表管道的宽高，speed 代表的是管道向左的移动速度。其次，要根据管道的移动速度给小鸟建立一个雷达预警机制，通过轮询的方式不断地探测正前方是否有障碍物，一旦有了就不断地在垂直方向上上下位移来做避障。最后，依次类推的方式达到终点。</p>
<p>如果算法看到上面需求时，他的思维惯式一般这样的：首先，需要找一款模型，拿 network 为例，可以利用遗传算法来解决上面的问题，具体就是通过 50 代小鸟不断地尝试碰撞，将每一代失败的小鸟的基因记录下来，然后遗传给下一代，形成遗传记忆，这样小鸟就不会以失败的方式过障，以此类推，直到没有失败的小鸟出现，那么成功的基因就训练完毕，这样的一代小鸟就可以完全过障了。</p>
<p>大家可以看到，前端的给的解题思路的代码里是有具体交代小鸟应该怎样判断过障的；而看算法解题思路的代码里其实并没有具体教小鸟过障的代码逻辑，有的只是将一些特征和反馈抽取传递给到 network，而真正的过障判断过程是模型去做的。而这就是这两种思路的关键差别，准确说是 程序员 和 AI 算法工程师的思维惯式差别，程序员的脑海里有着“我能用代码定义世界”的思维，而 AI 算法工程师脑海里有着“我该用什么样的数据训练模式让模型自己尽快掌握对错”的思维。前者是一种由自己来解问题的主观视角，所以写的代码纯粹是翻译给计算机要怎么去解这个问题；后者是一种由机器来替我解决问题的客观视角，所以写的代码纯粹是怎样把问题抛给计算机，并告知输入及结果对错，至于计算机是怎么解决这个问题的过程和规律算法工程师都不关心，只关心结果。</p>
<p>看到这里，想必大家对 2 种思维模式有了一个切身的体感，如果还有不太理解的，也可以看 甄子 老师的《前端智能化—思维转变之路》（<a target="_blank" rel="noopener" href="https://juejin.im/post/5e7d8b87f265da79861b7e0e">https://juejin.im/post/5e7d8b87f265da79861b7e0e</a>）文章，这更是对这个思维差异做了更深入的介绍。</p>
<p><strong>重新审视求解</strong></p>
<p>那么既然知道了 2 者的差异，我们就可以将前端领域内遇到的生产效率问题以最新的视角重新进行审视了。<br>前端，里面的关键字是“端”，所谓的“前”就是交代离用户最近的地方。所以用户接触到的终端（包括各种异形屏的、没屏幕的仅有传感器的终端等等）上面所呈现的任何人机交互内容（可视觉传达、听觉传达、肢体传达、甚至可能嗅觉传达等等）都可以认为是前端职责范围内的工作。面对这种形式多样的终端，要想快速产出人机交互的内容，我们用 AI 该怎么做呢？</p>
<p>鉴于话题有点大，我们还是聚焦在 Web 页面上（其他的以此类推），如何借助 AI 实现高效地生产呢？</p>
<p>一种思路是，首先，聚焦在网页上能呈现的内容形态看看到底有哪几种（空间轴上的语言），比如文字、图片、视频（视频可以理解为图片的逐帧动画，加上音频）、音频；然后，我们再看下网页上什么样的内容是经常变化的（时间轴上无序状态），什么样的内容是通过交互方式产生变化的（时间轴上的有序状态）。最后，我们的生产策略是，优先考虑将一组时间轴上的训练数据喂给一个模型让它识别出时间轴上的变化内容，然后再借助 CV 或 NLP 模型针对变化的内容进行实体识别（实体识别可能具体到一系列的模型存在，比如细化到商品图识别模型），再然后借助另外的 CV 或 NLP 模型来识别时间轴上不变的内容（往往这部分内容就是页面布局和容器框架），再通过一系列实体识别模型来做页面结构代码上的映射（高维空间向量余弦值相等）。理论上来说，如有大量的训练样本数据，那么模型针对时间轴上的有序状态（即事件响应）也是可以慢慢自己学习出规律出来的。</p>
<p>上面这种思路是纯算法的思路，其中没有借助前端的任何思维模式来影响，但具体效果怎样和实施难度上有多大呢，目前还不好说，至少我们自己也还没开始这种尝试。</p>
<p>也许上面思维未来是对的，但今天来说，前端还没有准备好，还在一步步进行思维上的转变和迭代，这的确是需要一个过程。而且机器学习也不是万能的，它受模型的制约因素很大，而模型往往也是一种算力的象征。我们可以把机器学习比作是一个拥有高复杂度并行密集计算能力（高维空间上的矩阵计算）的统计学计算器，而模型就是这款计算器的内核。也许它能在背后计算出 <img src="https://cdn.nlark.com/yuque/0/2020/svg/85733/1590065864838-829cb45a-b33b-4b04-8b29-95c413f7a469.svg#align=left&display=inline&height=37&margin=%5Bobject%20Object%5D&originHeight=36&originWidth=138&size=0&status=done&style=none&width=140">这样的宇宙规律，但至少也是进行了深度计算的，而这种深度的计算需要的就是海量的样本。而样本就是这款计算器内核塑造成型的灵魂，但这种海量样本的制造工作也绝非是一朝一夕依靠一个软件工程出身的技术人员搞得定的。样本本身就是数据，所以一定要有存量的数据才会有往深度学习方向上发展的可能性。否则人肉制造的样本，要不质量太差（不够客观）、要么就是量的规模不够。当然，也可以先把计算器搭起来，至于样本可以随着时间进行积累，这样的办法也不是不可以，就是等待的时日可能比较长，没法立竿见影收到奇效。</p>
<p>所以，针对商业行为来说，我们至少得有 2 套方案，一套是长远的（如上的方案）的准备，一套是短期眼前的方案。如果做短期的，就借助规则系统 + 机器学习的混合方式来做方案。但不管哪种，样本问题都是要解的。2 套方案也是 2 种选择，也许你还有第 3 种选择，都是选择，所以多与少没有什么差别，只是看能在选择之后投入多少和坚持多久。这种投入就涉及到知识和技能的储备了，所以前端想解决问题，还是得尽快上手机器学习。至于具体怎么上手在此就不做过多介绍了，网上的课程有很多，也可以看西瓜书上手，但关键是动手。可以先从 CV 领域入手，NLP 工程对个人来说单机部署有点难，得借助云（比如谷歌的 TPU 平台）。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864837-0b2391a5-a67a-45a8-845c-e6c735ed80ad.png#align=left&display=inline&height=79&margin=%5Bobject%20Object%5D&originHeight=608&originWidth=1080&size=0&status=done&style=none&width=140"></p>
<p>长远来看，前端 + AI 的这种前端智能化方向肯定是持续存在的，前端也会因为 AI 能力的加入，会产生诸多不一样的生产力变化。这种变化可能是阶段性的，也可能是终极的，总之生产力会慢慢向计算机身上过渡，前端做的工作是驱动这一切的更深层工作。这个方向没有退路，也绕不过去（专家系统不可能无敌），所以要解的问题直到彻底解决为止。</p>
<p><strong>智能化的10年</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864854-dc1390d0-e683-46c9-ae6d-303d2b2e7823.png#align=left&display=inline&height=44&margin=%5Bobject%20Object%5D&originHeight=272&originWidth=872&size=0&status=done&style=none&width=140"></p>
<p>最后，我还是带着大家一起展望一下前端智能化的未来 10 年（以如今的互联网发展节奏看，或许下面的 5 年内就达到也是有可能的）：</p>
<ul>
<li><p>2~3 年内，前端智能化从业者数量翻倍，AI 在前端领域内或多或少有一些产品形态上的应用，终端开始浮现各种前端机器学习框架，用户产品在智能化体验方面的设计也有对应的倾斜，社区上也开始浮现出各种前端智能化的工程框架、训练框架和 AI 平台；</p>
</li>
<li><p>3~5 年内，前端智能化从业者数量继续增长，传统前端已经被淘汰，前端领域内智能化在特定领域内小有成绩，可以解决特定领域内的一些业务或人力生产效率问题，终端智能体验会趋渐成熟，给用户带来的沉浸式体验增强，线上线下无屏化无差异体验趋近相同，社区上开始开源一些前端的智能化产品；</p>
</li>
<li><p>5~10年内，前端智能化从业市场已趋近饱和，端智能体验设计者应该在市场上比较吃香（如沉浸式人机对抗游戏等），nocode 问题应该能彻底解决，但同时带来其他的消费诉求，可能会引入新的领域难题。</p>
</li>
</ul>
<p><strong>结语</strong></p>
<p>如今危机四伏，未来无限可期，所以大家还是要未雨绸缪，提前做好准备。如今前端智能化是新赛道，如果想直接参加前端智能化第一线的，也可以通过下面这种方式加入我们。<br>团队产品</p>
<ul>
<li><p>imgcook —— 由设计稿一键智能生成代码（<a target="_blank" rel="noopener" href="https://www.imgcook.com/">https://www.imgcook.com/</a>）</p>
</li>
<li><p>pipcook —— 前端算法工程框架，前端应用机器学习的最后一公里（<a target="_blank" rel="noopener" href="https://github.com/alibaba/pipcook">https://github.com/alibaba/pipcook</a>）</p>
</li>
</ul>
<p>也欢迎加入我们的社区群， 一群已满，请加二群。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864837-72b58e62-b6e7-4fd0-8c7f-1c154985e9aa.png#align=left&display=inline&height=180&margin=%5Bobject%20Object%5D&originHeight=1280&originWidth=993&size=0&status=done&style=none&width=140"></p>
<hr>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="福利来了"><a href="#福利来了" class="headerlink" title="  福利来了 "></a><strong><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864837-74e1888b-7b05-4ac1-bbe5-6fb080d0c381.png#align=left&display=inline&height=64&margin=%5Bobject%20Object%5D&originHeight=64&originWidth=64&size=0&status=done&style=none&width=64">  福利来了 <img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864896-d5e2d864-d162-4651-aa18-8bbef1c94e69.png#align=left&display=inline&height=64&margin=%5Bobject%20Object%5D&originHeight=64&originWidth=64&size=0&status=done&style=none&width=64"></strong></strong></h1><h1 id="重磅下载！"><a href="#重磅下载！" class="headerlink" title="重磅下载！"></a><strong>重磅下载！</strong></h1><p>《2020 前端工程师必读手册》</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/85733/1590065864840-dc28fbad-a394-4fe9-9394-42b5e2525b91.png#align=left&display=inline&height=198&margin=%5Bobject%20Object%5D&originHeight=842&originWidth=595&size=0&status=done&style=none&width=140"></p>
<p>阿里巴巴前端委员会推荐！覆盖语言框架、前端智能化、微前端、Serverless及工程化** 5 大热点前端技术方向、10+ 核心实战的前端手册，**解锁前端新方式，挖掘前端新思路，尽在此刻，赶紧来先睹为快！关注 alibabaf2e 微信公众号回复 必读手册 立即获取下载链接。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/85733/1590065864864-01b83eca-84f5-4a44-b40f-872c74ed5bea.jpeg#align=left&display=inline&height=140&margin=%5Bobject%20Object%5D&originHeight=344&originWidth=344&size=0&status=done&style=none&width=140"><br>关注「Alibaba F2E」<br>把握阿里巴巴前端新动向</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-28T03:48:42.292Z" title="2020-09-28T03:48:42.292Z">2020-09-28</time>发表</span><span class="level-item"><time dateTime="2020-09-28T03:48:42.292Z" title="2020-09-28T03:48:42.292Z">2020-09-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span> / </span><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="level-item">3 小时读完 (大约31206个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/28/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/04%E9%81%93%20CSS%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%8A%A9%E4%BD%A0%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/">04道 CSS 面试题，助你查漏补缺</a></h1><div class="content"><h2 id="CSS-面试知识点总结"><a href="#CSS-面试知识点总结" class="headerlink" title="CSS 面试知识点总结"></a>CSS 面试知识点总结</h2><p>最近在整理 CSS 的时候发现遇到了很多面试中常见的面试题，本部分主要原作者在 Github 等各大论坛收录的 CSS 相关知识和一些相关面试题时所做的笔记，分享这份总结给大家，对大家对 CSS 的可以来一次全方位的检漏和排查，感谢原作者 CavsZhouyou 的付出，原文链接放在文章最下方，如果出现错误，希望大家共同指出！<br><a name="PN3JK"></a></p>
<h2 id="1-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？"><a href="#1-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？"></a>1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h2><p>相关知识点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）</span><br><span class="line">（2）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分</span><br><span class="line">IE盒模型和W3C标准盒模型的区别：</span><br><span class="line">（1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding</span><br><span class="line">（2）IE盒模型：属性width，height包含content、border和padding，指的是content</span><br><span class="line">+padding+border。</span><br><span class="line">在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；</span><br><span class="line">如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE</span><br><span class="line">盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。</span><br></pre></td></tr></table></figure>
<p>回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">盒模型都是由四个部分组成的，分别是margin、border、padding和content。</span><br><span class="line">标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的</span><br><span class="line">范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。</span><br><span class="line">一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。</span><br></pre></td></tr></table></figure>
<p>详细的资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://juejin.im/post/59ef72f5f265da4320026f76">《CSS 盒模型详解》</a><br><a name="h4zLM"></a></p>
<h2 id="2-CSS-选择符有哪些？"><a href="#2-CSS-选择符有哪些？" class="headerlink" title="2.CSS 选择符有哪些？"></a>2.CSS 选择符有哪些？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（1）id选择器（#myid）</span><br><span class="line">（2）类选择器（.myclassname）</span><br><span class="line">（3）标签选择器（div,h1,p）</span><br><span class="line">（4）后代选择器（h1p）</span><br><span class="line">（5）相邻后代选择器（子）选择器（ul&gt;li）</span><br><span class="line">（6）兄弟选择器（li~a）</span><br><span class="line">（7）相邻兄弟选择器（li+a）</span><br><span class="line">（8）属性选择器（a[rel&#x3D;&quot;external&quot;]）</span><br><span class="line">（9）伪类选择器（a:hover,li:nth-child）</span><br><span class="line">（10）伪元素选择器（::before、::after）</span><br><span class="line">（11）通配符选择器（*）</span><br></pre></td></tr></table></figure>
<p><a name="6bINt"></a></p>
<h2 id="3-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用。"><a href="#3-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用。" class="headerlink" title="3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。"></a>3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。</h2><p>相关知识点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）</span><br><span class="line">双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，</span><br><span class="line">比如:first-line、:first-letter、:before、:after等，</span><br><span class="line">而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</span><br><span class="line">想让插入的内容出现在其它内容前，使用::before，否者，使用::after；</span><br><span class="line">在代码顺序上，::after生成的内容也比::before生成的内容靠后。</span><br><span class="line">如果按堆栈视角，::after生成的内容会在::before生成的内容之上。</span><br></pre></td></tr></table></figure>
<p>回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号</span><br><span class="line">来表示伪元素。</span><br><span class="line">伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。</span><br></pre></td></tr></table></figure>
<p><a name="Ymv2Q"></a></p>
<h2 id="4-伪类与伪元素的区别"><a href="#4-伪类与伪元素的区别" class="headerlink" title="4.伪类与伪元素的区别"></a>4.伪类与伪元素的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句</span><br><span class="line">话中的第一个字母，或者是列表中的第一个元素。</span><br><span class="line">伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的</span><br><span class="line">元素时，我们可以通过:hover来描述这个元素的状态。</span><br><span class="line">伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::be</span><br><span class="line">fore来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</span><br><span class="line">有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是CSS3的一部分，并尝试区分伪类和伪元素。大多数浏览</span><br><span class="line">器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的W3C规范并未对此进行</span><br><span class="line">特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/">《总结伪类与伪元素》</a><br><a name="WaLJA"></a></p>
<h2 id="5-CSS-中哪些属性可以继承？"><a href="#5-CSS-中哪些属性可以继承？" class="headerlink" title="5.CSS 中哪些属性可以继承？"></a>5.CSS 中哪些属性可以继承？</h2><p>相关资料：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">每个CSS属性定义的概述都指出了这个属性是默认继承的，还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算</span><br><span class="line">值。</span><br><span class="line">当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应</span><br><span class="line">该是在该属性本身的定义中的默认值）。</span><br><span class="line">当元素的一个非继承属性（在Mozillacode里有时称之为resetproperty）没有指定值时，则取属性的初始值initialv</span><br><span class="line">alue（该值在该属性的概述里被指定）。</span><br><span class="line">有继承性的属性：</span><br><span class="line">（1）字体系列属性</span><br><span class="line">font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust</span><br><span class="line">（2）文本系列属性</span><br><span class="line">text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、</span><br><span class="line">text-transform、direction、color</span><br><span class="line">（3）表格布局属性</span><br><span class="line">caption-sideborder-collapseempty-cells</span><br><span class="line">（4）列表属性</span><br><span class="line">list-style-type、list-style-image、list-style-position、list-style</span><br><span class="line">（5）光标属性</span><br><span class="line">cursor</span><br><span class="line">（6）元素可见性</span><br><span class="line">visibility</span><br><span class="line">（7）还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性</span><br><span class="line">注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地</span><br><span class="line">指定继承性，可用于任何继承性&#x2F;非继承性属性。</span><br></pre></td></tr></table></figure>
<p>回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值</span><br><span class="line">来作为自己的值。</span><br><span class="line">一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。</span><br><span class="line">表格的一些布局属性、列表属性如list-style等。还有光标属性cursor、元素可见性visibility。</span><br><span class="line">当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。</span><br></pre></td></tr></table></figure>
<p>详细的资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Web/CSS/inheritance">《继承属性》</a><br /><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/34044e3c9317">《CSS 有哪些属性可以继承？》</a><br><a name="9lIrR"></a></p>
<h2 id="6-CSS-优先级算法如何计算？"><a href="#6-CSS-优先级算法如何计算？" class="headerlink" title="6.CSS 优先级算法如何计算？"></a>6.CSS 优先级算法如何计算？</h2><p>相关知识点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CSS的优先级是根据样式声明的特殊性值来判断的。</span><br><span class="line">选择器的特殊性值分为四个等级，如下：</span><br><span class="line">（1）标签内选择符x,0,0,0</span><br><span class="line">（2）ID选择符0,x,0,0</span><br><span class="line">（3）class选择符&#x2F;属性选择符&#x2F;伪类选择符    0,0,x,0</span><br><span class="line">（4）元素和伪元素选择符0,0,0,x</span><br><span class="line">计算方法：</span><br><span class="line">（1）每个等级的初始值为0</span><br><span class="line">（2）每个等级的叠加为选择器出现的次数相加</span><br><span class="line">（3）不可进位，比如0,99,99,99</span><br><span class="line">（4）依次表示为：0,0,0,0</span><br><span class="line">（5）每个等级计数之间没关联</span><br><span class="line">（6）等级判断从左向右，如果某一位数值相同，则判断下一位数值</span><br><span class="line">（7）如果两个优先级相同，则最后出现的优先级高，!important也适用</span><br><span class="line">（8）通配符选择器的特殊性值为：0,0,0,0</span><br><span class="line">（9）继承样式优先级最低，通配符样式优先级高于继承样式</span><br><span class="line">（10）!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。</span><br><span class="line">计算实例：</span><br><span class="line">（1）#demoa&#123;color:orange;&#125;&#x2F;*特殊性值：0,1,0,1*&#x2F;</span><br><span class="line">（2）div#demoa&#123;color:red;&#125;&#x2F;*特殊性值：0,1,0,2*&#x2F;</span><br><span class="line">注意：</span><br><span class="line">（1）样式应用时，css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。</span><br><span class="line">（2）特殊性值越大的声明优先级越高。</span><br><span class="line">（3）相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的）</span><br></pre></td></tr></table></figure>
<p>回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，</span><br><span class="line">那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。</span><br><span class="line">一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，</span><br><span class="line">第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，</span><br><span class="line">第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等</span><br><span class="line">级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。</span><br><span class="line">比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引</span><br><span class="line">入的顺序，后出现的规则的优先级最高。</span><br></pre></td></tr></table></figure>
<p>对于组合声明的特殊性值计算可以参考：<br /><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/1c4e639ff7d5">《CSS 优先级计算及应用》</a><br /><a href="https://link.zhihu.com/?target=http://www.cnblogs.com/wangmeijian/p/4207433.html">《CSS 优先级计算规则》</a><br><a name="7T452"></a></p>
<h2 id="7-关于伪类-LVHA-的解释"><a href="#7-关于伪类-LVHA-的解释" class="headerlink" title="7.关于伪类 LVHA 的解释?"></a>7.关于伪类 LVHA 的解释?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；</span><br><span class="line">当链接未访问过时：</span><br><span class="line">（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪</span><br><span class="line">类后面声明；</span><br><span class="line">（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），</span><br><span class="line">必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。</span><br><span class="line">当链接访问过时，情况基本同上，只不过需要将:link换成:visited。</span><br><span class="line">这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，</span><br><span class="line">也就不存在覆盖的问题。</span><br></pre></td></tr></table></figure>
<p><a name="q9Adb"></a></p>
<h2 id="8-CSS3-新增伪类有那些？"><a href="#8-CSS3-新增伪类有那些？" class="headerlink" title="8.CSS3 新增伪类有那些？"></a>8.CSS3 新增伪类有那些？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（1）elem:nth-child(n)选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数</span><br><span class="line">值，也可以接受函数。</span><br><span class="line">（2）elem:nth-last-child(n)作用同上，不过是从后开始查找。</span><br><span class="line">（3）elem:last-child选中最后一个子元素。</span><br><span class="line">（4）elem:only-child如果elem是父元素下唯一的子元素，则选中之。</span><br><span class="line">（5）elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。</span><br><span class="line">（6）elem:first-of-type选中父元素下第一个elem类型元素。</span><br><span class="line">（7）elem:last-of-type选中父元素下最后一个elem类型元素。</span><br><span class="line">（8）elem:only-of-type如果父元素下的子元素只有一个elem类型元素，则选中该元素。</span><br><span class="line">（9）elem:empty选中不包含子元素和内容的elem类型元素。</span><br><span class="line">（10）elem:target选择当前活动的elem元素。</span><br><span class="line">（11）:not(elem)选择非elem元素的每个元素。</span><br><span class="line">（12）:enabled    控制表单控件的禁用状态。</span><br><span class="line">（13）:disabled        控制表单控件的禁用状态。</span><br><span class="line">(14):checked单选框或复选框被选中。</span><br></pre></td></tr></table></figure>
<p>详细的资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/SKLthegoodman/p/css3.html">《CSS3 新特性总结(伪类)》</a><br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/zhouziyu2011/article/details/58605705">《浅谈 CSS 伪类和伪元素及 CSS3 新增伪类》</a><br><a name="o66zb"></a></p>
<h2 id="9-如何居中-div？"><a href="#9-如何居中-div？" class="headerlink" title="9.如何居中 div？"></a>9.如何居中 div？</h2><p>-水平居中：给 div 设置一个宽度，然后添加 margin:0auto 属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  margin: 0auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-水平居中，利用 text-align:center 实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  background: rgba(0, 0, 0, 0.5);</span><br><span class="line">  text-align: center;</span><br><span class="line">  font-size: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 500px;</span><br><span class="line">  height: 400px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-让绝对定位的 div 居中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  margin: auto;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  background-color: pink; &#x2F;*方便看效果*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-水平垂直居中一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*确定容器的宽高宽500高300的层设置层的外边距div&#123;*&#x2F;</span><br><span class="line">position:absolute;&#x2F;*绝对定位*&#x2F;</span><br><span class="line">width:500px;</span><br><span class="line">height:300px;</span><br><span class="line">top:50%;</span><br><span class="line">left:50%;</span><br><span class="line">margin:-150px00-250px;&#x2F;*外边距为自身宽高的一半*&#x2F;</span><br><span class="line">background-color:pink;&#x2F;*方便看效果*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-水平垂直居中二</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*未知容器的宽高，利用&#96;transform&#96;属性*&#x2F;</span><br><span class="line">div &#123;</span><br><span class="line">  position: absolute; &#x2F;*相对定位或绝对定位均可*&#x2F;</span><br><span class="line">  width: 500px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">  background-color: pink; &#x2F;*方便看效果*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-水平垂直居中三</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*利用flex布局实际使用时应考虑兼容性*&#x2F;</span><br><span class="line">.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center; &#x2F;*垂直居中*&#x2F;</span><br><span class="line">  justify-content: center; &#x2F;*水平居中*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">.containerdiv &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background-color: pink; &#x2F;*方便看效果*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-水平垂直居中四</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*利用text-align:center和vertical-align:middle属性*&#x2F;</span><br><span class="line">.container &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  background: rgba(0, 0, 0, 0.5);</span><br><span class="line">  text-align: center;</span><br><span class="line">  font-size: 0;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">  overflow: auto;</span><br><span class="line">&#125;</span><br><span class="line">.container::after &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  height: 100%;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 500px;</span><br><span class="line">  height: 400px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">  white-space: normal;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">一般常见的几种居中的方法有：</span><br><span class="line">对于宽高固定的元素</span><br><span class="line">（1）我们可以利用margin:0auto来实现元素的水平居中。</span><br><span class="line">（2）利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水</span><br><span class="line">平和垂直方向上的居中。</span><br><span class="line">（3）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素</span><br><span class="line">的中心点到页面的中心。</span><br><span class="line">（4）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素</span><br><span class="line">的中心点到页面的中心。</span><br><span class="line">（5）使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对</span><br><span class="line">齐，然后它的子元素也可以实现垂直和水平的居中。</span><br><span class="line">对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。</span><br></pre></td></tr></table></figure>
<p><a name="N334V"></a></p>
<h2 id="10-display-有哪些值？说明他们的作用。"><a href="#10-display-有哪些值？说明他们的作用。" class="headerlink" title="10.display 有哪些值？说明他们的作用。"></a>10.display 有哪些值？说明他们的作用。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">block    块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</span><br><span class="line">none    元素不显示，并从文档流中移除。</span><br><span class="line">inline    行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</span><br><span class="line">inline-block默认宽度为内容宽度，可以设置宽高，同行显示。</span><br><span class="line">list-item    像块类型元素一样显示，并添加样式列表标记。</span><br><span class="line">table    此元素会作为块级表格来显示。</span><br><span class="line">inherit    规定应该从父元素继承display属性的值。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=http://www.w3school.com.cn/css/pr_class_display.asp">《CSSdisplay 属性》</a><br><a name="a0SxU"></a></p>
<h2 id="11-position-的值-relative-和-absolute-定位原点是？"><a href="#11-position-的值-relative-和-absolute-定位原点是？" class="headerlink" title="11.position 的值 relative 和 absolute 定位原点是？"></a>11.position 的值 relative 和 absolute 定位原点是？</h2><p>相关知识点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">absolute</span><br><span class="line">生成绝对定位的元素，相对于值不为static的第一个父元素的paddingbox进行定位，也可以理解为离自己这一级元素最近的</span><br><span class="line">一级position设置为absolute或者relative的父元素的paddingbox的左上角为原点的。</span><br><span class="line">fixed（老IE不支持）</span><br><span class="line">生成绝对定位的元素，相对于浏览器窗口进行定位。</span><br><span class="line">relative</span><br><span class="line">生成相对定位的元素，相对于其元素本身所在正常位置进行定位。</span><br><span class="line">static</span><br><span class="line">默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。</span><br><span class="line">inherit</span><br><span class="line">规定从父元素继承position属性的值。</span><br></pre></td></tr></table></figure>
<p>回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">relative定位的元素，是相对于元素本身的正常位置来进行定位的。</span><br><span class="line">absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的paddingbox来进行定位的。这句话</span><br><span class="line">我们可以这样来理解，我们首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元</span><br><span class="line">素的paddingbox来定位，也就是说在计算定位距离的时候，padding的值也要算进去。</span><br></pre></td></tr></table></figure>
<p><a name="cDYWX"></a></p>
<h2 id="12-CSS3-有哪些新特性？（根据项目回答）"><a href="#12-CSS3-有哪些新特性？（根据项目回答）" class="headerlink" title="12.CSS3 有哪些新特性？（根据项目回答）"></a>12.CSS3 有哪些新特性？（根据项目回答）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">新增各种CSS选择器    （:not(.input)：所有class不是“input”的节点）</span><br><span class="line">圆角        （border-radius:8px）</span><br><span class="line">多列布局    （multi-columnlayout）</span><br><span class="line">阴影和反射    （Shadow\Reflect）</span><br><span class="line">文字特效        （text-shadow）</span><br><span class="line">文字渲染        （Text-decoration）</span><br><span class="line">线性渐变        （gradient）</span><br><span class="line">旋转            （transform）</span><br><span class="line">缩放，定位，倾斜，动画，多背景</span><br><span class="line">例如：transform:\scale(0.85,0.90)\translate(0px,-30px)\skew(-9deg,0deg)\Animation:</span><br></pre></td></tr></table></figure>
<p><a name="alpE8"></a></p>
<h2 id="13-请解释一下-CSS3-的-Flexbox（弹性盒布局模型），以及适用场景？"><a href="#13-请解释一下-CSS3-的-Flexbox（弹性盒布局模型），以及适用场景？" class="headerlink" title="13.请解释一下 CSS3 的 Flexbox（弹性盒布局模型），以及适用场景？"></a>13.请解释一下 CSS3 的 Flexbox（弹性盒布局模型），以及适用场景？</h2><p>相关知识点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Flex是FlexibleBox的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</span><br><span class="line">任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的float、cl</span><br><span class="line">ear和vertical-align属性将失效。</span><br><span class="line">采用Flex布局的元素，称为Flex容器（flexcontainer），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为Flex</span><br><span class="line">项目（flexitem），简称&quot;项目&quot;。</span><br><span class="line">容器默认存在两根轴：水平的主轴（mainaxis）和垂直的交叉轴（crossaxis），项目默认沿主轴排列。</span><br><span class="line">以下6个属性设置在容器上。</span><br><span class="line">flex-direction属性决定主轴的方向（即项目的排列方向）。</span><br><span class="line">flex-wrap属性定义，如果一条轴线排不下，如何换行。</span><br><span class="line">flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为rownowrap。</span><br><span class="line">justify-content属性定义了项目在主轴上的对齐方式。</span><br><span class="line">align-items属性定义项目在交叉轴上如何对齐。</span><br><span class="line">align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</span><br><span class="line">以下6个属性设置在项目上。</span><br><span class="line">order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</span><br><span class="line">flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</span><br><span class="line">flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</span><br><span class="line">flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认</span><br><span class="line">值为auto，即项目的本来大小。</span><br><span class="line">flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为01auto。</span><br><span class="line">align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父</span><br><span class="line">元素的align-items属性，如果没有父元素，则等同于stretch。</span><br></pre></td></tr></table></figure>
<p>回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex</span><br><span class="line">容器，它的所有子元素都会成为它的项目。</span><br><span class="line">一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。</span><br><span class="line">我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还</span><br><span class="line">可以使用flex-wrap来规定当一行排列不下时的换行方式。</span><br><span class="line">对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，</span><br><span class="line">项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">《Flex 布局教程：语法篇》</a><br /><a href="https://link.zhihu.com/?target=http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">《Flex 布局教程：实例篇》</a><br><a name="sdzlD"></a></p>
<h2 id="14-用纯-CSS-创建一个三角形的原理是什么？"><a href="#14-用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="14.用纯 CSS 创建一个三角形的原理是什么？"></a>14.用纯 CSS 创建一个三角形的原理是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">采用的是相邻边框连接处的均分原理。</span><br><span class="line">  将元素的宽高设为0，只设置</span><br><span class="line">  border</span><br><span class="line">  ，把任意三条边隐藏掉（颜色设为</span><br><span class="line">  transparent），剩下的就是一个三角形。</span><br><span class="line">  #demo &#123;</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  border-width: 20px;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: transparenttransparentredtransparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="y3FIs"></a></p>
<h2 id="15-一个满屏品字布局如何设计"><a href="#15-一个满屏品字布局如何设计" class="headerlink" title="15.一个满屏品字布局如何设计?"></a>15.一个满屏品字布局如何设计?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">简单的方式：</span><br><span class="line">    上面的div宽100%，</span><br><span class="line">    下面的两个div分别宽50%，</span><br><span class="line">    然后用float或者inline使其不换行即可</span><br></pre></td></tr></table></figure>
<p><a name="rh8hW"></a></p>
<h2 id="16-CSS-多列等高如何实现？"><a href="#16-CSS-多列等高如何实现？" class="headerlink" title="16.CSS 多列等高如何实现？"></a>16.CSS 多列等高如何实现？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:</span><br><span class="line">hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则</span><br><span class="line">父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</span><br><span class="line">（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。</span><br><span class="line">（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度</span><br><span class="line">的特性，来实现多列等高。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://juejin.im/post/5b0fb34151882515662238fd">《前端应该掌握的 CSS 实现多列等高布局》</a><br /><a href="https://link.zhihu.com/?target=https://codepen.io/yangbo5207/post/equh">《CSS：多列等高布局》</a><br><a name="hJC3D"></a></p>
<h2 id="17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？"><a href="#17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？" class="headerlink" title="17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？"></a>17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">（1）png24位的图片在iE6浏览器上出现背景</span><br><span class="line">解决方案：做成PNG8，也可以引用一段脚本处理。</span><br><span class="line">（2）浏览器默认的margin和padding不同</span><br><span class="line">解决方案：加一个全局的*&#123;margin:0;padding:0;&#125;来统一。</span><br><span class="line">（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或</span><br><span class="line">margin-right，margin值会加倍。</span><br><span class="line">#box&#123;float:left;width:10px;margin:00010px;&#125;</span><br><span class="line">这种情况之下IE会产生20px的距离</span><br><span class="line">解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</span><br><span class="line">（4）渐进识别的方式，从总体中逐渐排除局部。</span><br><span class="line">首先，巧妙的使用&quot;\9&quot;这一标记，将IE游览器从所有情况中分离出来。</span><br><span class="line">接着，再次使用&quot;+&quot;将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</span><br><span class="line">.bb&#123;</span><br><span class="line">background-color:#f1ee18;&#x2F;*所有识别*&#x2F;</span><br><span class="line">.background-color:#00deff\9;&#x2F;*IE6、7、8识别*&#x2F;</span><br><span class="line">+background-color:#a200ff;&#x2F;*IE6、7识别*&#x2F;</span><br><span class="line">_background-color:#1e0bd1;&#x2F;*IE6识别*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义</span><br><span class="line">属性；Firefox下，只能使用getAttribute()获取自定义属性</span><br><span class="line">解决方法：统一通过getAttribute()获取自定义属性。</span><br><span class="line">（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有</span><br><span class="line">pageX、pageY属性，但是没有x、y属性。</span><br><span class="line">解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</span><br><span class="line">（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示</span><br><span class="line">解决方法：</span><br><span class="line">1.可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome</span><br><span class="line">更新到27版本之后就不可以用了。</span><br><span class="line">2.还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);</span><br><span class="line">收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block&#x2F;inline-block&#x2F;...；</span><br><span class="line">（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了</span><br><span class="line">解决方法：改变CSS属性的排列顺序L-V-H-A</span><br><span class="line">（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模</span><br><span class="line">式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。</span><br></pre></td></tr></table></figure>
<p><a name="Ss5lc"></a></p>
<h2 id="http-18-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#http-18-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="http://18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a><a href="https://link.zhihu.com/?target=http://18.li">http://18.li</a> 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个&lt;li&gt;放在一行，</span><br><span class="line">这导致&lt;li&gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</span><br><span class="line">解决办法：</span><br><span class="line">（1）为&lt;li&gt;设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</span><br><span class="line">（2）将所有&lt;li&gt;写在同一行。不足：代码不美观。</span><br><span class="line">（3）将&lt;ul&gt;内的字符尺寸直接设为0，即font-size:0。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他</span><br><span class="line">字符尺寸，且在Safari浏览器依然会出现空白间隔。</span><br><span class="line">（4）消除&lt;ul&gt;的字符间隔letter-spacing:-8px，不足：这也设置了&lt;li&gt;内的字符间隔，因此需要将&lt;li&gt;内的字符</span><br><span class="line">间隔设为默认letter-spacing:normal。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/sjinsa/article/details/70919546">《li 与 li 之间有看不见的空白间隔是什么原因引起的？》</a><br><a name="WBRGA"></a></p>
<h2 id="19-为什么要初始化-CSS-样式？"><a href="#19-为什么要初始化-CSS-样式？" class="headerlink" title="19.为什么要初始化 CSS 样式？"></a>19.为什么要初始化 CSS 样式？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</span><br><span class="line">-当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</span><br><span class="line">最简单的初始化方法：*&#123;padding:0;margin:0;&#125;（强烈不建议）</span><br><span class="line">淘宝的样式初始化代码：</span><br><span class="line">body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend</span><br><span class="line">,button,input,textarea,th,td&#123;margin:0;padding:0;&#125;</span><br><span class="line">body,button,input,select,textarea&#123;font:12px&#x2F;1.5tahoma,arial,\5b8b\4f53;&#125;</span><br><span class="line">h1,h2,h3,h4,h5,h6&#123;font-size:100%;&#125;</span><br><span class="line">address,cite,dfn,em,var&#123;font-style:normal;&#125;</span><br><span class="line">code,kbd,pre,samp&#123;font-family:couriernew,courier,monospace;&#125;</span><br><span class="line">small&#123;font-size:12px;&#125;</span><br><span class="line">ul,ol&#123;list-style:none;&#125;</span><br><span class="line">a&#123;text-decoration:none;&#125;</span><br><span class="line">a:hover&#123;text-decoration:underline;&#125;</span><br><span class="line">sup&#123;vertical-align:text-top;&#125;</span><br><span class="line">sub&#123;vertical-align:text-bottom;&#125;</span><br><span class="line">legend&#123;color:#000;&#125;</span><br><span class="line">fieldset,img&#123;border:0;&#125;</span><br><span class="line">button,input,select,textarea&#123;font-size:100%;&#125;</span><br><span class="line">table&#123;border-collapse:collapse;border-spacing:0;&#125;</span><br></pre></td></tr></table></figure>
<p><a name="8GkVq"></a></p>
<h2 id="20-什么是包含块，对于包含块的理解"><a href="#20-什么是包含块，对于包含块的理解" class="headerlink" title="20.什么是包含块，对于包含块的理解?"></a>20.什么是包含块，对于包含块的理解?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">包含块（containingblock）就是元素用来计算和定位的一个框。</span><br><span class="line">（1）根元素（很多场景下可以看成是&lt;html&gt;）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。</span><br><span class="line">（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的contentbox</span><br><span class="line">边界形成。</span><br><span class="line">（3）如果元素position:fixed，则“包含块”是“初始包含块”。</span><br><span class="line">（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：</span><br><span class="line">如果该祖先元素是纯inline元素，则规则略复杂：</span><br><span class="line">•假设给内联元素的前后各生成一个宽度为0的内联盒子（inlinebox），则这两个内联盒子的paddingbox外面的包</span><br><span class="line">围盒就是内联元素的“包含块”；</span><br><span class="line">•如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥</span><br><span class="line">否则，“包含块”由该祖先的paddingbox边界形成。</span><br><span class="line">如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。</span><br></pre></td></tr></table></figure>
<p><a name="fCe71"></a></p>
<h2 id="21-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？在不同浏览器下以后什么区别？"><a href="#21-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？在不同浏览器下以后什么区别？" class="headerlink" title="21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？"></a>21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。</span><br><span class="line">（2）但例外的是，如果这个元素是table相关的元素，例如table行，tablegroup，table列，tablecolumngroup，它的</span><br><span class="line">表现却跟display:none一样，也就是说，它们占用的空间也会释放。</span><br><span class="line">在不同浏览器下的区别：</span><br><span class="line">在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。</span><br><span class="line">在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位</span><br><span class="line">置。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=http://www.webhek.com/post/visibility-collapse.html">《CSS 里的 visibility 属性有个鲜为人知的属性值：collapse》</a><br><a name="g48s5"></a></p>
<h2 id="22-width-auto-和-width-100-的区别"><a href="#22-width-auto-和-width-100-的区别" class="headerlink" title="22.width:auto 和 width:100%的区别"></a>22.width:auto 和 width:100%的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一般而言</span><br><span class="line">width:100%会使元素box的宽度等于父元素的contentbox的宽度。</span><br><span class="line">width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。</span><br></pre></td></tr></table></figure>
<p><a name="qTUZh"></a></p>
<h2 id="23-绝对定位元素与非绝对定位元素的百分比计算的区别"><a href="#23-绝对定位元素与非绝对定位元素的百分比计算的区别" class="headerlink" title="23.绝对定位元素与非绝对定位元素的百分比计算的区别"></a>23.绝对定位元素与非绝对定位元素的百分比计算的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的paddingbox来计算的。</span><br><span class="line">非绝对定位元素的宽高百分比则是相对于父元素的contentbox来计算的。</span><br></pre></td></tr></table></figure>
<p><a name="BlXmw"></a></p>
<h2 id="24-简单介绍使用图片-base64-编码的优点和缺点。"><a href="#24-简单介绍使用图片-base64-编码的优点和缺点。" class="headerlink" title="24.简单介绍使用图片 base64 编码的优点和缺点。"></a>24.简单介绍使用图片 base64 编码的优点和缺点。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的</span><br><span class="line">url属性。</span><br><span class="line">使用base64的优点是：</span><br><span class="line">（1）减少一个图片的HTTP请求</span><br><span class="line">使用base64的缺点是：</span><br><span class="line">（1）根据base64的编码原理，编码后的大小会比原文件大小大1&#x2F;3，如果把大图片编码到html&#x2F;css中，不仅会造成文件体</span><br><span class="line">积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。</span><br><span class="line">（2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要</span><br><span class="line">差很多。</span><br><span class="line">（3）兼容性的问题，ie8以前的浏览器不支持。</span><br><span class="line">一般一些网站的小图标可以使用base64图片来引入。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/coco1s/p/4375774.html">《玩转图片 base64 编码》</a><br /><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31155574">《前端开发中，使用 base64 图片的弊端是什么？》</a><br /><a href="https://link.zhihu.com/?target=https://www.zhangxinxu.com/wordpress/2012/04/base64-url-image-%25E5%259B%25BE%25E7%2589%2587-%25E9%25A1%25B5%25E9%259D%25A2%25E6%2580%25A7%25E8%2583%25BD%25E4%25BC%2598%25E5%258C%2596/">《小 tip:base64:URL 背景图片与 web 页面性能优化》</a><br><a name="2kVnR"></a></p>
<h2 id="25-’display’、’position’和’float’的相互关系？"><a href="#25-’display’、’position’和’float’的相互关系？" class="headerlink" title="25.’display’、’position’和’float’的相互关系？"></a>25.’display’、’position’和’float’的相互关系？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</span><br><span class="line">（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被</span><br><span class="line">设置为table或者block，具体转换需要看初始转换值。</span><br><span class="line">（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display</span><br><span class="line">的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对</span><br><span class="line">于浮动后的最终位置定位。</span><br><span class="line">（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，</span><br><span class="line">则保持指定的display属性值不变。</span><br><span class="line">总的来说，可以把它看作是一个类似优先级的机制，&quot;position:absolute&quot;和&quot;position:fixed&quot;优先级最高，有它存在</span><br><span class="line">的时候，浮动不起作用，&#39;display&#39;的值也需要调整；其次，元素的&#39;float&#39;特性的值不是&quot;none&quot;的时候或者它是根元素</span><br><span class="line">的时候，调整&#39;display&#39;的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，&#39;display&#39;特性值同设置值。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/jackyWHJ/p/3756087.html">《position 跟 display、margincollapse、overflow、float 这些特性相互叠加后会怎么样？》</a><br><a name="2xgcK"></a></p>
<h2 id="26-margin-重叠问题的理解。"><a href="#26-margin-重叠问题的理解。" class="headerlink" title="26.margin 重叠问题的理解。"></a>26.margin 重叠问题的理解。</h2><p>相关知识点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合</span><br><span class="line">并”。</span><br><span class="line">产生折叠的必备条件：margin必须是邻接的!</span><br><span class="line">而根据w3c规范，两个margin是邻接的必须满足以下条件：</span><br><span class="line">•必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。</span><br><span class="line">•没有线盒，没有空隙，没有padding和border将他们分隔开</span><br><span class="line">•都属于垂直方向上相邻的外边距，可以是下面任意一种情况</span><br><span class="line">•元素的margin-top与其第一个常规文档流的子元素的margin-top</span><br><span class="line">•元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top</span><br><span class="line">•height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom</span><br><span class="line">•高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top</span><br><span class="line">和margin-bottom</span><br><span class="line">margin合并的3种场景：</span><br><span class="line">（1）相邻兄弟元素margin合并。</span><br><span class="line">解决办法：</span><br><span class="line">•设置块状格式化上下文元素（BFC）</span><br><span class="line">（2）父级和第一个&#x2F;最后一个子元素的margin合并。</span><br><span class="line">解决办法：</span><br><span class="line">对于margin-top合并，可以进行如下操作（满足一个条件即可）：</span><br><span class="line">•父元素设置为块状格式化上下文元素；</span><br><span class="line">•父元素设置border-top值；</span><br><span class="line">•父元素设置padding-top值；</span><br><span class="line">•父元素和第一个子元素之间添加内联元素进行分隔。</span><br><span class="line">对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：</span><br><span class="line">•父元素设置为块状格式化上下文元素；</span><br><span class="line">•父元素设置border-bottom值；</span><br><span class="line">•父元素设置padding-bottom值；</span><br><span class="line">•父元素和最后一个子元素之间添加内联元素进行分隔；</span><br><span class="line">•父元素设置height、min-height或max-height。</span><br><span class="line">（3）空块级元素的margin合并。</span><br><span class="line">解决办法：</span><br><span class="line">•设置垂直方向的border；</span><br><span class="line">•设置垂直方向的padding；</span><br><span class="line">•里面添加内联元素（直接Space键空格是没用的）；</span><br><span class="line">•设置height或者min-height。</span><br></pre></td></tr></table></figure>
<p>回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">margin重叠指的是在垂直方向上，两个相邻元素的margin发生重叠的情况。</span><br><span class="line">一般来说可以分为四种情形：</span><br><span class="line">第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC</span><br><span class="line">来解决。</span><br><span class="line">第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这</span><br><span class="line">一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC</span><br><span class="line">来解决。</span><br><span class="line">第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相</span><br><span class="line">邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为</span><br><span class="line">父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。</span><br><span class="line">第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、pa</span><br><span class="line">dding或者高度来解决这个问题。</span><br></pre></td></tr></table></figure>
<p><a name="jT6xV"></a></p>
<h2 id="27-对-BFC-规范（块级格式化上下文：blockformattingcontext）的理解？"><a href="#27-对-BFC-规范（块级格式化上下文：blockformattingcontext）的理解？" class="headerlink" title="27.对 BFC 规范（块级格式化上下文：blockformattingcontext）的理解？"></a>27.对 BFC 规范（块级格式化上下文：blockformattingcontext）的理解？</h2><p>相关知识点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">块格式化上下文（BlockFormattingContext，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒</span><br><span class="line">子的区域，也是浮动元素与其他元素的交互限定区域。</span><br><span class="line">通俗来讲</span><br><span class="line">•BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。</span><br><span class="line">•如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</span><br><span class="line">创建BFC</span><br><span class="line">（1）根元素或包含根元素的元素</span><br><span class="line">（2）浮动元素float＝left|right或inherit（≠none）</span><br><span class="line">（3）绝对定位元素position＝absolute或fixed</span><br><span class="line">（4）display＝inline-block|flex|inline-flex|table-cell或table-caption</span><br><span class="line">（5）overflow＝hidden|auto或scroll(≠visible)</span><br></pre></td></tr></table></figure>
<p>回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也</span><br><span class="line">不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。</span><br><span class="line">一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些</span><br><span class="line">属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html">《深入理解 BFC 和 MarginCollapse》</a><br /><a href="https://link.zhihu.com/?target=https://segmentfault.com/a/1190000013647777">《前端面试题-BFC（块格式化上下文）》</a><br><a name="uLCVA"></a></p>
<h2 id="28-IFC-是什么？"><a href="#28-IFC-是什么？" class="headerlink" title="28.IFC 是什么？"></a>28.IFC 是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IFC指的是行级格式化上下文，它有这样的一些布局规则：</span><br><span class="line">（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。</span><br><span class="line">（2）当一行不够的时候会自动切换到下一行。</span><br><span class="line">（3）行级上下文的高度由内部最高的内联盒子的高度决定。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/paintandraw/article/details/80401741">《BFC 和 IFC 的理解（布局）》</a><br><a name="drO1J"></a></p>
<h2 id="29-请解释一下为什么需要清除浮动？清除浮动的方式"><a href="#29-请解释一下为什么需要清除浮动？清除浮动的方式" class="headerlink" title="29.请解释一下为什么需要清除浮动？清除浮动的方式"></a>29.请解释一下为什么需要清除浮动？清除浮动的方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，</span><br><span class="line">不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框</span><br><span class="line">的高度小于浮动框的时候，此时就会出现“高度塌陷”。</span><br><span class="line">清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</span><br><span class="line">清除浮动的方式</span><br><span class="line">（1）使用clear属性清除浮动。参考28。</span><br><span class="line">（2）使用BFC块级格式化上下文来清除浮动。参考26。</span><br><span class="line">因为BFC元素不会影响外部元素的特点，所以BFC元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元</span><br><span class="line">素高度塌陷，必然会影响后面元素布局和定位，这显然有违BFC元素的子元素不会影响外部元素的设定。</span><br></pre></td></tr></table></figure>
<p><a name="sk13G"></a></p>
<h2 id="30-使用-clear-属性清除浮动的原理？"><a href="#30-使用-clear-属性清除浮动的原理？" class="headerlink" title="30.使用 clear 属性清除浮动的原理？"></a>30.使用 clear 属性清除浮动的原理？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">使用clear属性清除浮动，其语法如下：</span><br><span class="line">clear:none|left|right|both</span><br><span class="line">如果单看字面意思，clear:left应该是“清除左浮动”，clear:right应该是“清除右浮动”的意思，实际上，这种解释是有问</span><br><span class="line">题的，因为浮动一直还在，并没有清除。</span><br><span class="line">官方对clear属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置clear属性是为了避免浮动元素</span><br><span class="line">对该元素的影响，而不是清除掉浮动。</span><br><span class="line">还需要注意的一点是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属</span><br><span class="line">性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear</span><br><span class="line">属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left</span><br><span class="line">等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和cle</span><br><span class="line">ar:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</span><br><span class="line">一般使用伪元素的方式清除浮动</span><br><span class="line">.clear::after&#123;</span><br><span class="line">content:&#39;&#39;;</span><br><span class="line">display:table;&#x2F;&#x2F;也可以是&#39;block&#39;，或者是&#39;list-item&#39;</span><br><span class="line">clear:both;</span><br><span class="line">&#125;</span><br><span class="line">clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置disp</span><br><span class="line">lay属性值的原因。</span><br></pre></td></tr></table></figure>
<p><a name="xCPce"></a></p>
<h2 id="31-zoom-1-的清除浮动原理"><a href="#31-zoom-1-的清除浮动原理" class="headerlink" title="31.zoom:1 的清除浮动原理?"></a>31.zoom:1 的清除浮动原理?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">清除浮动，触发hasLayout；</span><br><span class="line">zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）</span><br><span class="line">的重叠，浮动清除，触发ie的haslayout属性等。</span><br><span class="line">来龙去脉大概如下：</span><br><span class="line">当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发</span><br><span class="line">生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。</span><br><span class="line">zoom属性是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标</span><br><span class="line">准化，出现在CSS3.0规范草案中。</span><br><span class="line">目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。</span><br></pre></td></tr></table></figure>
<p><a name="THaBc"></a></p>
<h2 id="32-移动端的布局用过媒体查询吗？"><a href="#32-移动端的布局用过媒体查询吗？" class="headerlink" title="32.移动端的布局用过媒体查询吗？"></a>32.移动端的布局用过媒体查询吗？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些</span><br><span class="line">媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法</span><br><span class="line">当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被</span><br><span class="line">下载（只不过不会被应用）。</span><br><span class="line">包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改</span><br><span class="line">内容便可以使样式应用于某些特定的设备范围。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=http://www.runoob.com/cssref/css3-pr-mediaquery.html">《CSS3@media 查询》</a><br /><a href="https://link.zhihu.com/?target=http://caibaojian.com/356.html">《响应式布局和自适应布局详解》</a><br><a name="wni1d"></a></p>
<h2 id="33-使用-CSS-预处理器吗？喜欢哪个？"><a href="#33-使用-CSS-预处理器吗？喜欢哪个？" class="headerlink" title="33.使用 CSS 预处理器吗？喜欢哪个？"></a>33.使用 CSS 预处理器吗？喜欢哪个？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SASS（SASS、LESS没有本质区别，只因为团队前端都是用的SASS）</span><br></pre></td></tr></table></figure>
<p><a name="659dh"></a></p>
<h2 id="34-CSS-优化、提高性能的方法有哪些？"><a href="#34-CSS-优化、提高性能的方法有哪些？" class="headerlink" title="34.CSS 优化、提高性能的方法有哪些？"></a>34.CSS 优化、提高性能的方法有哪些？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">加载性能：</span><br><span class="line">（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。</span><br><span class="line">（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top0bottom0;但margin-bottom:bot</span><br><span class="line">tom;margin-left:left;执行的效率更高。</span><br><span class="line">（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</span><br><span class="line">选择器性能：</span><br><span class="line">（1）关键选择器（keyselector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到</span><br><span class="line">左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</span><br><span class="line">（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹</span><br><span class="line">配它们了）。</span><br><span class="line">（3）避免使用通配规则，如*&#123;&#125;计算次数惊人！只对需要用到的元素进行选择。</span><br><span class="line">（4）尽量少的去对标签进行选择，而是用class。</span><br><span class="line">（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过</span><br><span class="line">三层，更多的使用类来关联每一个标签元素。</span><br><span class="line">（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</span><br><span class="line">渲染性能：</span><br><span class="line">（1）慎重使用高性能属性：浮动、定位。</span><br><span class="line">（2）尽量减少页面重排、重绘。</span><br><span class="line">（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</span><br><span class="line">（4）属性值为0时，不加单位。</span><br><span class="line">（5）属性值为浮动小数0.**，可以省略小数点之前的0。</span><br><span class="line">（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</span><br><span class="line">（7）不使用@import前缀，它会影响css的加载速度。</span><br><span class="line">（8）选择器优化嵌套，尽量避免层级过深。</span><br><span class="line">（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清</span><br><span class="line">楚，再使用。</span><br><span class="line">（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</span><br><span class="line">（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。webfonts通常体积庞大，而且一些浏</span><br><span class="line">览器在下载webfonts时会阻塞页面渲染损伤性能。</span><br><span class="line">可维护性、健壮性：</span><br><span class="line">（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</span><br><span class="line">（2）样式与内容分离：将css代码定义到外部css中。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19886806">《CSS 优化、提高性能的方法有哪些？》</a><br /><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/4e673bf24a3b">《CSS 优化，提高性能的方法》</a><br><a name="pkFRB"></a></p>
<h2 id="35-浏览器是怎样解析-CSS-选择器的？"><a href="#35-浏览器是怎样解析-CSS-选择器的？" class="headerlink" title="35.浏览器是怎样解析 CSS 选择器的？"></a>35.浏览器是怎样解析 CSS 选择器的？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直</span><br><span class="line">到和规则匹配，或者是因为不匹配而放弃该规则。</span><br><span class="line">试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，</span><br><span class="line">最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://juejin.im/entry/5a123c55f265da432240cc90">《探究 CSS 解析原理》</a><br><a name="UFrEb"></a></p>
<h2 id="36-在网页中应该使用奇数还是偶数的字体？为什么呢？"><a href="#36-在网页中应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="36.在网页中应该使用奇数还是偶数的字体？为什么呢？"></a>36.在网页中应该使用奇数还是偶数的字体？为什么呢？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14</span><br><span class="line">×0.5&#x3D;7px的margin，在另一些地方用14×1.5&#x3D;21px的标题字号。</span><br><span class="line">（2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。</span><br><span class="line">（3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/jian_xi/article/details/79346477">《谈谈网页中使用奇数字体和偶数字体》</a><br /><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20440679">《现在网页设计中的为什么少有人用 11px、13px、15px 等奇数的字体？》</a><br><a name="y6GMA"></a></p>
<h2 id="37-margin-和-padding-分别适合什么场景使用？"><a href="#37-margin-和-padding-分别适合什么场景使用？" class="headerlink" title="37.margin 和 padding 分别适合什么场景使用？"></a>37.margin 和 padding 分别适合什么场景使用？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。</span><br><span class="line">margin用于布局分开元素使元素与元素互不相干。</span><br><span class="line">padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。</span><br><span class="line">何时应当使用margin：</span><br><span class="line">•需要在border外侧添加空白时。</span><br><span class="line">•空白处不需要背景（色）时。</span><br><span class="line">•上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。</span><br><span class="line">何时应当时用padding：</span><br><span class="line">•需要在border内测添加空白时。</span><br><span class="line">•空白处需要背景（色）时。</span><br><span class="line">•上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。</span><br></pre></td></tr></table></figure>
<p><a name="I4xgF"></a></p>
<h2 id="38-抽离样式模块怎么写，说出思路，有无实践经验？-阿里航旅的面试题"><a href="#38-抽离样式模块怎么写，说出思路，有无实践经验？-阿里航旅的面试题" class="headerlink" title="38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]"></a>38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放</span><br><span class="line">进业务相关的库里面做成对应功能的模块儿。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=http://nec.netease.com/standard/css-sort.html">《CSS 规范-分类方法》</a><br><a name="6PEqc"></a></p>
<h2 id="39-简单说一下-css3-的-all-属性。"><a href="#39-简单说一下-css3-的-all-属性。" class="headerlink" title="39.简单说一下 css3 的 all 属性。"></a>39.简单说一下 css3 的 all 属性。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction</span><br><span class="line">这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。</span><br><span class="line">initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始</span><br><span class="line">值。</span><br><span class="line">inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。</span><br><span class="line">unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则</span><br><span class="line">使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://www.zhangxinxu.com/wordpress/2016/03/know-about-css3-all/">《简单了解 CSS3 的 all 属性》</a><br><a name="q0OQB"></a></p>
<h2 id="40-为什么不建议使用统配符初始化-css-样式。"><a href="#40-为什么不建议使用统配符初始化-css-样式。" class="headerlink" title="40.为什么不建议使用统配符初始化 css 样式。"></a>40.为什么不建议使用统配符初始化 css 样式。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">采用*&#123;pading:0;margin:0;&#125;这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，</span><br><span class="line">样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一</span><br><span class="line">套初始化样式。</span><br><span class="line">出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即</span><br><span class="line">可，并不需使用通配符*来初始化。</span><br></pre></td></tr></table></figure>
<p><a name="s1GCg"></a></p>
<h2 id="41-absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？"><a href="#41-absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？" class="headerlink" title="41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？"></a>41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）内联元素也可以作为“包含块”所在的元素；</span><br><span class="line">（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；</span><br><span class="line">（3）边界是paddingbox而不是contentbox。</span><br></pre></td></tr></table></figure>
<p><a name="VA4nq"></a></p>
<h2 id="42-对于-hasLayout-的理解？"><a href="#42-对于-hasLayout-的理解？" class="headerlink" title="42.对于 hasLayout 的理解？"></a>42.对于 hasLayout 的理解？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hasLayout是IE特有的一个属性。很多的IE下的cssbug都与其息息相关。在IE中，一个元素要么自己对自身的内容进</span><br><span class="line">行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可</span><br><span class="line">能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完</span><br><span class="line">成这些工作。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://segmentfault.com/a/1190000010883974">《CSS 基础篇–CSS 中 IE 浏览器的 hasLayout，IE 低版本的 bug 根源》</a><br /><a href="https://link.zhihu.com/?target=https://segmentfault.com/a/1190000004632071">《CSS 魔法堂：hasLayout 原来是这样的！》</a><br><a name="Z1TdK"></a></p>
<h2 id="43-元素竖向的百分比设定是相对于容器的高度吗？"><a href="#43-元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="43.元素竖向的百分比设定是相对于容器的高度吗？"></a>43.元素竖向的百分比设定是相对于容器的高度吗？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果是height的话，是相对于包含块的高度。</span><br><span class="line">如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。</span><br></pre></td></tr></table></figure>
<p><a name="LOmVy"></a></p>
<h2 id="44-全屏滚动的原理是什么？用到了-CSS-的哪些属性？（待深入实践）"><a href="#44-全屏滚动的原理是什么？用到了-CSS-的哪些属性？（待深入实践）" class="headerlink" title="44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）"></a>44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，容器及容</span><br><span class="line">器内的页面取当前可视区高度，同时容器的父级元素overflow属性值设为hidden，通过更改容器可视区的位置来实现全</span><br><span class="line">屏滚动效果。主要是响应鼠标事件，页面通过CSS的动画效果，进行移动。</span><br><span class="line">overflow：hidden；transition：all1000msease；</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/liona_koukou/article/details/52680409">《js 实现网页全屏切换（平滑过渡），鼠标滚动切换》</a><br /><a href="https://link.zhihu.com/?target=https://juejin.im/post/5aeef41cf265da0ba0630de0">《用 ES6 写全屏滚动插件》</a><br><a name="jtTFy"></a></p>
<h2 id="45-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？（待深入了解）"><a href="#45-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？（待深入了解）" class="headerlink" title="45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）"></a>45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏</span><br><span class="line">幕尺寸做处理。页面头部必须有meta声明的viewport。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/dreamerframework/article/details/8994741">《响应式布局原理》</a><br /><a href="https://link.zhihu.com/?target=http://www.mahaixiang.cn/wzsj/278.html">《响应式布局的实现方法和原理》</a><br><a name="3gFxD"></a></p>
<h2 id="46-视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）"><a href="#46-视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）" class="headerlink" title="46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）"></a>46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20990029">《如何实现视差滚动效果的网页？》</a><br><a name="sjwct"></a></p>
<h2 id="47-如何修改-chrome-记住密码后自动填充表单的黄色背景？"><a href="#47-如何修改-chrome-记住密码后自动填充表单的黄色背景？" class="headerlink" title="47.如何修改 chrome 记住密码后自动填充表单的黄色背景？"></a>47.如何修改 chrome 记住密码后自动填充表单的黄色背景？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的in</span><br><span class="line">put表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：</span><br><span class="line">&#123;</span><br><span class="line">background-color:rgb(250,255,189)!important;</span><br><span class="line">background-image:none!important;</span><br><span class="line">color:rgb(0,0,0)!important;</span><br><span class="line">&#125;</span><br><span class="line">对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是</span><br><span class="line">其他属性可使用。</span><br><span class="line">使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下</span><br><span class="line">input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill&#123;</span><br><span class="line">-webkit-box-shadow:000px1000pxwhiteinset;</span><br><span class="line">border:1pxsolid#CCC!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/zsl_955200/article/details/78276209">《去掉 chrome 记住密码后的默认填充样式》</a><br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/M_agician/article/details/73381706">《修改谷歌浏览器 chrome 记住密码后自动填充表单的黄色背景》</a><br><a name="0QwuV"></a></p>
<h2 id="48-怎么让-Chrome-支持小于-12px-的文字？"><a href="#48-怎么让-Chrome-支持小于-12px-的文字？" class="headerlink" title="48.怎么让 Chrome 支持小于 12px 的文字？"></a>48.怎么让 Chrome 支持小于 12px 的文字？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</span><br><span class="line">解决办法：</span><br><span class="line">（1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size</span><br><span class="line">-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器</span><br><span class="line">已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</span><br><span class="line">（2）还可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.</span><br><span class="line">75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block&#x2F;</span><br><span class="line">inline-block&#x2F;...；</span><br><span class="line">（3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://570109268.iteye.com/blog/2406562">《谷歌浏览器不支持 CSS 设置小于 12px 的文字怎么办？》</a><br><a name="FLUT1"></a></p>
<h2 id="49-让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#49-让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="49.让页面里的字体变清晰，变细用 CSS 怎么做？"></a>49.让页面里的字体变清晰，变细用 CSS 怎么做？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webkit内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。</span><br><span class="line">在MacOS测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设</span><br><span class="line">置后无效。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/huo_bao/article/details/50251585">《让字体变的更清晰 CSS 中-webkit-font-smoothing》</a><br><a name="0Z3qJ"></a></p>
<h2 id="50-font-style-属性中-italic-和-oblique-的区别？"><a href="#50-font-style-属性中-italic-和-oblique-的区别？" class="headerlink" title="50.font-style 属性中 italic 和 oblique 的区别？"></a>50.font-style 属性中 italic 和 oblique 的区别？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">italic和oblique这两个关键字都表示“斜体”的意思。</span><br><span class="line">它们的区别在于，italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，</span><br><span class="line">则退而求其次，解析为oblique，也就是单纯形状倾斜。</span><br></pre></td></tr></table></figure>
<p><a name="9D6gT"></a></p>
<h2 id="51-设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？"><a href="#51-设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？" class="headerlink" title="51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？"></a>51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。</span><br><span class="line">css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相</span><br><span class="line">对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。</span><br><span class="line">dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr&#x3D;1。在iphone4时，苹果推出了retina屏幕，它的dpr</span><br><span class="line">为2。屏幕的缩放会改变dpr的值。</span><br><span class="line">ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/libin-1/p/7148377.html">《什么是物理像素、虚拟像素、逻辑像素、设备像素，什么又是 PPI,DPI,DPR 和 DIP》</a><br /><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/af6dad66e49a">《前端工程师需要明白的「像素」》</a><br /><a href="https://link.zhihu.com/?target=https://github.com/jawil/blog/issues/21">《CSS 像素、物理像素、逻辑像素、设备像素比、PPI、Viewport》</a><br /><a href="https://link.zhihu.com/?target=https://github.com/wujunchuan/wujunchuan.github.io/issues/15">《前端开发中像素的概念》</a><br><a name="xcvuF"></a></p>
<h2 id="52-layoutviewport、visualviewport-和-idealviewport-的区别？"><a href="#52-layoutviewport、visualviewport-和-idealviewport-的区别？" class="headerlink" title="52.layoutviewport、visualviewport 和 idealviewport 的区别？"></a>52.layoutviewport、visualviewport 和 idealviewport 的区别？</h2><p>相关知识点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定</span><br><span class="line">默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。</span><br><span class="line">ppk把这个浏览器默认的viewport叫做layoutviewport。</span><br><span class="line">layoutviewport的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小，ppk把</span><br><span class="line">这个viewport叫做visualviewport。</span><br><span class="line">idealviewport是最适合移动设备的viewport，idealviewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元</span><br><span class="line">素的宽度设为idealviewport的宽度（单位用px），那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。i</span><br><span class="line">dealviewport的意义在于，无论在何种分辨率的屏幕下，那些针对idealviewport而设计的网站，不需要用户手动缩放，也</span><br><span class="line">不需要出现横向滚动条，都可以完美的呈现给用户。</span><br></pre></td></tr></table></figure>
<p>回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">移动端一共需要理解三个viewport的概念的理解。</span><br><span class="line">第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整</span><br><span class="line">个页面的布局都会显示错乱。所以移动端浏览器提供了一个layoutviewport布局视口的概念，使用这个视口来对页面进行布局展</span><br><span class="line">示，一般layoutviewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。</span><br><span class="line">第二个视口指的是视觉视口，visualviewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visu</span><br><span class="line">alviewport和layoutviewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口</span><br><span class="line">中的网页内容。</span><br><span class="line">第三个视口是理想视口，由于layoutviewport一般比visualviewport要大，所以想要看到整个页面必须通过拖动和缩放才</span><br><span class="line">能实现。所以又提出了idealviewport的概念，idealviewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在</span><br><span class="line">不同分辨率下显示的内容大小相同。idealviewport其实就是通过修改layoutviewport的大小，让它等于设备的宽度，这个</span><br><span class="line">宽度可以理解为是设备独立像素，因此根据idealviewport设计的页面，在不同分辨率的屏幕下，显示应该相同。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/2050/p/3877280.html">《移动前端开发之 viewport 的深入理解》</a><br /><a href="https://link.zhihu.com/?target=https://www.html.cn/archives/5975">《说说移动前端中 viewport（视口）》</a><br /><a href="https://link.zhihu.com/?target=https://juejin.im/post/5b6d21daf265da0f9d1a2ed7%23heading-14">《移动端适配知识你到底知多少》</a><br><a name="jc3Hq"></a></p>
<h2 id="53-position-fixed-在-android-下无效怎么处理？"><a href="#53-position-fixed-在-android-下无效怎么处理？" class="headerlink" title="53.position:fixed;在 android 下无效怎么处理？"></a>53.position:fixed;在 android 下无效怎么处理？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">因为移动端浏览器默认的viewport叫做layoutviewport。在移动端显示时，因为layoutviewport的宽度大于移动端屏幕</span><br><span class="line">的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layoutviewport来固定位置的，而不是移动端屏幕来固定位置的</span><br><span class="line">，所以会出现感觉fixed无效的情况。</span><br><span class="line">如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为idealviewport，可以如下设置：</span><br><span class="line">&lt;metaname&#x3D;&quot;viewport&quot;content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1.0,maximum-scale&#x3D;1.0,minimum-sca</span><br><span class="line">le&#x3D;1.0,user-scalable&#x3D;no&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p><a name="OFlDL"></a></p>
<h2 id="54-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"><a href="#54-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）" class="headerlink" title="54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"></a>54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1&#x2F;60*1000ms＝16.7ms</span><br></pre></td></tr></table></figure>
<p><a name="TlFON"></a></p>
<h2 id="55-如何让去除-inline-block-元素间间距？"><a href="#55-如何让去除-inline-block-元素间间距？" class="headerlink" title="55.如何让去除 inline-block 元素间间距？"></a>55.如何让去除 inline-block 元素间间距？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%25E5%258E%25BB%25E9%2599%25A4%25E9%2597%25B4%25E8%25B7%259D/">《去除 inline-block 元素间间距的 N 种方法》</a><br><a name="SgCLQ"></a></p>
<h2 id="56-overflow-scroll-时不能平滑滚动的问题怎么处理？"><a href="#56-overflow-scroll-时不能平滑滚动的问题怎么处理？" class="headerlink" title="56.overflow:scroll 时不能平滑滚动的问题怎么处理？"></a>56.overflow:scroll 时不能平滑滚动的问题怎么处理？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以下代码可解决这种卡顿的问题：-webkit-overflow-scrolling:touch;是因为这行代码启用了硬件加速特性，所以滑动很流</span><br><span class="line">畅。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/1f4693d0ad2d">《解决页面使用 overflow:scroll 在 iOS 上滑动卡顿的问题》</a><br><a name="9pgLc"></a></p>
<h2 id="57-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度。"><a href="#57-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度。" class="headerlink" title="57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。"></a>57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）外层div使用position：relative；高度要求自适应的div使用position:absolute;top:100px;bottom:0;</span><br><span class="line">left:0;right:0;</span><br><span class="line">（2）使用flex布局，设置主轴为竖轴，第二个div的flex-grow为1。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/xutongbao/article/details/79408522">《有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度(三种方案)》</a><br><a name="9TpAX"></a></p>
<h2 id="58-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？"><a href="#58-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？" class="headerlink" title="58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？"></a>58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</h2><p>相关知识点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">（1）BMP，是无损的、既支持索引色也支持直接色的、点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常</span><br><span class="line">具有较大的文件大小。</span><br><span class="line">（2）GIF是无损的、采用索引色的、点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具</span><br><span class="line">有支持动画以及透明的优点。但，GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积</span><br><span class="line">较小的场景。</span><br><span class="line">（3）JPEG是有损的、采用直接色的、点阵图。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来</span><br><span class="line">存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，</span><br><span class="line">又会导致图片文件较GIF更大。</span><br><span class="line">（4）PNG-8是无损的、使用索引色的、点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的</span><br><span class="line">情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8</span><br><span class="line">还支持透明度的调节，而GIF并不支持。现在，除非需要动画的支持，否则我们没有理由使用GIF而不是PNG-8。</span><br><span class="line">（5）PNG-24是无损的、使用直接色的、点阵图。PNG-24的优点在于，它压缩了图片的数据，使得同样效果的图片，PNG-24格</span><br><span class="line">式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</span><br><span class="line">（6）SVG是无损的、矢量图。SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图</span><br><span class="line">片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企</span><br><span class="line">业Logo、Icon等。</span><br><span class="line">（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。从名字就可以看出来它是</span><br><span class="line">为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，</span><br><span class="line">如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。</span><br><span class="line">•在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</span><br><span class="line">•在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</span><br><span class="line">•WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</span><br><span class="line">但是目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</span><br></pre></td></tr></table></figure>
<p>回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我了解到的一共有七种常见的图片的格式。</span><br><span class="line">（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比</span><br><span class="line">较大。</span><br><span class="line">（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还</span><br><span class="line">支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。</span><br><span class="line">（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但</span><br><span class="line">由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。</span><br><span class="line">（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并</span><br><span class="line">且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。</span><br><span class="line">（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP</span><br><span class="line">格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。</span><br><span class="line">（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般</span><br><span class="line">适合于用来制作一些网站logo或者图标之类的图片。</span><br><span class="line">（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相</span><br><span class="line">同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，</span><br><span class="line">这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/xinzhao/p/5130410.html">《图片格式那么多，哪种更适合你？》</a><br><a name="OHnwW"></a></p>
<h2 id="59-浏览器如何判断是否支持-webp-格式图片"><a href="#59-浏览器如何判断是否支持-webp-格式图片" class="headerlink" title="59.浏览器如何判断是否支持 webp 格式图片"></a>59.浏览器如何判断是否支持 webp 格式图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如</span><br><span class="line">果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格</span><br><span class="line">式的图片。</span><br><span class="line">（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断</span><br><span class="line">返回值中是否含有image&#x2F;webp字段，如果包含则说明支持WebP，反之则不支持。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/jesslu/article/details/82495061">《判断浏览器是否支持 WebP 图片》</a><br /><a href="https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL">《toDataURL()》</a><br><a name="fWxbj"></a></p>
<h2 id="60-什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）"><a href="#60-什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）" class="headerlink" title="60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）"></a>60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。</span><br><span class="line">如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开</span><br><span class="line">，静态资源放CDN。</span><br><span class="line">因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请</span><br><span class="line">求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</span><br><span class="line">同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的</span><br><span class="line">http请求的解析速度。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36514327?rf=37353035">《CDN 是什么？使用 CDN 有什么优势？》</a><br><a name="XzsJG"></a></p>
<h2 id="61-style-标签写在-body-后与-body-前有什么区别？"><a href="#61-style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="61.style 标签写在 body 后与 body 前有什么区别？"></a>61.style 标签写在 body 后与 body 前有什么区别？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式</span><br><span class="line">表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可</span><br><span class="line">能会出现FOUC现象（即样式失效导致的页面闪烁问题）</span><br></pre></td></tr></table></figure>
<p><a name="hUWcW"></a></p>
<h2 id="62-什么是-CSS-预处理器-后处理器？"><a href="#62-什么是-CSS-预处理器-后处理器？" class="headerlink" title="62.什么是 CSS 预处理器/后处理器？"></a>62.什么是 CSS 预处理器/后处理器？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成</span><br><span class="line">文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然</span><br><span class="line">后再编译成正常的CSS文件。</span><br><span class="line">预处理器例如：LESS、Sass、Stylus，用来预编译Sass或lesscsssprite，增强了css代码的复用性，还有层级、mixin、</span><br><span class="line">变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</span><br><span class="line">CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后</span><br><span class="line">处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，</span><br><span class="line">以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。</span><br><span class="line">后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏</span><br><span class="line">览器私有前缀，实现跨浏览器兼容性的问题。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/yushuangyushuang/article/details/79209752">《CSS 预处理器和后处理器》</a><br><a name="6eIqs"></a></p>
<h2 id="63-阐述一下-CSSSprites"><a href="#63-阐述一下-CSSSprites" class="headerlink" title="63.阐述一下 CSSSprites"></a>63.阐述一下 CSSSprites</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background</span><br><span class="line">-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites</span><br><span class="line">能减少图片的字节。</span><br><span class="line">优点：</span><br><span class="line">减少HTTP请求数，极大地提高页面加载速度</span><br><span class="line">增加图片信息重复度，提高压缩比，减少图片大小</span><br><span class="line">更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</span><br><span class="line">缺点：</span><br><span class="line">图片合并麻烦</span><br><span class="line">维护麻烦，修改一个图片可能需要重新布局整个图片，样式</span><br></pre></td></tr></table></figure>
<p><a name="BgIds"></a></p>
<h2 id="64-使用-rem-布局的优缺点？"><a href="#64-使用-rem-布局的优缺点？" class="headerlink" title="64.使用 rem 布局的优缺点？"></a>64.使用 rem 布局的优缺点？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。</span><br><span class="line">而且现在浏览器基本都已经支持rem了，兼容性也非常的好。</span><br><span class="line">缺点：</span><br><span class="line">（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。</span><br><span class="line">（2）使用iframe引用也会出现问题。</span><br><span class="line">（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问</span><br><span class="line">题。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21504656">《css3 的字体大小单位 rem 到底好在哪？》</a><br /><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/e8ae1c3861dc">《VW:是时候放弃 REM 布局了》</a><br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/Honeymao/article/details/76795089">《为什么设计稿是 750px》</a><br /><a href="https://link.zhihu.com/?target=https://github.com/amfe/article/issues/17">《使用 Flexible 实现手淘 H5 页面的终端适配》</a><br><a name="cfOaz"></a></p>
<h2 id="65-几种常见的-CSS-布局"><a href="#65-几种常见的-CSS-布局" class="headerlink" title="65.几种常见的 CSS 布局"></a>65.几种常见的 CSS 布局</h2><p>详细的资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://juejin.im/post/5bbcd7ff5188255c80668028%23heading-12">《几种常见的 CSS 布局》</a><br><a name="PJjoI"></a></p>
<h2 id="66-画一条-0-5px-的线"><a href="#66-画一条-0-5px-的线" class="headerlink" title="66.画一条 0.5px 的线"></a>66.画一条 0.5px 的线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">采用metaviewport的方式</span><br><span class="line">采用border-image的方式</span><br><span class="line">采用transform:scale()的方式</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://juejin.im/post/5ab65f40f265da2384408a95">《怎么画一条 0.5px 的边（更新）》</a><br><a name="QS5jk"></a></p>
<h2 id="67-transition-和-animation-的区别"><a href="#67-transition-和-animation-的区别" class="headerlink" title="67.transition 和 animation 的区别"></a>67.transition 和 animation 的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transition关注的是CSSproperty的变化，property值和时间的关系是一个三次贝塞尔曲线。</span><br><span class="line">animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19749045">《CSSanimation 与 CSStransition 有何区别？》</a><br /><a href="https://link.zhihu.com/?target=https://blog.csdn.net/cddcj/article/details/53582334">《CSS3Transition 和 Animation 区别及比较》</a><br /><a href="https://link.zhihu.com/?target=http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html">《CSS 动画简介》</a><br /><a href="https://link.zhihu.com/?target=https://juejin.im/post/5b137e6e51882513ac201dfb">《CSS 动画：animation、transition、transform、translate》</a><br><a name="Wqsb2"></a></p>
<h2 id="68-什么是首选最小宽度？"><a href="#68-什么是首选最小宽度？" class="headerlink" title="68.什么是首选最小宽度？"></a>68.什么是首选最小宽度？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“首选最小宽度”，指的是元素最适合的最小宽度。</span><br><span class="line">东亚文字（如中文）最小宽度为每个汉字的宽度。</span><br><span class="line">西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短</span><br><span class="line">横线、问号以及其他非英文字符等。</span><br><span class="line">如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。</span><br></pre></td></tr></table></figure>
<p><a name="SyRlR"></a></p>
<h2 id="69-为什么-height-100-会无效？"><a href="#69-为什么-height-100-会无效？" class="headerlink" title="69.为什么 height:100%会无效？"></a>69.为什么 height:100%会无效？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。</span><br><span class="line">原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，</span><br><span class="line">所以无法参与计算。</span><br><span class="line">使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。</span><br></pre></td></tr></table></figure>
<p><a name="9D7Qb"></a></p>
<h2 id="70-min-width-max-width-和-min-height-max-height-属性间的覆盖规则？"><a href="#70-min-width-max-width-和-min-height-max-height-属性间的覆盖规则？" class="headerlink" title="70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？"></a>70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）max-width会覆盖width，即使width是行类样式或者设置了!important。</span><br><span class="line">（2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。</span><br></pre></td></tr></table></figure>
<p><a name="TJysP"></a></p>
<h2 id="71-内联盒模型基本概念"><a href="#71-内联盒模型基本概念" class="headerlink" title="71.内联盒模型基本概念"></a>71.内联盒模型基本概念</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）内容区域（contentarea）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子</span><br><span class="line">（characterbox）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些</span><br><span class="line">元素，内容区域可以看成元素自身。</span><br><span class="line">（2）内联盒子（inlinebox）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒</span><br><span class="line">子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。</span><br><span class="line">（3）行框盒子（linebox），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。</span><br><span class="line">（4）包含块（containingbox），由一行一行的“行框盒子”组成。</span><br></pre></td></tr></table></figure>
<p><a name="7YprA"></a></p>
<h2 id="72-什么是幽灵空白节点？"><a href="#72-什么是幽灵空白节点？" class="headerlink" title="72.什么是幽灵空白节点？"></a>72.什么是幽灵空白节点？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同</span><br><span class="line">每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵</span><br><span class="line">一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。</span><br></pre></td></tr></table></figure>
<p><a name="ZiaNl"></a></p>
<h2 id="73-什么是替换元素？"><a href="#73-什么是替换元素？" class="headerlink" title="73.什么是替换元素？"></a>73.什么是替换元素？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;iframe&gt;或者表</span><br><span class="line">单元素&lt;textarea&gt;和&lt;input&gt;和&lt;select&gt;都是典型的替换元素。</span><br><span class="line">替换元素除了内容可替换这一特性以外，还有以下一些特性。</span><br><span class="line">（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要</span><br><span class="line">类似appearance属性，或者浏览器自身暴露的一些样式接口，</span><br><span class="line">（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像</span><br><span class="line">素，如&lt;video&gt;、&lt;iframe&gt;或者&lt;canvas&gt;等，也有少部分替换元素为0像素，如&lt;img&gt;图片，而表单元素的替换元素</span><br><span class="line">的尺寸则和浏览器有关，没有明显的规律。</span><br><span class="line">（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，ve</span><br><span class="line">rtical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，</span><br><span class="line">被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</span><br><span class="line">（4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认</span><br><span class="line">的display值却是不一样的，有的是inline，有的是inline-block。</span><br></pre></td></tr></table></figure>
<p><a name="F9IVH"></a></p>
<h2 id="74-替换元素的计算规则？"><a href="#74-替换元素的计算规则？" class="headerlink" title="74.替换元素的计算规则？"></a>74.替换元素的计算规则？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。</span><br><span class="line">（1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</span><br><span class="line">（2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括&lt;img&gt;的width和height属性、&lt;input&gt;的s</span><br><span class="line">ize属性、&lt;textarea&gt;的cols和rows属性等。</span><br><span class="line">（3）CSS尺寸特指可以通过CSS的width和height或者max-width&#x2F;min-width和max-height&#x2F;min-height设置的</span><br><span class="line">尺寸，对应盒尺寸中的contentbox。</span><br><span class="line">这3层结构的计算规则具体如下</span><br><span class="line">（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。</span><br><span class="line">（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</span><br><span class="line">（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。</span><br><span class="line">（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。</span><br><span class="line">（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。</span><br><span class="line">（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</span><br></pre></td></tr></table></figure>
<p><a name="Wd8ly"></a></p>
<h2 id="75-content-与替换元素的关系？"><a href="#75-content-与替换元素的关系？" class="headerlink" title="75.content 与替换元素的关系？"></a>75.content 与替换元素的关系？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">content属性生成的对象称为“匿名替换元素”。</span><br><span class="line">（1）我们使用content生成的文本是无法选中、无法复制的，好像设置了userselect:none声明一般，但是普通元素的文本</span><br><span class="line">却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是</span><br><span class="line">地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。</span><br><span class="line">（2）content生成的内容不能左右:empty伪类。</span><br><span class="line">（3）content动态生成值无法获取。</span><br></pre></td></tr></table></figure>
<p><a name="9QoDW"></a></p>
<h2 id="76-margin-auto-的填充规则？"><a href="#76-margin-auto-的填充规则？" class="headerlink" title="76.margin:auto 的填充规则？"></a>76.margin:auto 的填充规则？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">margin的&#39;auto&#39;可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发mar</span><br><span class="line">gin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。</span><br><span class="line">（1）如果一侧定值，一侧auto，则auto为剩余空间大小。</span><br><span class="line">（2）如果两侧均是auto，则平分剩余空间。</span><br></pre></td></tr></table></figure>
<p><a name="G16Jr"></a></p>
<h2 id="77-margin-无效的情形"><a href="#77-margin-无效的情形" class="headerlink" title="77.margin 无效的情形"></a>77.margin 无效的情形</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有ma</span><br><span class="line">rgin合并的问题。</span><br><span class="line">（2）表格中的&lt;tr&gt;和&lt;td&gt;元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。</span><br><span class="line">（3）绝对定位元素非定位方位的margin值“无效”。</span><br><span class="line">（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。</span><br></pre></td></tr></table></figure>
<p><a name="153cP"></a></p>
<h2 id="78-border-的特殊性？"><a href="#78-border-的特殊性？" class="headerlink" title="78.border 的特殊性？"></a>78.border 的特殊性？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）border-width却不支持百分比。</span><br><span class="line">（2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-col</span><br><span class="line">or没有边框显示的原因。</span><br><span class="line">（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。</span><br><span class="line">（4）border-color默认颜色就是color色值。</span><br><span class="line">（5）默认background背景图片是相对于paddingbox定位的。</span><br></pre></td></tr></table></figure>
<p><a name="4bpQx"></a></p>
<h2 id="79-什么是基线和-x-height？"><a href="#79-什么是基线和-x-height？" class="headerlink" title="79.什么是基线和 x-height？"></a>79.什么是基线和 x-height？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字母x的下边缘（线）就是我们的基线。</span><br><span class="line">x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在C</span><br><span class="line">SS世界中，middle指的是基线往上1&#x2F;2x-height高度。我们可以近似理解为字母x交叉点那个位置。</span><br><span class="line">ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影</span><br><span class="line">响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。</span><br></pre></td></tr></table></figure>
<p><a name="ma9bQ"></a></p>
<h2 id="80-line-height-的特殊性？"><a href="#80-line-height-的特殊性？" class="headerlink" title="80.line-height 的特殊性？"></a>80.line-height 的特殊性？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高</span><br><span class="line">度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。</span><br><span class="line">（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作</span><br><span class="line">用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是</span><br><span class="line">有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。</span><br><span class="line">（3）行距&#x3D;line-height-font-size。</span><br><span class="line">（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下</span><br><span class="line">边距，则向上取整。</span><br><span class="line">（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。</span><br><span class="line">（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是</span><br><span class="line">通过改变块级元素里面内联级别元素占据的高度实现的。</span><br><span class="line">（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-si</span><br><span class="line">ze相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。</span><br><span class="line">（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为</span><br><span class="line">属性值，那么所有的子元素继承的是最终的计算值。</span><br><span class="line">（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。</span><br><span class="line">（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个</span><br><span class="line">“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。</span><br></pre></td></tr></table></figure>
<p><a name="j5Qjf"></a></p>
<h2 id="81-vertical-align-的特殊性？"><a href="#81-vertical-align-的特殊性？" class="headerlink" title="81.vertical-align 的特殊性？"></a>81.vertical-align 的特殊性？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字</span><br><span class="line">母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面</span><br><span class="line">没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行</span><br><span class="line">内联元素的基线。</span><br><span class="line">（2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display</span><br><span class="line">计算值是table-cell的元素，我们不妨脑补成&lt;td&gt;元素，则和&lt;tr&gt;元素上边缘对齐。</span><br><span class="line">（3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1&#x2F;2x-height处对齐。对</span><br><span class="line">于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。</span><br><span class="line">（4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上</span><br><span class="line">偏移。</span><br><span class="line">（5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。</span><br><span class="line">（6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元</span><br><span class="line">素。</span><br><span class="line">（7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。</span><br></pre></td></tr></table></figure>
<p><a name="1XORd"></a></p>
<h2 id="82-overflow-的特殊性？"><a href="#82-overflow-的特殊性？" class="headerlink" title="82.overflow 的特殊性？"></a>82.overflow 的特殊性？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度</span><br><span class="line">高度限制的时候，剪裁的边界是borderbox的内边缘，而非paddingbox的内边缘。</span><br><span class="line">（2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素&lt;html&gt;，另一个是文本域&lt;textarea&gt;。</span><br><span class="line">（3）滚动条会占用容器的可用宽度或高度。</span><br><span class="line">（4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！</span><br></pre></td></tr></table></figure>
<p><a name="rOk2J"></a></p>
<h2 id="83-无依赖绝对定位是什么？"><a href="#83-无依赖绝对定位是什么？" class="headerlink" title="83.无依赖绝对定位是什么？"></a>83.无依赖绝对定位是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没有设置left&#x2F;top&#x2F;right&#x2F;bottom属性值的绝对定位称为“无依赖绝对定位”。</span><br><span class="line">无依赖绝对定位其定位的位置和没有设置position:absolute时候的位置相关。</span><br></pre></td></tr></table></figure>
<p><a name="UXKMD"></a></p>
<h2 id="84-absolute-与-overflow-的关系？"><a href="#84-absolute-与-overflow-的关系？" class="headerlink" title="84.absolute 与 overflow 的关系？"></a>84.absolute 与 overflow 的关系？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute</span><br><span class="line">元素进行剪裁。</span><br><span class="line">（2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也</span><br><span class="line">都不会出现滚动条。</span><br><span class="line">（3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。</span><br></pre></td></tr></table></figure>
<p><a name="p0wsA"></a></p>
<h2 id="85-clip-裁剪是什么？"><a href="#85-clip-裁剪是什么？" class="headerlink" title="85.clip 裁剪是什么？"></a>85.clip 裁剪是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。</span><br><span class="line">clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。</span><br></pre></td></tr></table></figure>
<p><a name="V43Xh"></a></p>
<h2 id="86-relative-的特殊性？"><a href="#86-relative-的特殊性？" class="headerlink" title="86.relative 的特殊性？"></a>86.relative 的特殊性？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）相对定位元素的left&#x2F;top&#x2F;right&#x2F;bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。</span><br><span class="line">（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。</span><br><span class="line">（3）当相对定位元素同时应用对立方向定位值的时候，也就是top&#x2F;bottom和left&#x2F;right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top&#x2F;bottom同时使用的时候，bottom失效；left&#x2F;right同时使用的时候，right失效。</span><br></pre></td></tr></table></figure>
<p><a name="YXoms"></a></p>
<h2 id="87-什么是层叠上下文？"><a href="#87-什么是层叠上下文？" class="headerlink" title="87.什么是层叠上下文？"></a>87.什么是层叠上下文？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">层叠上下文，英文称作stackingcontext，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元</span><br><span class="line">素在z轴上就“高人一等”。</span><br><span class="line">层叠上下文元素有如下特性：</span><br><span class="line">（1）层叠上下文的层叠水平要比普通元素高（原因后面会说明）。</span><br><span class="line">（2）层叠上下文可以阻断元素的混合模式。</span><br><span class="line">（3）层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。</span><br><span class="line">（4）每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。</span><br><span class="line">（5）每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</span><br><span class="line">层叠上下文的创建：</span><br><span class="line">（1）页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是&lt;html&gt;元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。</span><br><span class="line">（2）对于position值为relative&#x2F;absolute以及Firefox&#x2F;IE浏览器（不包括Chrome浏览器）下含有position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。Chrome等WebKit内核浏览器下，position:fixed元素天然层叠上下文元素，无须z-index为数值。根据我的测试，目前IE和Firefox仍是老套路。</span><br><span class="line">（3）其他一些CSS3属性，比如元素的opacity值不是1。</span><br></pre></td></tr></table></figure>
<p><a name="AQIaR"></a></p>
<h2 id="88-什么是层叠水平？"><a href="#88-什么是层叠水平？" class="headerlink" title="88.什么是层叠水平？"></a>88.什么是层叠水平？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">层叠水平，英文称作stackinglevel，决定了同一个层叠上下文中元素在z轴上的显示顺序。</span><br><span class="line">显而易见，所有的元素都有层叠水平，包括层叠上下文元素，也包括普通元素。然而，对普通元素的层叠水平探讨只局限在当前层叠上</span><br><span class="line">下文元素中。</span><br></pre></td></tr></table></figure>
<p><a name="rxcA0"></a></p>
<h2 id="89-元素的层叠顺序？"><a href="#89-元素的层叠顺序？" class="headerlink" title="89.元素的层叠顺序？"></a>89.元素的层叠顺序？</h2><p>层叠顺序，英文称作 stackingorder，表示元素发生层叠时有着特定的垂直显示顺序。<br /><br><br /><img src="https://pic3.zhimg.com/80/v2-06c60210df13e7677a031a3ff01beb9a_1440w.jpg#align=left&display=inline&message=%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5%EF%BC%8C%E8%AF%B7%E9%87%8D%E8%AF%95&percent=0&status=uploading&width=528"><br /></p>
<p><a name="bbBbP"></a></p>
<h2 id="90-层叠准则？"><a href="#90-层叠准则？" class="headerlink" title="90.层叠准则？"></a>90.层叠准则？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。</span><br><span class="line">（2）后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</span><br></pre></td></tr></table></figure>
<p><a name="KwWcT"></a></p>
<h2 id="91-font-weight-的特殊性？"><a href="#91-font-weight-的特殊性？" class="headerlink" title="91.font-weight 的特殊性？"></a>91.font-weight 的特殊性？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果使用数值作为font-weight属性值，必须是100～900的整百数。因为这里的数值仅仅是外表长得像数值，实际上是一个具有特定含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。</span><br></pre></td></tr></table></figure>
<p><a name="TOPko"></a></p>
<h2 id="92-text-indent-的特殊性？"><a href="#92-text-indent-的特殊性？" class="headerlink" title="92.text-indent 的特殊性？"></a>92.text-indent 的特殊性？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）text-indent仅对第一行内联盒子内容有效。</span><br><span class="line">（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block&#x2F;inli</span><br><span class="line">ne-table则会生效。</span><br><span class="line">（3）&lt;input&gt;标签按钮text-indent值无效。</span><br><span class="line">（4）&lt;button&gt;标签按钮text-indent值有效。</span><br><span class="line">（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。</span><br></pre></td></tr></table></figure>
<p><a name="UuUzW"></a></p>
<h2 id="93-letter-spacing-与字符间距？"><a href="#93-letter-spacing-与字符间距？" class="headerlink" title="93.letter-spacing 与字符间距？"></a>93.letter-spacing 与字符间距？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。</span><br><span class="line">letter-spacing具有以下一些特性。</span><br><span class="line">（1）继承性。</span><br><span class="line">（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。</span><br><span class="line">（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。</span><br><span class="line">（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。</span><br><span class="line">（5）支持小数值，即使0.1px也是支持的。</span><br><span class="line">（6）暂不支持百分比值。</span><br></pre></td></tr></table></figure>
<p><a name="fVadA"></a></p>
<h2 id="94-word-spacing-与单词间距？"><a href="#94-word-spacing-与单词间距？" class="headerlink" title="94.word-spacing 与单词间距？"></a>94.word-spacing 与单词间距？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙</span><br><span class="line">宽度。</span><br></pre></td></tr></table></figure>
<p><a name="W75zz"></a></p>
<h2 id="95-white-space-与换行和空格的控制？"><a href="#95-white-space-与换行和空格的控制？" class="headerlink" title="95.white-space 与换行和空格的控制？"></a>95.white-space 与换行和空格的控制？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）</span><br><span class="line">键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否</span><br><span class="line">生效）等。</span><br><span class="line">其属性值包括下面这些。</span><br><span class="line">•normal：合并空白字符和换行符。</span><br><span class="line">•pre：空白字符不合并，并且内容只在有换行符的地方换行。</span><br><span class="line">•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。</span><br><span class="line">•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。</span><br><span class="line">•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。</span><br></pre></td></tr></table></figure>
<p><a name="2cuX7"></a></p>
<h2 id="96-隐藏元素的-background-image-到底加不加载？"><a href="#96-隐藏元素的-background-image-到底加不加载？" class="headerlink" title="96.隐藏元素的 background-image 到底加不加载？"></a>96.隐藏元素的 background-image 到底加不加载？</h2><p>相关知识点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">根据测试，一个元素如果display计算值为none，在IE浏览器下（IE8～IE11，更高版本不确定）依然会发送图片请求，Fire</span><br><span class="line">fox浏览器不会，至于Chrome和Safari浏览器则似乎更加智能一点：如果隐藏元素同时又设置了background-image，则图片</span><br><span class="line">依然会去加载；如果是父元素的display计算值为none，则背景图不会请求，此时浏览器或许放心地认为这个背景图暂时是不会使</span><br><span class="line">用的。</span><br><span class="line">如果不是background-image，而是&lt;img&gt;元素，则设置display:none在所有浏览器下依旧都会请求图片资源。</span><br><span class="line">还需要注意的是如果设置的样式没有对应的元素，则background-image也不会加载。hover情况下的background-image，在触</span><br><span class="line">发时加载。</span><br></pre></td></tr></table></figure>
<p>回答：<br />-（1）元素的背景图片<br />-元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求<br />-:hover 样式下，触发时请求<br />-（2）img 标签图片任何情况下都会请求图片<br />详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://www.jb51.net/css/469033.html">《CSS 控制前端图片 HTTP 请求的各种情况示例》</a><br><a name="zTGnS"></a></p>
<h2 id="97-如何实现单行／多行文本溢出的省略（…）？"><a href="#97-如何实现单行／多行文本溢出的省略（…）？" class="headerlink" title="97.如何实现单行／多行文本溢出的省略（…）？"></a>97.如何实现单行／多行文本溢出的省略（…）？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*单行文本溢出*&#x2F;</span><br><span class="line">p &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*多行文本溢出*&#x2F;</span><br><span class="line">p &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  line-height: 1.5em;</span><br><span class="line">  &#x2F;*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*&#x2F;</span><br><span class="line">  height: 3em;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">p:after &#123;</span><br><span class="line">  content: &quot;...&quot;;</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  background-color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30707916">《【CSS/JS】如何实现单行／多行文本溢出的省略》</a><br /><a href="https://link.zhihu.com/?target=https://juejin.im/entry/587f453e1b69e60058555a5f">《CSS 多行文本溢出省略显示》</a><br><a name="pHTUO"></a></p>
<h2 id="98-常见的元素隐藏方式？"><a href="#98-常见的元素隐藏方式？" class="headerlink" title="98.常见的元素隐藏方式？"></a>98.常见的元素隐藏方式？</h2><p>-（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。<br />-（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。<br />-（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。<br />-（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。<br />-（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。<br />-（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。<br />-（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。<br />详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://juejin.im/post/584b645a128fe10058a0d625%23heading-2">《CSS 隐藏元素的八种方法》</a><br><a name="f7zHV"></a></p>
<h2 id="99-css-实现上下固定中间自适应布局？"><a href="#99-css-实现上下固定中间自适应布局？" class="headerlink" title="99.css 实现上下固定中间自适应布局？"></a>99.css 实现上下固定中间自适应布局？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">利用绝对定位实现body &#123;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">.header &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line">.container &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 100px;</span><br><span class="line">  bottom: 100px;</span><br><span class="line">  width: 100%;</span><br><span class="line">  background: green;</span><br><span class="line">&#125;</span><br><span class="line">.footer &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  height: 100px;</span><br><span class="line">  width: 100%;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line">利用flex布局实现html,</span><br><span class="line">body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">&#125;</span><br><span class="line">.header &#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line">.container &#123;</span><br><span class="line">  flex-grow: 1;</span><br><span class="line">  background: green;</span><br><span class="line">&#125;</span><br><span class="line">.footer &#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细资料可以参考：<br /><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/30bc9751e3e8">《css 实现上下固定中间自适应布局》</a><br><a name="i8rYX"></a></p>
<h2 id="100-css-两栏布局的实现？"><a href="#100-css-两栏布局的实现？" class="headerlink" title="100.css 两栏布局的实现？"></a>100.css 两栏布局的实现？</h2><p>相关资料：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。*&#x2F;</span><br><span class="line">&#x2F;*以左边宽度固定为200px为例*&#x2F;</span><br><span class="line">&#x2F;*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*&#x2F;</span><br><span class="line">.outer &#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  height: 100px;</span><br><span class="line">  width: 200px;</span><br><span class="line">  background: tomato;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">  margin-left: 200px;</span><br><span class="line">  width: auto;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: gold;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*（2）第二种是利用flex布局，将左边元素的放大和缩小比例设置为0，基础大小设置为200px。将右边的元素的放大比例设置为1，缩小比例设置为1，基础大小设置为auto。*&#x2F;</span><br><span class="line">.outer &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  flex-shrink: 0;</span><br><span class="line">  flex-grow: 0;</span><br><span class="line">  flex-basis: 200px;</span><br><span class="line">  background: tomato;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">  flex: auto;</span><br><span class="line">  &#x2F;*11auto*&#x2F;</span><br><span class="line">  background: gold;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为</span><br><span class="line">200px。将右边元素的margin-left的值设置为200px。*&#x2F;</span><br><span class="line">.outer &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: tomato;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">  margin-left: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: gold;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*&#x2F;</span><br><span class="line">.outer &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: tomato;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 200px;</span><br><span class="line">  background: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=http://cavszhouyou.top/Demo-Display/TwoColumnLayout/index.html">《两栏布局 demo 展示》</a><br />回答：<br />两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。<br />以左边宽度固定为 200px 为例<br />-（1）利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。<br />-（2）第二种是利用 flex 布局，将左边元素的放大和缩小比例设置为 0，基础大小设置为 200px。将右边的元素的放大比例设置为 1，缩小比例设置为 1，基础大小设置为 auto。<br />-（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。<br />-（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。<br><a name="n3zsV"></a></p>
<h2 id="101-css-三栏布局的实现？"><a href="#101-css-三栏布局的实现？" class="headerlink" title="101.css 三栏布局的实现？"></a>101.css 三栏布局的实现？</h2><p>相关资料：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</span><br><span class="line">这里以左边宽度固定为100px，右边宽度固定为200px为例。*&#x2F;</span><br><span class="line">&#x2F;*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*&#x2F;</span><br><span class="line">.outer &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: tomato;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: gold;</span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line">  margin-left: 100px;</span><br><span class="line">  margin-right: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto*&#x2F;</span><br><span class="line">.outer &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  flex: 00100px;</span><br><span class="line">  background: tomato;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">  flex: 00200px;</span><br><span class="line">  background: gold;</span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line">  flex: auto;</span><br><span class="line">  background: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*&#x2F;</span><br><span class="line">.outer &#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: tomato;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">  float: right;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: gold;</span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">  margin-left: 100px;</span><br><span class="line">  margin-right: 200px;</span><br><span class="line">  background: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*（4）双飞翼布局，利用浮动和负边距来实现。父级元素设置左右的pedding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。*&#x2F;</span><br><span class="line">.outer &#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">  padding-left: 100px;</span><br><span class="line">  padding-right: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  left: -100px;</span><br><span class="line">  float: left;</span><br><span class="line">  margin-left: -100%;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: tomato;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  left: 200px;</span><br><span class="line">  float: right;</span><br><span class="line">  margin-left: -200px;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: gold;</span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元</span><br><span class="line">素的pedding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*&#x2F;</span><br><span class="line">.outer &#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  margin-left: -100%;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: tomato;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  margin-left: -200px;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: gold;</span><br><span class="line">&#125;</span><br><span class="line">.wrapper &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line">  margin-left: 100px;</span><br><span class="line">  margin-right: 200px;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=http://cavszhouyou.top/Demo-Display/ThreeColumnLayout/index.html">《三栏布局 demo 展示》</a><br />回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</span><br><span class="line">这里以左边宽度固定为100px，右边宽度固定为200px为例。</span><br><span class="line">（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</span><br><span class="line">（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto。</span><br><span class="line">（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。</span><br><span class="line">（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的pedding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。双飞翼布局中间列的宽度不能小于两边任意列的宽度，而双飞翼布局则不存在这个问题。</span><br><span class="line">（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的pedding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</span><br></pre></td></tr></table></figure>
<p><a name="LPDLZ"></a></p>
<h2 id="102-实现一个宽高自适应的正方形"><a href="#102-实现一个宽高自适应的正方形" class="headerlink" title="102.实现一个宽高自适应的正方形"></a>102.实现一个宽高自适应的正方形</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*1.第一种方式是利用vw来实现*&#x2F;</span><br><span class="line">.square &#123;</span><br><span class="line">  width: 10%;</span><br><span class="line">  height: 10vw;</span><br><span class="line">  background: tomato;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*2.第二种方式是利用元素的margin&#x2F;padding百分比是相对父元素width的性质来实现*&#x2F;</span><br><span class="line">.square &#123;</span><br><span class="line">  width: 20%;</span><br><span class="line">  height: 0;</span><br><span class="line">  padding-top: 20%;</span><br><span class="line">  background: orange;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*3.第三种方式是利用子元素的margin-top的值来实现的*&#x2F;</span><br><span class="line">.square &#123;</span><br><span class="line">  width: 30%;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  background: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.square::after &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  display: block;</span><br><span class="line">  margin-top: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=http://cavszhouyou.top/Demo-Display/AdaptiveSquare/index.html">《自适应正方形 demo 展示》</a><br><a name="mUccf"></a></p>
<h2 id="103-实现一个三角形"><a href="#103-实现一个三角形" class="headerlink" title="103.实现一个三角形"></a>103.实现一个三角形</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*三角形的实现原理是利用了元素边框连接处的等分原理。*&#x2F;</span><br><span class="line">.triangle &#123;</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  border-width: 100px;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: tomatotransparenttransparenttransparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=http://cavszhouyou.top/Demo-Display/Triangle/index.html">《三角形 demo 展示》</a><br><a name="0cFSF"></a></p>
<h2 id="104-一个自适应矩形，水平垂直居中，且宽高比为-2-1"><a href="#104-一个自适应矩形，水平垂直居中，且宽高比为-2-1" class="headerlink" title="104.一个自适应矩形，水平垂直居中，且宽高比为 2:1"></a>104.一个自适应矩形，水平垂直居中，且宽高比为 2:1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*实现原理参考自适应正方形和水平居中方式*&#x2F;</span><br><span class="line">.box &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  margin: auto;</span><br><span class="line">  width: 10%;</span><br><span class="line">  height: 0;</span><br><span class="line">  padding-top: 20%;</span><br><span class="line">  background: tomato;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="pTE6E"></a></p>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>笔者再次墙裂推荐收藏这篇原文，转载于 <a href="https://link.zhihu.com/?target=https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/Css/Css.md">CavsZhouyou - 前端面试复习笔记</a>，这个仓库是原作者校招时的前端复习笔记，主要总结一些比较重要的知识点和前端面试问题，希望对大家有所帮助。<br />最后如果文章和笔记能带您一丝帮助或者启发，请不要吝啬你的赞和收藏，你的肯定是我前进的最大动力</p>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/hula_loop_octodex03.gif" alt="Zero"></figure><p class="title is-size-4 is-block line-height-inherit">Zero</p><p class="is-size-6 is-block">A GitHub Octocat</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>HangZhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/jizhi77" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/jizhi77"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%89%8D%E7%AB%AF/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/"><span class="level-start"><span class="level-item">所思所想</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"><span class="level-start"><span class="level-item">面试</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-28T03:48:42.296Z">2020-09-28</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/28/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/%E8%80%81%E7%A0%81%E5%86%9C%E7%9A%84%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">老码农的字节跳动前端面试总结</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-28T03:48:42.296Z">2020-09-28</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/28/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8C%20P6%20%E8%83%BD%E5%8A%9B/">阿里 P6 能力</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/">面试</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-28T03:48:42.292Z">2020-09-28</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/28/%E5%89%8D%E7%AB%AF/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/%E6%94%BF%E9%87%87%E4%BA%91-%E5%89%8D%E7%AB%AF%E6%96%B0%E4%BA%BA%E5%85%A5%E8%81%8C%E5%8E%86%E7%A8%8B/">政采云-前端新人入职历程</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/">所思所想</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-28T03:48:42.292Z">2020-09-28</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/28/%E5%89%8D%E7%AB%AF/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/%E4%BB%8E%201%20%E4%BA%BA%E5%88%B050%20%E5%A4%9A%E4%BA%BA%EF%BC%8C%E9%98%BF%E9%87%8C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%B5%84%E6%B7%B1%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E7%AE%A1%E7%90%86%E5%BF%83%E8%B7%AF/">从 1 人到50 多人，阿里人工智能资深技术专家管理心路</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/">所思所想</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-28T03:48:42.292Z">2020-09-28</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/28/%E5%89%8D%E7%AB%AF/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0%E5%92%8C%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E2%80%9C%E5%A4%A7%E5%89%8D%E7%AB%AF%E2%80%9D%E5%9B%A2%E9%98%9F?%E9%A5%BF%E4%BA%86%E4%B9%88%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%9B%A2%E9%98%9F%E8%A7%A3%E5%AF%86/">如何落地和管理一个“大前端”团队?饿了么大前端团队解密</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/">所思所想</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Zero`s House" height="28"></a><p class="size-small"><span>&copy; 2020 Zero</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://s9.cnzz.com/z_stat.php?id=1279310232&amp;web_id=1279310232" async></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><form class="searchbox-input-container"><input class="searchbox-input" name="wd" type="text" placeholder="想要查找什么..."></form><a class="searchbox-close" href="javascript:;">×</a></div></div></div><script>(function ($) {
            $('.searchbox-input-container').on('submit', function (e) {
                var keyword = $('.searchbox-input[name="wd"]').val();
                window.location = 'https://www.baidu.com/s?wd=site:jizhi77.github.io ' + keyword;
                return false;
            });
        })(jQuery);
        (function (document, $) {
            $(document).on('click', '.navbar-main .search', function () {
                $('.searchbox').toggleClass('show');
            }).on('click', '.searchbox .searchbox-mask', function () {
                $('.searchbox').removeClass('show');
            }).on('click', '.searchbox-close', function () {
                $('.searchbox').removeClass('show');
            });
        })(document, jQuery);</script></body></html>